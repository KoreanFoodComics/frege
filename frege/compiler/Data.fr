{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
 * This package defines most data structures used in the compiler.
 * Anything else is only used locally.
 -}


package frege.compiler.Data
        inline (stio, changeST, putST, getST) 
    where


import frege.List (Tree, each)
import frege.IO   (PrintWriter,  `<<`,  getProperty, URLClassLoader)

import frege.compiler.Classtools    as CT()
import frege.compiler.BaseTypes public


--- compiler options
data Options = !Options {
    source :: String,   -- our source file
    sourcePath :: [String], -- path names where source files can be found
    flags :: Flags,     -- some 'Flag's
    dir::String,        -- value of the -d option or "."
    path::[String],     -- value of the -fp option plus classpath depending on WITHCP
    prefix::String,     -- value of the -prefix option or ""
    encoding :: Maybe String,   -- used for construction of input file
    tRanges :: [(Int, Int)]     -- ranges for trace output
}

data Severity = HINT | WARNING | ERROR
data Message = !Msg { pos :: Position, level :: Severity, text :: String }

{-
    Informs how tokens like 'VARID', 'CONID' and 'QUALIFIER' have been
    resolved.
    
    [Left ()] this is a namespace name
    [Right _] this is a type name, member name, constructor or (local) variable 
-}
type IdInfo = Either () QName

--- items that are created early and seldom changed later so that copying them all the time is costly
data SubSt = !Sub {
    loader      :: URLClassLoader       --- class loader for access to imported classes
    cache       :: IORef (Tree String CT.FregePackage)
                                        {-- cache of packages where we know the class file is
                                            up to date, used/set in Main.fr and Import.fr -}
    optab       :: Tree String TokenID  --- operator table
    toks        :: Array Token          --- array of tokens returned from scanner
    idKind      :: Tree KeyToken IdInfo --- information about how id tokens got resolved
    packageDoc  :: Maybe String         --- documentation for this package
    definitions :: [DefinitionS]        --- package definitions
    errors      :: Int                  --- number of errors found so far
    messages    :: [Message]            --- list of 'Message's (used when 'IDE' is on, contains messages in reverse order
    nextPass    :: Int                  --- next pass (used in fregIDE only)
    cancelled   :: IO Bool              {-- Tell if processing is cancelled. The eclipse IDE will put a value here that
                                            checks a progress monitor. In batchmode this is of course always false.
                                            We need this because certain passes can take a long time,
                                            but usually do a 'foreach'-loop that could be terminated after
                                            a substep. See 'forsome' -}
    thisPack    :: Pack                 --- the current package
    thisPos     :: Position             --- from *package* ... *where* 
    nsPos       :: Tree NSName Position --- where NS was introduced
    stderr      :: PrintWriter          --- error messages go here, UTF-8 encoded
    toExport    :: [SName]              --- inlineable functions from this package
}

--- items that are set and used during code generation
data GenSt = !Gen {
    printer :: PrintWriter             --- generated java code goes here, UTF-8 encoded
    tunique :: Int                     --- unique numbers for taus
    runique :: Int                     --- unique numbers for rhos
    sunique :: Int                     --- unique numbers for sigmas
    xunique :: Int                     --- unique numbers for exprs
    tTree   :: Tree TauA Int           --- tau table
    rTree   :: Tree RhoA Int           --- rho table
    sTree   :: Tree SigmaA Int         --- sigma table
    xTree   :: Tree ExprA Int          --- expr table
    consts  :: Tree (Literalkind, String) Int   --- constant table
    lambdas :: Tree (Int, [QName]) [Symbol] --- lambda table
}

--- compiler state, appears like it was global, but threaded through 'StIO' monad
data Global = !Global {
    options  :: Options                  --- compiler options
    sub      :: SubSt                    --- seldom changed items
    gen      :: GenSt                    --- things used in code generation
    unique   :: Int                      --- source for uniq integers
    packages :: Tree Pack Symtab         --- map packages to symbol table
    namespaces  :: Tree NSName Pack      --- map namespaces to packages
    -- env :: [Symtab]                      --- current local environments
    genEnv  :: [Symbol]                  --- symbols of function that is being compiled
    locals :: Tree Int Symbol            --- local ids identified by name
    typEnv :: [QName]                    --- names of functions being type checked
} where
    --- true if and only if we are generating code for a top level item
    toplevel (g::Global)    = null g.genEnv
    -- make it look like all the items live in Global
    optab (g::Global)       = g.sub.optab
    tRanges (g::Global)     = g.options.tRanges
    sourcePath (g::Global)  = g.options.sourcePath
    packageDoc (g::Global)  = g.sub.packageDoc
    definitions (g::Global) = g.sub.definitions
    cache       (g::Global) = g.sub.cache
    stderr  (g::Global)     = g.sub.stderr
    printer (g::Global)     = g.gen.printer
    tunique (g::Global)     = g.gen.tunique
    runique (g::Global)     = g.gen.runique
    sunique (g::Global)     = g.gen.sunique
    xunique (g::Global)     = g.gen.xunique
    tTree (g::Global)       = g.gen.tTree
    rTree (g::Global)       = g.gen.rTree
    sTree (g::Global)       = g.gen.sTree
    xTree (g::Global)       = g.gen.xTree
    thisPack (g::Global)    = g.sub.thisPack
    resolved :: Global -> Token -> Maybe IdInfo 
    resolved g t = g.sub.idKind.lookup (KeyTk t)
    -- namespaces (g::Global)  = g.sub.namespaces
    errors (g::Global)      = g.sub.errors
    -- genEnv (g::Global)      = g.genEnv
    thisTab :: Global -> Symtab
    thisTab g = case g.packages.lookup g.thisPack of
        Just st -> st
        Nothing -> error ("no symtab for package " ++ show (g.thisPack.unpack g))

--- the symbol table
type Symtab = Tree String Symbol
{-
type XSS     = KeyString

abstract data KeyString = XS String where
    unXS (XS s) = tail s
    global c s  = XS (c ++ s)
    local s     = XS ("l" ++ s)

derive Ord KeyString
-}

{--
 * A package name can not be read without resort to the global state,
 * because it includes the prefix given on the command line.
 * However, one can compare them, i.e. @p == P "frege.Prelude"@
 -}
abstract data Pack = P String where
    new s = P s
    un (P s) = s
    unpack :: Pack -> Global -> String
    unpack (P s) g = g.options.prefix ++ s
    --- Make a namespace name from a package name by taking the trailing word characters
    --- For always-to-import Prelude packages, the namespace name is derived from 'preludePacks'
    nsName p | [n] <- [ NSX s | (p', Just s) <- preludePacks, p' == p ] = n
    nsName (P (m~#(\w+)$#)) = NSX (unJust (m.group 1))
    nsName (P s) = Prelude.error ("nsName: illegal package name " ++ s.show)
    --- convert to JName
    className p g
        | m~#^((\S+)\.)?(\w+)$# <- unpack p g
        = JName (maybe "" id (m.group 2)) (maybe "Hä?" id (m.group 3))
        | otherwise = error ("bad package name " ++ un p)
    nice p g
        -- p == pPrelude   = "Prelude"
        | p == Global.thisPack g = ""
        | otherwise = case filter ((p==) <~ snd) ((Global.namespaces g).each) of
                ((NSX s, _):_) -> s
                _              -> (nsName p).unNS
    (P a) ==  (P b) = a.==  b
    (P a) <=> (P b) = a.<=> b
    hashCode (P a) = String.hashCode a

instance Eq   Pack
instance Ord  Pack
derive   Show Pack

{--
    When a package name consists of more than just a 'CONID' 
    and the first character is an uppercase letter, then this 
    letter is replaced by its lowercase equivalent and the
    string @"frege."@ prepended to form the real package name.
    
    > magicPack "Data.List" = "frege.data.List"
    > magicPack "List"      = "List"  
    -}
magicPack (nm@´\.´)
    | fst.isUpperCase = "frege." ++ fst.toLowerCase.display ++ tail nm
    where 
        fst = String.charAt nm 0
magicPack nm = nm

--- a prominent package
pPrelude = (Pack.new • fromMaybe "frege.Prelude" • IO.getProperty) "frege.prelude"
pPreludeBase    = Pack.new "frege.prelude.PreludeBase"
pPreludeNative  = Pack.new "frege.prelude.PreludeNative"
pPreludeText    = Pack.new "frege.prelude.PreludeText"
pPreludeList    = Pack.new "frege.prelude.PreludeList"
pPreludeMonad   = Pack.new "frege.prelude.PreludeMonad"

{-- List of Prelude packages and the namespace that needs to be assigned on import time

    These are automatically recognized as Prelude-Packages.

    For each of them, a java import will be generated and
    names from them appear in Class.name form in java code.

    If the package's namespace must be present at compile time,
    the second component of the tuple must be given as 'Just' @name@
-}
preludePacks = (pPreludeBase,  Just "PreludeBase") : map fppack [
                    ("Native", Just "PreludeNative"),     -- because of various literals
                    ("List",   Just "PreludeList"),       -- because of list comprehension
                    ("Text",   Just "PreludeText"),       -- because of derive Show
                    ("Monad",  Just "PreludeMonad"),      -- because of derive Show
               ]
       where
            fppack (s,mb) = (Pack.new ("frege.prelude.Prelude" ++ s), mb)

--- The list of imports that must always be performed, constructed from 'preludePacks'
importAlways = [ ImpDcl {pos=Position.null, pack=Pack.un p, as=Just n, imports = linkNone} |
                    (p, Just n) <- preludePacks ]

{--
    This predicate tells if a certain package is a Prelude package
    (and so does not need a Prelude import)

    Treatment as Prelude package can be forced
    by prepending the *package* keyword with *protected*
-}
inPrelude :: Pack -> Global -> Bool
inPrelude p g = (p `elem` map fst preludePacks)
              || g.options.flags `band`  (1 `bshl`  ord INPRELUDE) != 0

--- namespace name
data NSName = NSX { unNS :: String }
derive Eq   NSName
derive Ord  NSName
derive Show NSName

-- copied over from Utilities, sorry
{--
 * determine 'QName' of type given in an instance definition
 -}
private instTSym (ForAll _ (RhoTau _ tau)) g = instTauSym tau g
private instTSym _ g = Nothing
--- return type symbol for constructor of tau, if any
private instTauSym tau g = case tau of
        TCon {name} -> QName.findit name g
        TApp a _    -> instTauSym a g
        _           -> Nothing
--- qualified name
data QName =
        !TName   { pack :: Pack,  base :: String }
        | !VName { pack :: Pack,  base :: String }
        | !MName { tynm :: QName, base :: String }
        | !Local { uid  :: Int,   base :: String }
    where
        getpack (TName p _) = p
        getpack (VName p _) = p
        getpack (MName (TName p _) _) = p
        getpack (MName _ _) = Prelude.error "illegal MName"
        getpack (Local{}) = Pack.new ""

        key (TName _ s)  = "T+" ++ s
        key vmName       = vmName.base

        find :: QName -> Global -> Maybe Symbol
        find (this@Local{uid})  g =  g.locals.lookup uid {- loop g.env where
            loop []     = Nothing
            loop (e:es) = case Tree.lookupS e k of
                Nothing -> loop es
                just    -> just-}
        find (this@TName p s) g = case g.packages.lookup p of
            Just env -> env.lookupS (key this)
            Nothing  -> Nothing
        find (this@VName p s) g = case g.packages.lookup p of
            Just env -> env.lookupS s
            Nothing  -> Nothing
        find (this@MName t s) g = case findit t g of
            Just sy | sy.{env?} = sy.env.lookupS s
            Just (SymA {typ}) = case instTSym typ g of
                Just (sym::Symbol) -> find (MName sym.name s) g
                Nothing  -> Nothing
            _ -> Nothing
        --- like 'QName.find', but follow aliases
        findit :: QName -> Global -> Maybe Symbol
        findit t g = case find t g of
            Just sy -> sy.follow g
            Nothing -> Nothing
        istuple s   = QName.base s ~ #^\(,+\)$#
        public our :: QName -> Global -> Bool
        our     (TName p  _) g = p.== (Global.thisPack g)
        our     (VName p  _) g = p.== (Global.thisPack g)
        our     (MName t  _) g = our t g
        our     (Local {})    g = true
        qual    (TName p  _)   = TName p
        qual    (VName p  _)   = VName p
        qual    (MName t  _)   = MName t
        qual    (Local {uid})  = Local uid
        nice    (TName p s)  g
            | inPrelude p g  = s
            | p.== (Global.thisPack g) = s
            | otherwise = p.nice g ++ "." ++ s
        nice    (VName p s)  g
            | inPrelude p g  = s
            | p.== (Global.thisPack g) = s
            | otherwise = p.nice g ++ "." ++ s
        nice    (MName t s)    g = t.nice g ++ "." ++ s
        nice    (Local {uid, base}) g = base ++ "{" ++ show uid ++ "}"
        --- 'nicer' gives a short form of a 'TName' if it can be found locally
        nicer (Local {uid, base}) g = base
        nicer (qn@TName p s) g
            | findit qn g == findit (TName g.thisPack s) g = s
        nicer  qn g = nice qn g
        --- tell if this is the name of a let or lambda bound item
        isLocal (Local{}) = true
        isLocal _         = false

derive Eq   QName
derive Ord  QName
derive Show QName

data JName = !JName {qual :: String, base :: String} where
        show (JName "" x) = x
        show (JName p  x) = p ++ "." ++ x

instance Show JName
derive   Eq   JName

{--
    symbol state (for 'Symbol.SymV' symbols)
    -}
data SymState = Unchecked | Typechecking | Recursive | Typechecked | StrictChecked
derive Eq SymState
derive Ord SymState
derive Show SymState
derive Enum SymState

{--
    The information stored in the 'Symtab' nodes.
    -}
data Symbol =
        !SymT    {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 typ::Sigma, env::Symtab, nativ::Maybe String,
                 product::Bool, enum::Bool, pur::Bool, newt::Bool}  --- data type
        | !SymL  {sid::Int, pos::Position, vis::Visibility, name::QName,
                 alias::QName}                                      --- alias name
        | !SymD  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 cid::Int   --- constructor number
                 typ::Sigma, flds::[ConField QName],
                 strsig :: Strictness }                             --- data constructor
        | !SymC  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name::QName,
                 tau::Tau, supers::[QName], insts::[(QName, QName)],
                 env::Symtab, vkind :: Int}                         --- class
        | !SymI  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 clas::QName, typ::Sigma, env::Symtab}              --- instance
        | !SymV  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 typ::Sigma, expr::Maybe Expr, nativ::Maybe String,
                 pur::Bool, anno::Bool, exported::Bool, state::SymState,
                 strsig :: Strictness, depth :: Int, rkind :: Int } --- variable or function
        | !SymA  {sid::Int, pos::Position, vis::Visibility, doc::Maybe String, name ::QName,
                 typ::Sigma, vars::[Tau]}                           --- type alias
    where
        follow (ali@SymL {alias}) g = alias.find g
        follow sym g = Just sym
        kind (SymT {name}) g = "data type"
        kind (SymD {name}) g = "constructor"
        kind (SymC {name}) g = "class"
        kind (SymI {name}) g = "instance"
        kind (SymV {name,nativ, expr}) g = if isJust nativ then "native " ++ fun else fun
            where fun | MName t b <- name, Just sym <- t.find g
                                          = sym.kind g ++ " member " ++ funval
                      | MName _ _ <- name = "member " ++ funval
                      | otherwise         = funval
                  funval | isJust nativ = "function"
                         | Just (Lam {}) <- expr = "function"
                         | otherwise = "value"
        kind (SymA {name}) g = "type alias"
        kind (SymL {alias}) g = case alias.find g of
            Just sym -> "alias for " ++ sym.kind g
            Nothing  -> "alias"
        nice (sym@SymL {alias}) g = kind sym g ++ " `" ++ alias.nice g ++ "`"
        nice sym g = kind sym g ++ " `" ++ sym.name.nice g ++ "`"
        nicer (sym@SymL {alias}) g = kind sym g ++ " `" ++ alias.nicer g ++ "`"
        nicer sym g = kind sym g ++ " `" ++ sym.name.nicer g ++ "`"
        --- Symbols are ordered *only* by the @sid@ field, which is a unique number
        sym1 <=> sym2 = (Symbol.sid sym1).<=> (Symbol.sid sym2)
        sym1 == sym2  = (Symbol.sid sym1).==  (Symbol.sid sym2)
        hashCode sym  = (Symbol.sid sym)
        our sy g = (Symbol.name sy).our g

instance Ord Symbol

data ConField s = !Field { pos:: Position, name, doc :: Maybe String, typ :: SigmaT s }

--- Strictness information for function arguments
--- This is stored in 'SymD' and 'SymV' symbols.
data Strictness = U                 --- lazy argument
                | S [Strictness]    {-- strict argument, for product types
                                        there may be additional information for the
                                        subcomponts
                                     -}
                where
                    isStrict U = false
                    isStrict _ = true
instance Eq Strictness where
    U == U = true
    S x == S y = (length x).== (length y) && and (zipWith (Strictness.==) x y)
    _ == _ = false
    hashCode U = 1
    hashCode (S x) = x.hashCode

allLazy   = repeat U
allStrict = repeat (S [])

instance Show Strictness where
    show U = "u"
    show (S []) = "s"
    show (S xs) = "s(" ++ joined "" (map show xs) ++ ")"

{--
 * [usage] @decodeS string@
 * [returns] the decoded strictness value
 * [requires] the string must have been constructed with 'Strictness.show'
 * [ensures]  @forAll Strictness.arbitrary { s | s == decodeS (show s) }@
 -}
decodeS :: String -> Strictness
decodeS s = fst (decode s) where
    decode     (s @ #^u#)  = (U, strtail s 1)
    decode     (s @ #^s#)  = (S list, rest) where (!list,!rest) = decodeList (strtail s 1)
    decode     s           = Prelude.error ("decodeS: bad string " ++ s.show)
    decodeList (s @ #^\(#) = listElems (strtail s 1)
    decodeList  s          = ([], s)
    listElems  (s @ #^\)#) = ([], strtail s 1)
    listElems   s          = (e:elems,rest) where
                                                (e,rs)       = decode s
                                                (elems,rest) = listElems rs


{--
 * type to model type variables in type checking
 -}
data MetaTvT s =
          !Flexi {uid::Int, ref :: (IORef (Maybe (TauT s))), hint::String}
        | !Rigid {uid::Int, hint::String}
        where
            --- tell if the 'MetaTv' is bound
            bound (Flexi _ r _) = doio (r.get)
            bound (Rigid _ _)   = stio Nothing
            --- tell if the 'MetaTv' is flexible
            isFlexi (Flexi _ _ _) = true
            isFlexi _             = false

instance Eq MetaTvT s where
    Flexi u1 _ _ == Flexi u2 _ _  = u1.== u2
    Rigid u1 _   == Rigid u2 _    = u1.== u2
    _            == _             = false
    hashCode x = x.uid


instance Ord MetaTvT s where
    Flexi _  _  _ <=> Rigid _  _      = Lt
    Rigid _  _    <=> Flexi _  _  _   = Gt
    Flexi u1 _ _  <=> Flexi u2 _  _   = u1.<=> u2
    Rigid u1 _    <=> Rigid u2 _      = u1.<=> u2

type MetaTv = MetaTvT QName

{--
 * The type for modelling tau-types.
 -}
data TauT s =
      !TApp (TauT s) (TauT s)
    -- !TFun (TauT s) (TauT s)
    -- TAli pos::Position name::s (SigmaT s)
    | !TCon {pos::Position, name::s}
    | !TVar {pos::Position, var::String}
    | !Meta (MetaTvT s)
    where
        tfun a b = TApp (TApp (TCon Position.null (TName pPreludeBase "->")) a) b
        getFun (TApp (TApp TCon{name = TName p "->"} a) b) | p == pPreludeBase = Just (a,b)
        getFun _ = Nothing
        isFun    = maybe false (const true) • getFun 
        {--
         * Convert a flat type application to a 'TApp'
         * obeying the law
         > flat (mkapp con ts) == con:ts
         -}
        mkapp a xs = fold TApp a xs
        {-- a nonempty list where the head element is the type constructor and the tail are the args -}
        flat (TApp a b) = flatapp a [b] where
            flatapp (TApp a b) ts = flatapp a (b:ts)
            flatapp t ts          = t:ts
        -- flat (TFun a b) = [TCon 0 (TName pPrelude "->"), a, b]
        flat t = [t]

-- flat form of types, used in "GenMeta"
data TauA = !TauA {kind::Int, tcon::Maybe QName, suba::Int, subb::Int, tvar::String}
data RhoA = !RhoA {rhofun::Bool, cont::[ContextA], sigma::Int, rhotau::Int}
data ContextA = !CtxA {clas::QName, tau::Int}
data SigmaA = !SigmaA {bound::[String], rho::Int}
data ExprA = !ExprA {xkind::Int, name::Maybe QName, lkind::Int, varval::Maybe String,
                    alts :: [Int], subx1 :: Int, subx2 :: Int, subx3 :: Int}
derive Eq  TauA
derive Ord TauA
derive Eq  ContextA
derive Ord ContextA
derive Eq  RhoA
derive Ord RhoA
derive Eq  SigmaA
derive Ord SigmaA
derive Eq  ExprA
derive Ord ExprA



nApp a b = App a b Nothing

infixl 16 `App` `nApp`  `TApp`
infixr 16 `TFun`

--- tau types as created by parser
type TauS = TauT SName
--- tau types use in TC
type Tau = TauT QName

{--
 * The type for modelling sigma types
 -}
data SigmaT s = !ForAll { bound :: [String], rho :: (RhoT s) }

--* sigmas as returned from parsing
type SigmaS = SigmaT SName
--* sigmas as used in typecheck
type Sigma =  SigmaT QName

{--
 * The type for modelling class assertions
 -}
data ContextT s = Ctx {pos :: Position, cname :: s, tau :: TauT s, checked :: Bool }
type Context    = ContextT QName
type ContextS   = ContextT SName

{--
 * The type for modelling rho types
 -}
data RhoT s =
      !RhoFun {context::[ContextT s], sigma::SigmaT s, rho::RhoT s}
    | !RhoTau {context::[ContextT s], tau::TauT s}

--* rho as returned from parsing
type RhoS = RhoT SName
--* rho as used in typechecker
type Rho  = RhoT QName

--- cross module visibility of items
data Visibility =
    Private         --- item is not available in other packages, except constructors for inlined code
    | Protected     --- item is available but will be imported only on demand
    | Public        --- item is available and will be imported by default
    | Abstract      --- makes type public but all constructors private

instance Show Visibility where
    show Private   = "private"
    show Public    = "public"
    show Protected = "protected"
    show Abstract  = "abstract"

derive Eq   Visibility
derive Ord  Visibility

--- an item together with a 'Position'
type Pos s = (s, Position)
--- a string with a position
type PString = Pos String
--- an unresolved, maybe qualified identifier
data SName = ! Simple { id :: Token } --- syntactically forced to be VARID, CONID or LOP1..NOP16
           | ! With1  { ty :: Token, id :: Token }
           | ! With2  { ns, ty :: Token, id :: Token }

instance Show SName where
    show (Simple t)           = t.value
    show (With1 {ty, id})     = ty.value ++ "." ++ id.value
    show (With2 {ns, ty, id}) = ns.value ++ "." ++ ty.value ++ "." ++ id.value

derive Eq SName
instance Ord SName where
    Simple t1    <=> Simple t2    = t1.value.<=> t2.value
    (s1@With1{}) <=> (s2@With1{}) = (s1.ty.value, s1.id.value).<=> (s2.ty.value, s2.id.value)
    (s1@With2{}) <=> (s2@With2{}) = (s1.ns.value, s1.ty.value, s1.id.value).<=>
                                        (s2.ns.value, s2.ty.value, s2.id.value)
    s1 <=> s2 = (constructor s1).<=> (constructor s2)

prelToken = Token CONID "Prelude" 1 1 0
baseToken = Token CONID "PreludeBase" 1 1 0
listToken = Token CONID "PreludeList" 1 1 0
monadToken = Token CONID "PreludeMonad" 1 1 0
listSourceToList = With2 listToken listToken.{value="ListSource"} listToken.{tokid=VARID, value="toList"}
emptyEmpty = With2 listToken listToken.{value="Empty"} listToken.{tokid=VARID, value="empty"}
underlineToken = Token VARID "_" 1 1 0
protoSimple = Simple underlineToken
wellKnown :: Token -> String -> SName
wellKnown t s = With1 baseToken t.{tokid=VARID, value=s}
baseFlip t = wellKnown t "flip"
qBy :: Token -> SName -> SName
qBy t (Simple con) {- con.tokid == CONID -} = With1 con t
qBy t (With1 ty id){- id.tokid  == CONID -} = With2 ty id t
qBy t  name = error ("Can't qualify " ++ t.value ++ " by " ++ show name)
withNS :: String -> SName -> SName
withNS s (Simple t) = With1 t.{tokid=CONID, value=s} t
withNS s (With1 c t) = With2 c.{tokid=CONID, value=s} c t
withNS s name = error ("Can't set namespace " ++ s ++ " for " ++ show name)

{--
 * Java keywords (along with substitutions)
 * as specified in the Java Language Specification, Version 3.0, page 21
 * and, in addition, "true", "false", and "null"
 *
 * It is, for instance, possible to name a frege item /int/, though
 * in the generated java code, this will appear as /_int/.
 *
 -}
javakeywords = Tree.insertlist Tree.Nil [(kw, "_"++kw) | kw <- [
    "abstract",     "continue",     "for",          "new",          "switch",
    "assert",       "default",      "if",           "package",      "synchronized",
    "boolean",      "do",           "goto",         "private",      "this",
    "break",        "double",       "implements",   "protected",    "then",
    "byte",         "else",         "import",       "public",       "throws",
    "case",         "enum",         "instanceof",   "return",       "transient",
    "catch",        "extends",      "int",          "short",        "try",
    "char",         "final",        "interface",    "static",       "void",
    "class",        "finally",      "long",         "strictfp",     "volatile",
    "const",        "float",        "native",       "super",        "while",
    -- also the literals, as variables cannot be named like so
    "true",         "false",        "null",
    -- likewise assert and main, in order to avoid confusion
    "assert",       "main",
    -- forgot throw
    "throw"
    ]]

{--
 * definitions
 -}
data DefinitionT =
      ImpDcl    {pos::Position, pack::String, as::Maybe String,
                    imports::ImportList}
    | FixDcl    {pos::Position, opid::TokenID, ops::[String]}
    | DocDcl    {pos::Position, text::String}
    | TypDcl    {pos::Position, vis::Visibility, name::String,
                    vars::[TauS], rho::RhoS, doc::Maybe String}
    | ClaDcl    {pos::Position, vis::Visibility, name::String,
                    clvar::TauS, supers::[SName],
                    defs::[DefinitionT], doc::Maybe String}
    | InsDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    defs::[DefinitionT], doc::Maybe String}
    | DrvDcl    {pos::Position, vis::Visibility,
                    clas::SName, typ::SigmaS,
                    doc::Maybe String}
    | AnnDcl    {pos::Position, vis::Visibility, name::String, typ::SigmaS, doc::Maybe String}
    | NatDcl    {pos::Position, vis::Visibility, name::String, typ::SigmaS,
                    meth::String, isPure::Bool, doc::Maybe String}
    | FunDcl    {poss::[Position]            --- because of multiple clauses
                    vis::Visibility, name::String,
                    pats::[PatternS], expr::ExprS,
                    doc::Maybe String}
    | DatDcl    {pos::Position, vis::Visibility, name::String,
                    vars::[TauS], ctrs::[DCon], defs::[DefinitionT],
                    doc::Maybe String}
    | JavDcl    {pos::Position, vis::Visibility, name::String, isPure::Bool,
                    jclas::String, vars::[TauS], defs::[DefinitionT],
                    doc::Maybe String}

type DefinitionS = DefinitionT
type Definition  = DefinitionT

{--
    structure of an import list
--}
data ImportList = Imports {
        publik, except :: Bool,     -- kind of import list
        items :: [ImportItem]
    }
{--
    a single import item
--}
data ImportItem = Item {
        publik :: Bool,             -- re-export this one
        name :: SName,              -- to be resolved in the imported package
        members :: Maybe [ImportItem],    -- members
        alias :: String             -- guaranteed to be unqualified through syntax
    } where
        export :: ImportItem -> ImportItem
        export it = it.{publik = true, members <- fmap (map export)}

--- Prototype for an 'Item'
protoItem = Item { publik = false, name = protoSimple, members = Nothing, alias = "" }
-- 'ImportList' used when none is specified
linkAll  = Imports { publik = false, except = true,  items = [] }
-- 'ImportList' for ()
linkNone = Imports { publik = false, except = false, items = [] }

{--
 * alternatives (constructors) in a data declaration
 -}
data DCon = DCon {pos::Position, vis::Visibility, name::String, strict::Bool,
                        flds::[ConField SName], doc::Maybe String}
type DConS = DCon

{--
 * Literals
 -}
data Literalkind =
      LBool
    | LChar
    | LString
    | LInt
    | LBig
    | LLong
    | LFloat
    | LDouble
    | LRegex

derive Enum Literalkind
derive Show Literalkind

{--
    expressions
 -}
data ExprT q =
      Vbl      { pos::Position, name::q, typ::Maybe (SigmaT q) }
    | Con      { pos::Position, name::q, typ::Maybe (SigmaT q) }
    | ConFS    { pos::Position, name::q, fields::[(String, ExprT q)],  typ::Maybe (SigmaT q) }
    | !App     { fun::ExprT q, arg::ExprT q,  typ::Maybe (SigmaT q)}
    | !Lit     { pos::Position, kind::Literalkind, value::String,  typ::Maybe (SigmaT q)}
    | !Let     { env::[QName], defs::[Definition], ex::ExprT q, typ::Maybe (SigmaT q)}
    | !Lam     { pat:: PatternT q,   ex::ExprT q, typ::Maybe (SigmaT q)}
    | !Ifte    { cnd::ExprT q, thn::ExprT q, els::ExprT q, typ::Maybe (SigmaT q)}
    | !Mem     { ex::ExprT q, member::Token, typ::Maybe (SigmaT q)}
    | !Case    { ckind::CKind, ex::ExprT q, alts::[CAltT q], typ::Maybe (SigmaT q)}
    | !Ann     { ex::ExprT q,  typ::Maybe (SigmaT q)}


type Expr  = ExprT QName
type ExprS = ExprT SName
{--
    case alternative 
 -}
data CAltT q = !CAlt {pat::PatternT q, ex::ExprT q}
type CAltS = CAltT SName
type CAlt  = CAltT QName

{--
 * case kind
 -}
data CKind =
      CNormal       --- normal case
    | CWhen         --- case that falls through
    | CNoWarn       --- compiler generated, do not emit warnings

derive Eq CKind
derive Enum CKind

{--
 * patterns
 -}
data PatternT q =
      !PVar    { pos::Position, uid::Int, var::String }                     -- x
    | PCon     { pos::Position, qname::q, pats :: [PatternT q] }            -- Con
    | PConFS   { pos::Position, qname::q, fields::[(String, PatternT q)] }  -- Con { field, ... }
    | !PAt     { pos::Position, uid::Int, var::String, pat::PatternT q}     -- a@pat
    | !PStrict { pat :: PatternT q}                                         -- strict pattern !pat
    | !PLit    { pos::Position, kind::Literalkind, value::String}           -- 42 #foo#
    | !PAnn    { pat::PatternT q, typ::SigmaT q}                            -- pat::forall a.Eq a => a -> a
    | !PMat    { pos::Position, uid::Int, var::String, value::String}       -- m~#foo#

type PatternS = PatternT SName
type Pattern  = PatternT QName

{--
 * formatting for 'Char'
 -}
{--
 * encode certain special characters so that the result is a
 * valid java identifier
 -}
pure native formatchar java.lang.String.format :: String -> Int -> String

repljavakws s = case Tree.lookupS javakeywords s of
    Just k  -> k
    Nothing -> s
;

--- replacement for know operators
knownops = Tree.insertlist Tree.Nil [
       ("()", "Unit"),
       ("[]", "Nil"),
       (":",  "Cons"),
       ("$",  "_dollar"),
    ]

--- replacement for certain graphic characters ∀
graphReplacements = Tree.insertlist Tree.Nil [
    ('°', "_deg"),  ('^', "_caret"),    ('!', "_excl"), ('²', "_two"),  ('³', "_three"),
    ('§', "_par"),  ('%', "_pct"),      ('&', "_amp"),  ('/', "_div"),  ('=', "_eq"),
    ('?', "_qm"),   ('\\', "_back"),     ('*', "_star"), ('+', "_plus"), ('~', "_tilde"),
    ('\'', "_tick"),('#', "_num"),      ('-', "_minus"),('.', "_dot"),  (':', "_colon"),   -- '#
    (',', "c"),(';', "_semi"),     ('@', "_at"),   ('|', "_bar"),  ('<', "_lt"),
    ('>', "_gt"),   ('•', "_bullet"),   ('«', "_lang"), ('»', "_rang"), ('¦', "_bar2"),
    ('¿', "_iqm"),  ('€', "_euro"),     ('£', "_pound"),('¥', "_yen"),  ('¢', "_cent"),
    ('¬', "_not"),  ('±', "_plusminus"),('¡', "_iexcl"),('¤', "_money"),('©', "_copy"),
    ('®', "_trade"),('¹', "_one"),      ('$', "_dollar"),
    ('[', "_lbrack"), (']', "_rbrack"), ('(', "l_"), (')', "_r")]

--- look in 'graphReplacements' for character translation, if not there, use ordinal number
replaceGraphic c = case graphReplacements.lookup c of
    Just s ->  s
    Nothing -> formatchar "_%d" (ord c)


{--
 * encode certain special characters so that the result is a
 * valid java identifier
 * 
 -}
mangled :: String -> String
mangled (s@#^\(,+\)$#) = "Tuple" ++ show (length s - 2 + 1)
mangled "()" = "Unit"
mangled "[]" = "List"
mangled "->" = "Function"
mangled s | Just o <- Tree.lookupS knownops s = o                    -- other know operator
mangled s = loop s  (s =~ nokchars) where                           -- s contains a strange char
        loop :: String -> Maybe Matcher -> String
        loop s'  Nothing  = repljavakws s'                          -- string is clean
        loop _  (Just m) =                                          -- string contains special characters
            let
                x  = unJust (m.group 0)                             -- the matched string
                c  = x.charAt 0                                     -- the offending character
                xc = replaceGraphic c                               -- ... translated
                r  = m.replaceFirst xc.quoteReplacement             -- replace it
            in loop r (r =~ nokchars)
--- pattern that matches any string that contains special characters
nokchars = #[^\p{L}\d_$]#

{- --------------------- monad stuff --------------- 
{-- a monad that manages state and can perform IO -}
data StIO s a = StIO { run :: (s -> IO (a, s)) } where
    get      = StIO (\!s -> IO.return (s,s))
    put !s   = StIO (\_ -> IO.return ((),s))
    change f = StIO (\!s -> IO.return ((), f s))
    lift !c  = StIO (\!s -> (IO.>>=) c (\!x -> IO.return (x,s)))
    performUnsafe !(StIO r) !s = IO.performUnsafe (r s)
    -- return2 _ a = StIO.return a

instance Monad (StIO s) where
    return !a = StIO (\!s -> IO.return (a,s))
    !ma >> !mb = ma >>= const mb
    -- (>>=) :: StIO s a -> (a -> StIO s b) -> StIO s b
    !(StIO !x) >>= !f = StIO ( \!s -> do
                (!v, !s') <- x s
                StIO.run (f v) s'
            )
    -}

{-- Convenience function for injecting an @a@ into ('StG').
    This is just 'StG.return' typed as @a -> State Global a@ -}
stio :: a -> StG a
stio !a = StG.return a

{-- Convenience function for doing IO in a ('StG') action.
    
    The correct way would be of course to use a 'State' monad transformer
    with an inner 'IO' monad, and indeed this was how it was implemented first.
    
    This version is there for better performance.
    -}

doio :: IO a -> StG a
doio act = return (IO.performUnsafe act) 

{--
    Convenience function for getting the state.
    This replaces the ugly:
    > (s::Global) <- State.get
-}
getST :: StG Global
getST = State.get

{--
    Convenience function for putting the state back.
    This is just 'State.put' retyped.
    -}
putST :: Global -> StG ()
putST s = State.put s

{--
    Convenience function for changing the state.
    This is just 'State.change' retyped.
    -}
changeST :: (Global -> Global) -> StG ()
changeST f = State.change f

--- absurd true message aborts the compiler with "message"
absurd :: Bool -> String -> StG ()
absurd c msg = if c then error msg else stio ()

{-
--- do an action with an extended environment
with :: Symtab -> StG a -> StG a
with e action = do
    -- g <- getST
    changeST Global.{env <- (e:)}   -- extend env with e
    -- envDump
    r <- action                     -- perform action
    --e <- getTop
    changeST Global.{env <- tail}   -- drop e' again
    -- envDump
    stio r

--- like 'with', but work with void action and return changed environment in the 'StIO' monad
nested :: Symtab -> StG () -> StG Symtab
nested e action = do
        changeST Global.{env <- (e:)}   -- extend env with e
        void <- action                  -- perform action
        e  <- getTop                    -- get top env
        changeST Global.{env <- tail}   -- drop it again
        stio e                          -- and return possible changed e

--- do an action while saving the top env
without :: StG a -> StG a
without action = do
    top <- getTop
    changeST Global.{env <- tail}
    -- envDump
    r <- action
    changeST Global.{env <- (top:)}
    -- envDump
    stio r

--- dump the environment if TRACE3 is on
envDump = do
    g <- getST
    let
        cond = (1 `bshl` ord TRACEX) `band` g.options.flags
        levels = reverse (1..g.env.length)
        frame (n, st) = do
            let nmid = [ (nm, Symbol.pos sym, Symbol.sid sym) | (nm, sym) <- each st ]
            g.stderr.println (show n ++ " " ++ show nmid)
            IO.return ()
    when (cond != 0) do
        doio (sequence_ (map frame (zip levels g.env)))
        doio (g.stderr.println "end-of-env-stack")
        stio ()


--- @within expr action@
--- do an action with the expression that is surrounded by 0 or more lambdas
--- > within (\x\y -> z) f  ==> with x (with y (f z))
-- within :: Expr -> (Expr -> StG a) -> StG a
-- within (Lam {env,ex}) f = with env (within ex f)
-- within x f = f x

---
--- get the top level
getTop = do
    g <- getST
    absurd (null g.env) "FATAL: no top level environment, i.e. getTop outside with"
    stio (head g.env)

--- apply a change to the top level env
changeTop f = do
    g <- getST
    absurd (null g.env) "FATAL: no top level environment, i.e. changeTop outside with"
    let top  = head g.env
        rest = tail g.env
    changeST Global.{env = f top:rest}
-}

{-- do a 'StG' action for each element of a list -}
foreach :: [a] -> (a -> StG b) -> StG ()
foreach list f = foldr (>>) (stio ()) (map f list)

{-- do a 'StG' action for each element of a list while not cancelled -}
forsome [] f = stio ()
forsome (a:as) f = do
    g <- getST
    b <- doio g.sub.cancelled
    if b then stio () else do
        f a
        forsome as f

{-- map a 'StG' action over each element of a list and return the resulting list in 'StG' -}
mapSt :: (a -> StG b) -> [a] -> StG [b]
mapSt f [] = stio []
mapSt f (a:as) = do
    a <- f a
    as <- mapSt f as
    stio (a:as)
{-- fold with 'StG' action -}
foldSt :: (a -> b -> StG a) -> a -> [b] -> StG a
foldSt f a [] = stio a
foldSt f a (b:bs) = do
        a <- f a b
        foldSt f a bs

-- ------------  position functions ------------------
--- Position of the *package* keyword. If there is none falls back to 'Position.null'
packageStart :: Global -> Position
packageStart g = case filter ((PACKAGE ==) • Token.tokid) g.sub.toks.toList of
    t:_ -> Pos t t
    _   -> Position.null
--- Position of the last character in the file. If there is none falls back to 'Position.null'
packageEnd :: Global -> Position
packageEnd g = case dropWhile ((Int.maxBound.==) • Token.offset) (reverse g.sub.toks.toList) of
    (tok:_) -> tok.{value=" ", offset = tok.offset + tok.length - 1, col = tok.col + tok.length - 1}.position
    _       -> Position.null

--- get the tokens that make up this item
tokens :: Position -> Global -> [Token]
tokens pos
    | pos == Position.null = const [pos.first]
    | otherwise = filter wanted
                 • takeWhile ((< e) • Token.offset)
                 • dropWhile ((< s) • Token.offset)
                 • Array.toList
                 • SubSt.toks
                 • Global.sub
         where
            -- wanted :: Token -> Bool
            wanted t
                | id.== COMMENT = false
                | id.== DOCUMENTATION = false
                | otherwise = true
                where id = Token.tokid t
            e = pos.end
            s = pos.start





--- avoid writing 'State' 'Global' all the time
type StG = State Global

--- things that need the environment to print nicely
class Nice a where
    nice :: a -> Global -> String
    nicer :: a -> Global -> String
    nicer a g = nice a g        -- default

instance Nice String where
    nice s _ = s

instance Nice QName
instance Nice SName where
    nice s _ = s.show
instance Nice Symbol