{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
    Java code generation for the frege compiler

    This verion of code generation tries to minimize boxing/wrapping of values.
    
    This is achieved through the following principles:
    - every frege type is mapped to a java
      type that extends @Lambda@ (for function types) or @Algebraic@
      for algebraic types. @Lambda@ and @Algebraic@ are abstract classes that
      both implement the @Lazy@ interface. Hence every non native value is
      a Lazy value.
    - Lazy arguments of functions or data constructors have type @Lazy@ if
      the type checker tells us that only non native values can be passed.
      Otherwise, the type is just @Object@. In effect, this means we can pass
      *anything* to the function - a primitive value (that gets autoboxed by java),
      a frege value or a closure.
    - The same holds for lazy fields of data constructors, so that native values can  
      remain unboxed all the time.
    - But a not yet evaluated value of function application or a lazy field must never
      be passed when a strict value is expected.  
 -}


package frege.compiler.GenJava7 where


import frege.Prelude hiding(apply)
import frege.List (Tree, values, keys, each, insert, lookup, insertkv, updatekv)
import Data.List as DL(sortBy, partitioned)

import frege.compiler.Data          as D
import frege.compiler.Utilities     as U() 
import frege.lib.PP()  -- (`<>`, `<+>`, `</>`, `<+/>`, `<~/>`, text, bracket)
import frege.compiler.Transform     as T(patternStrictness)
import frege.compiler.TCUtil        as TC(sameTau)
import frege.compiler.Typecheck     as TY(mainSigma, tc, tauString)
import frege.compiler.Javatypes     as JT(subTypeOf)

import frege.compiler.gen.Match     as GM
import frege.compiler.gen.Util      as GU except(group, break)
import frege.compiler.gen.Const     as GC
import frege.compiler.gen.Bindings  as GB

infixr 6 `<>`

--- Post condition of the code generation pass, always true
post = stio true


--- the main class name for this package
mainClass :: Global -> JName
mainClass g = if jn.base  `elem` javaLangNames then jn else jn.{qual=""}
    where jn = g.thisPack.className g



 
-- --- prefix for wrapper methods is ﬂ
-- flLigatur = "ﬂ"
-- --- prefix for method handles is ﬁ
-- fiLigatur = "ﬁ"

--- latin ƒ is prefix for class methods and postfix for Lambdas 
latinF    = "ƒ"
 
{--
     create a lazy method for the given symbol
 -}
lazyMethod :: Symbol -> StG JDecl
lazyMethod sym | sym.{flds?} || sym.{rkind?} = do
        g <- getST
        let jname  = JX.static (workerMethod g sym)
            arity = if sym.{depth?} then sym.depth else length sym.flds
            isnative = sym.{nativ?} && isJust sym.nativ
         -- U.logmsg TRACEG sym.pos (text ("lazyMethod: " ++ nicer sym g ++ " :: " ++ nicer sym.typ g))
        sym <- if isnative then objectifySigma sym.typ >>= return . sym.{typ=}
                 else return sym
         -- U.logmsg TRACEG sym.pos (text ("lazyMethod: " ++ nicer sym g ++ " :: " ++ nicer sym.typ g))
        let (rty, sigmas) = U.returnTypeN arity sym.typ.rho
            (rtau, _)     = U.returnType sym.typ.rho
            jrty            = rhoJT g rty
        let argdefs = evalArgDef attrFinal sigmas (take arity argNames)
            wcode   = if wrapped sym
                    then wrapCode g JReturn rtau sym (map (instArg g) argdefs)
                    else if isnative
                         then let bind = nativeCall g sym (map (instArg g) argdefs)
                              in [JReturn bind.jex]
                         else []
 
         -- special support for native functions, call directly into native code
        let haswrapper  = arity > 0 && wrapped sym || (not (null sym.typ.bound))
         
         -- be sure to pass ctx1, ctx2, ....
        let ctxs = map JAtom (take (length sym.typ.rho.context) ctxNames)
 
        let args        = argdefs
            rkind       = if sym.{rkind?} then sym.rkind else RState.singleton RValue
            -- rm       = wmode  rkind
            jtype       = autoboxed (returnType rkind jrty)                 
            
            abinds
                 | S ss <- sym.strsig = zipWith (adaptArg g) argdefs (ss ++ allLazy)
                 | otherwise          = zipWith (adaptArg g) argdefs allLazy
 
            body = JBlock $
                        -- [ sComment (show b) | b <- abinds ] ++ 
                        [(JReturn  • JX.invoke (ctxs ++ map Binding.jex abinds)) jname]
            rBody = if haswrapper then body -- JBlock [JReturn callWrapper]
                     else JBlock wcode 
            -- bx jex = (toMode g rm (Bind {mode = rm,
            --                              ftype = ForAll [] rty,
            --                              jtype = jtype, jex})).jex
            result = JMethod { attr = attrs [JFinal, JPublic],
                             gargs = targs sym.typ,
                             name = "eval",
                             jtype, args = reverse args,
                             body = if isnative then rBody else body }
        stio result
         
lazyMethod sym = error "lazyMeth: no SymV"
  
{-- 
     Replace type variables with kind @KGen@
     that are the type of some argument (and hence stand for unknown native values)
     with the type for @java.lang.Object@, see 'PreludeBase.AnonymousObject'
     -} 
objectifySigma :: Sigma -> StG Sigma
objectifySigma sig = do
         -- g <- getST
         -- U.logmsg TRACEG (getpos sig) (text ("objectifySigma: " ++ nicer sig g))
         -- U.logmsg TRACEG (getpos sig) (text ("objectifySigma: vars = " ++ show (keys tree)))
         nrho <- U.substRho tree sig.rho
         let nsig = ForAll nbound nrho
             nbound = filter (isNothing . lookup tree . fst) sig.bound
         -- U.logmsg TRACEG (getpos sig) (text ("objectifySigma: " ++ nicer nsig g))
         return nsig
     where
         tree = findAnonRho Nil [] sig.rho
 
--- Find arguments whose type is a simple type variable of type KGen
findAnonSigma acc except (ForAll bound rho) = findAnonRho acc (except ++ map fst bound) rho
findAnonRho acc except RhoTau{tau=TVar{kind=KGen,var=n}} 
     | n `elem` except = acc
     | otherwise       = insert acc n  (TY.tc "AnonymousObject")
findAnonRho acc except RhoFun{sigma, rho}
     = findAnonRho (findAnonSigma acc except sigma) except rho 
findAnonRho acc _ _ = acc

--- tells how many lazy functions go into one Lambda class.
--- *Important* This must be a power of 2!
fpC = 256

{--
     Prepare top level function for lazy usage.
     
     For every top level function, including native ones, there may be a
     Lambda object that one can pass to other functions if the need arises.
     
     The eval method of that object must invoke the actual function code.
     
     Since all eval() method signatures of functions with the same arity and the same
     list of constraints is the same, we can combine several functions in one
     class and one eval method that switches on a function id to do the right thing. 
     
     This helps to contain the class explosion problem - every function passed to
     a higher order function generates a class without that optimization.
     
     Given a toplevel symbol, we compute the arity
     and the the names of the constraints, and enter the symbol in the
     @Global.gen.lambdas tree. By the way, we assign every function a small
     index unique in its category.
     Finally, we generate a
     > final static public LambdaN funcf = new LambdaN(i);
     for unconstrained functions and
     > final static public LambdaN funcf(Constraint1 ctx1, Constraint2 ctx2) {
     >   return new Lambda2CC(i, ctx1, ctx2);
     > }
     for constrained ones. 
     -}
lazyDecl sym jname
     | SymV {name, depth, typ} <- sym, not name.isLocal = prep name depth         typ
     | SymD {name, typ} <- sym                          = prep name (U.arity sym) typ
     | otherwise = do
         g <- getST
         U.fatal sym.pos (text("prepareLazy: " ++ nicer sym g)) 
     where 
       prep :: QName -> Int -> Sigma -> StG JDecl
       prep name depth typ = do
         g <- getST
         let constr = map Context.cname typ.rho.context
             funXtyp  = jtFunc depth
             key    = (depth, constr)
             lamid  n = lambdaName depth constr n 
             member n = JMember {
                         attr = attrTop, 
                         jtype = funXtyp, 
                         name  = JName.base jname, 
                         init  = Just (newfl n)}
             classTyp n = Ref {jname = U.memberOf (mainClass g) (lamid n), typeargs = []}
             args     = map JAtom (take (length constr) argNames)                         
             newfl n  = JNew (classTyp n) (JAtom (show (n `rem` fpC)):args) 
             method n = JMethod {
                         attr = attrTop, gargs = [],
                         jtype = funXtyp,
                         name = JName.base jname,
                         args = zipWith (makeConstraintArg g) typ.rho.context argNames,
                         body = JBlock [JReturn (newfl n)]}
             result = if null constr then member else method
         case lookup g.gen.lambdas key of
             Just list -> do
                 changeST Global.{gen <- GenSt.{lambdas <- updatekv key (sym:list)}}
                 return (result (length list))
             Nothing -> do
                 changeST Global.{gen <- GenSt.{lambdas <- insertkv key [sym]}}
                 return (result 0)                         

lazyDeclarations :: [Symbol] -> StG [JDecl]
lazyDeclarations syms = do
    g <- getST
    sequence [lazyDecl sym (extFname g sym) | sym::Symbol <- syms,
            -- only functions and constructors with arity > 0 
            sym.{depth?} && sym.depth > 0 
                || sym.{flds?} && not (null sym.flds)]         
 
lambdaName n constr i = "Lambda" ++ show n ++ cid ++ packed (replicate (length constr) 'C')
                         ++ hash
     where
         cid                = U.allAsciiBinders !! (i `quot` fpC)
         hash | null constr = ""
              | otherwise   = show conid
              where conid   = fold (\a \b -> a + a + unsigned (hashCode (QName.show b))) 0L constr
                    unsigned i = fromInt i `band` 0xffffffffL                          
 
 
--- emit all lazy definitions
emitLazy :: ((Int, [QName]), [Symbol]) -> StG [JDecl]
emitLazy ((n, constr), syms) = loop [] n constr (reverse syms) 0 where
     loop dcls n constr syms base
         | length syms <= fpC = do
             dcl <- emitLazyN n constr syms base
             return (dcl:dcls)
         | otherwise = do
             dcl <- emitLazyN n constr (take fpC syms) base
             loop (dcl:dcls) n constr (drop fpC syms) (base+fpC) 

--- emit a block of lazy definitions
emitLazyN n constr syms base = do
     g <- getST
     let argdefs      = evalArgDef attrFinal (replicate n TY.sigInt) (take n argNames)
     let cname        = lambdaName n constr base
         cltype       = Nativ cname []
         p0           = Position.null
         contexts     = [ Ctx p0 q TVar{pos=p0, var="a", kind = KVar} true | q <- constr ]
         indexargname = head GenJava7.argNames
         argNames     = tail GenJava7.argNames
         indexdef     = JMember { attr = attrFinal, 
                                 jtype = strict jtInt,
                                 name  = "index",
                                 init = Nothing
                             }
         constraints  = map  (uncurry (makeConstraintDef g)) (zip contexts ctxNames)
         indexarg     = (attrFinal, TY.sigInt, strict jtInt, indexargname) 
         constrargs   = map  (uncurry (makeConstraintArg g)) (zip contexts argNames)
         initindex    = JAssign (JAtom indexdef.name) (JAtom indexargname)
         initctx      = take (length constraints)
                             (zipWith JAssign (map JAtom ctxNames) (map JAtom argNames))
         init         = JConstr { attr = attrs [JPublic], 
                                  jtype = cltype,
                                  args  = indexarg:constrargs, 
                                  body  = JBlock (initindex:initctx) }
         numbered   = zip syms (0 .. length syms)                                 
     
     stmts <- mapSt caseFor numbered
     
     let eval         = JMethod { attr = attrs [JFinal, JPublic], gargs = [],
                                  jtype = Something,
                                  name  = "eval",
                                  args  = reverse argdefs,
                                  body  = JBlock [switch, bad] }
         -- jname  sym = JX.static (workerMethod g sym)
         switch = JCond "switch" (JAtom indexdef.name) stmts 
         bad    = JThrow (JNew (Nativ "java.lang.Error" []) [JAtom (show "bad function number " ++ " + index")])                            
     
     return JClass{
             attr = attrs [JFinal, JStatic, JPrivate],
             jtype = cltype,
             extend = Just (jtFunc n),
             implement = [],
             defs = indexdef:constraints ++ [init,eval]
         }
 
caseFor (sym, n) = do 
     meth <- lazyMethod sym
     return JCase{jex = JAtom (show n), stmt = replTVarStmt meth.body}
            
{--
     Construct a java name for a variable/method that
     holds or returns the lambda class for a given symbol.
     
     The names for top level functions live in the _Consts_ subclass and are either
     static members (for function without constraints) or
     static methods that take the constraints for instantiation.
     
     The method/member name is the last part of the java name with an appended 
     latin "ƒ".
     
     For members of instances and data types
     the java name is the same as the original one with an appended latin "ƒ".
     
     This way the java name generated depends only on the qualified name
     and remains constant.
 -}
extFname :: Global -> Symbol -> JName
extFname g sym
     | VName p base <- qname,
       qname.our g               = mg (worker.base ++ latinF)
     | VName _ base <- qname     = mx qname (worker.base ++ latinF)
     | MName tname base <- qname = worker.{base <- (++ latinF)}
     where qname = Symbol.name sym
           worker = workerMethod g sym
           -- hash  = hashCode qname.show
           -- ustr  = show (fromInt hash `band` 0xffffffffL)
           mg = U.memberOf (JName "" (constClass g))
           mx qn = U.memberOf ((U.javaName g qn).{base = constClass g})
extFname g sym = error ("extFname: bad symbol " ++ nicer sym g)
 
-- -- pure native hashCode :: String -> Int
 
{--
     Require that there be an instance of a Lambda suitable to call
     the symbol lazily at runtime and return a 'Binding' for that handle.
 -}
reqLam :: Symbol -> StG Binding
reqLam sym = do
         g <- getST
         let jname = extFname g sym
         return (newBind g sym.typ (JX.static jname))
 
{--
     Generate the anonymous Lambdas for all top level function symbols
     
     (The anonymous lambdas for members are generated in the block where
     the symbol itself is defined.)
 --}
genAnonLams = do
         g <- getST
         let {- collectedenvs = g.thisTab : [ Symbol.env sy | sy <- values g.thisTab, 
                                             Symbol.{env?} sy,
                                             -- do not search type classes
                                             not (Symbol.{supers?} sy) ] -}
             collectedvars = [ v | v <- values g.thisTab, 
                                        -- only functions
                                        Symbol.{depth?} v && Symbol.depth v > 0,
                                        VName{} <- Just (Symbol.name v)
                                             ]
     
         let jnames = map (extFname g) collectedvars
         mapSt (uncurry lazyDecl) (zip collectedvars jnames)
         
 
 
pass :: StG (String, Int)
pass = do
    changeST Global.{unique <- (*100000) . succ . (`quot` 100000)}
    g <- getST
    U.print "final public class "
    U.print (mainClass g).base
    U.println " {"

    let vals = values g.thisTab
        cClass = JMember {
            attr = attrTop,
            jtype = cType,
            name = ijLigatur, -- println ("final public static " ++ constClass g ++ "
            init = Just (JNew cType []) }
        cType = Ref (JName "" (constClass g)) []
    pp (anno cClass)
-- 
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymT {sid} <- vals ])
        >>= ppSSC
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymC {sid} <- vals ])
        >>= ppSSC
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymI {sid} <- vals ])
        >>= ppSSC
    -- do variables in dependency order, this is so that CAFs refer only to CAFs
    -- whose java initialization occurs earlier
    let vars = [ s | s@SymV {} <- vals ]
    -- names   <- mapSt U.fundep vars
    -- varsyms <- mapSt U.findV (concat (U.tsort names))
    mapSt U.fundep vars >>= mapSt U.findV . concat . U.tsort >>= mapSt (symCode Nil) >>= ppSSC 
    -- mapSt (symCode Nil) varsyms >>= ppSS

    -- constants
    makeConstants
 
    -- lazy lambda classes
    g <- getST
    foreach (each g.gen.lambdas) (emitLazy >=> sequence • map (pp • anno) • unCommentG g) 

    let toMaybe = [
            "final public static TMaybe _toMaybe(Object it) {",
            "   return it == null ? TMaybe.DNothing.it : TMaybe.DJust.mk(it);",
            "}",
            ]
    when (g.thisPack == pPreludeBase) (foreach toMaybe U.println)
    let toList = [ 
             "final public static<T> TList _toList(T[] arr) {",
             "   if (arr == null) return PreludeBase.TList.DList.it;",
             "   int i = arr.length - 1;",
             "   TList it = TList.DList.it;",
             "   while (i >= 0) {",
             "       final T elem = arr[i];",
             "       i = i-1;",
             "       if (elem == null) continue;",
             "       it = TList.DCons.mk(elem, it);",
             "   }",
             "   return it;",
             "}",
             "final public static TList _toList(Iterable<Object> iter) {",
             "   return (new frege.runtime.Func1() {",
             "       @Override public TList eval(Object arg) {",
             "           @SuppressWarnings(\"unchecked\")",
             "           final java.util.Iterator<Object> iter = (java.util.Iterator<Object>)arg;",
             "           while (true) {",
             "               if (iter.hasNext()) {",
             "                   final Object x = iter.next();",
             "                   if (x == null) continue;",
             "                   return PreludeBase.TList.DCons.mk(x,", 
             "                              this.apply(iter));",
             "               }",
             "               else return PreludeBase.TList.DList.it;",
             "           }",
             "       }",
             "   }).apply(iter.iterator()).<TList>forced();",
             "}" ]                
 
    when (g.thisPack == pPreludeBase) (foreach toList U.println)
    
    let mainCode = [
            "public static void main(final java.lang.String[] argv) {",
            "    final long t1 = java.lang.System.nanoTime();",
            "    frege.runtime.Runtime.runMain(",
            "       " ++ pPreludeBase.unpack g ++ ".TST.performUnsafe(",
            "           " ++ constClass g ++ "._mainƒ.apply(" 
                                ++ pPreludeBase.unpack g 
                                ++ "._toList(argv)).<frege.runtime.Lambda>forced()));",
            "   final long t2 = java.lang.System.nanoTime();",
            "   java.lang.System.err.println(",
            "     \"runtime \" + ((((t2 - t1) + 500000) / 1000000) / 1e3) + \" wallclock seconds.\");",
            "}"
            ]
        haveMain = case (VName g.thisPack "main").findit g of
                Just sym -> sym.name.pack == g.thisPack
                other -> false
    when (haveMain) (foreach mainCode U.println)
    U.println "}"
 
    stio ("java7 class", 1)
 
--- print lists of lists of annotatable items
ppSS xss = foreach (concat xss) (pp • anno)

unCommentG g gs = if U.isOn (Global.options g).flags COMMENTS 
                    then gs else unComment gs

ppSSC xss = do
    g <- getST
    ppSS (map (unCommentG g)  xss)

makeConstants = do
         g <- getST
         lams   <- genAnonLams 
         consts <- mapSt genConst (keys g.gen.consts)
         let ccType = (Ref (JName "" (constClass g)) [])
             constclass = JClass   { attr = attrs [JPublic, JStatic],
                                     jtype = ccType,
                                     extend = Nothing,
                                     implement = [],
                                     defs = constructor:(lams ++ consts)}
             constructor = JConstr { attr = attrs [JPublic],
                                     jtype = ccType,
                                     args = [],
                                     body = JBlock []}
         pp (anno constclass)
         stio ()
     where
         genConst (kind,value) = do
             g <- getST
             jname <- findConst Lit {pos=Position.null, typ = Nothing, kind, value}
             let lsigma = TY.litSigma kind
                 numv = (#_#.matcher value).replaceAll ""
                 bjt  = sigmaJT g lsigma
             let it = JMember { attr = attrs [JPublic, JFinal],
                                jtype = bjt, name = jname.base, init = Just ex }
                 ex = case kind of
                     LBig   -> JNew (Ref (JName "" "java.math.BigInteger") []) [JAtom (show numv)]
                     LRegex -> JInvoke
                                 (JStMem (JName "java.util.regex.Pattern" "compile") [])
                                 [JAtom value]
                     LInt      -> JAtom numv
                     LLong     -> JAtom numv
                     LDouble   -> JAtom numv
                     LFloat    -> JAtom numv
                     otherwise -> JAtom value
 
                 -- nb = newBind g lsigma ex
             stio it
 
 
-- genMain = do
--     g <- getST
--     case (VName g.thisPack "main").findit g of
--         Just sym | sym.name.pack == g.thisPack = do         -- we have a main
--             let -- tc n = TCon {pos=sym.pos, name = TName pPreludeBase n}
--                 tauSig tau = ForAll [] (RhoTau [] tau)
--                 sarr = TName (Pack.new "frege.prelude.Arrays") "StringArray"
--                 sarrTau = tauSig (TApp (TCon Position.null sarr) (tc "Immutable"))
--             sarrJT <- sigmaJT sarrTau
--             let args = [(attrFinal, sarrTau, strict sarrJT, "argv")]
--             let st   = (tc "ST").name
--                 stpu = MName st "performUnsafe"
--                 toli = MName sarr "toList"
--             vstpu <- U.findV stpu
--             vtoli <- U.findV toli
--             let avb = argBind (head args)
--                 slist = TApp (tc "[]") tauString
--                 sig1 = ForAll [] (RhoFun [] (sarrTau) (RhoTau [] slist))
--             btoli <- instSymDirect sym.pos vtoli sig1
--             let  apparg = JInvoke btoli.jex [avb.jex]
--             bmain <- instSymDirect sym.pos sym mainSigma
--             let applist = (JCast jtFun
--                             • JX.invoke [] • JX.xmem "_e"
--                             • JX.invoke [apparg]) bmain.jex
--                 iovoid = TApp (TApp (tc "ST") (tc "RealWorld")) (tc "()")
--                 sig2 = ForAll [] (RhoFun [] (tauSig iovoid) (RhoTau [] (tc "()")))
--             bperf <- instSymDirect sym.pos vstpu sig2
--             let appio = {- JCast jtFun -} (JInvoke bperf.jex [applist])
--                 -- appe  = JInvoke (JExMem appio "_e") []
--                 appe  = JInvoke (JStMem (JName "frege.RT" "fjMain") []) [appio]
--                 gettime s = JMember {attr = attrFinal, jtype = Nativ "long" [], name=s,
--                             init = Just (JInvoke
--                                 (JStMem (JName "java.lang.System" "nanoTime") [])
--                                 [])}
--                 stmts = [ JLocal (gettime "t1"), JEx appe, JLocal (gettime "t2"), times ]
--                 times = JEx (JInvoke (JStMem (JName "java.lang.System.err" "println") [])
--                                 [ex1])
--                 ex1 = JBin (JAtom "\"runtime \"") "+" ex2
--                 ex2 = JBin ex3 "+" (JAtom "\" wallclock seconds.\"")
--                 ex3 = JBin ex4 "/" (JAtom "1e3")
--                 ex4 = JBin ex5 "/" (JAtom "1000000")
--                 ex5 = JBin ex6 "+" (JAtom "500000")
--                 ex6 = JBin (JAtom "t2") "-" (JAtom "t1")
--                 mMeth = JMethod {attr = attrs [JPublic, JStatic], gargs = [],
--                             jtype = Nativ "void" [],        -- sure thing :)
--                             name  = "main",
--                             args, body = JBlock stmts }
--             stio [mMeth]
--         sonst -> stio []
-- 
--- the @constructor@ method
--- >final public int _constructor() { return n; }
cMethod n = atomMethod "_constructor" (Nativ "int" []) (show n)
-- 
-- --- the @_u@ method
-- --- >final public boolean _u() { return false; }
-- uMethod = atomMethod "_u" (Nativ "boolean" []) "false"
-- 
-- --- the @_v@ method
-- --- >final public Lazy<FV> _v() { return this; }
-- vMethod = atomMethod "_v" (lazy jtValue) "this"
-- 
-- --- the @_e@ method
-- --- >final public FV _e() { return this; }
-- eMethod = atomMethod "_e" jtValue "this"
 
 
{--
  * [usage] @atomMethod name type atom@
  * [returns] a 'JMethod' of the form @final public /type/ /name/() { return /atom/; }@
  -}
atomMethod s jt atom = JMethod {attr = attrs [JFinal, JPublic], gargs=[], jtype = jt,
                     name = s, args=[], body = JBlock [ JReturn (JAtom atom) ]}
 
 
{--
   Code for data constructors
 
   - For nullary constructors, a subclass of @Value@ is derived that contains a singleton and
     an appropriate @mk@ method.
   - For non-strict constructors with arity > 0, a subclass of @Algebraic@
     with a static @mk@ method is derived.
   - For strict constructors, the members are generated directly.
  -}
conCode symt cons (sym@SymD {flds, cid}) = do
    g <- getST
    si <- symInfo sym
    lazyM <- lazyDeclarations [sym]
    let symtjt  = sigmaJT g (Symbol.typ symt)
        jtype   = (variantType g symtjt sym).{jname <- JName.{qual = ""}}
        -- argtys  = map ConField.typ flds
        arity   = length flds
        comment = JComment (nice sym g)
        result  = sumCon
        sumCon  = JClass {attr = attrTop,
                             jtype = jtype, 
                             extend = Just jtAlgebraic, 
                             implement = imp, defs}
        imp = [symtjt]
 
        defs = [comment, constr, cMethod cid, make]
                   ++ singlelazy ++ getters ++ members
        singlelazy 
            | arity == 0 = [JMember {attr = attrs [JFinal, JPublic, JStatic],
                                         jtype = jtype,
                                         name = "it",
                                         init = Just (JX.new [] jtype)}]
            | otherwise = lazyM
        !make 
            | arity == 0 = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                     gargs = [], jtype = symtjt, name = "mk",
                                     args = [],
                                     body = JBlock [JReturn (JAtom "it")]}   
            | otherwise  = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                     gargs = [], jtype = symtjt, name = "mk",
                                     args = constrargs,
                                     body = JBlock [JReturn (JNew jtype args)]}
 
        
        constrargs  = argDefs attrFinal si argNames
        args = take arity (map JAtom argNames)
        
         -- rbinds = [ Bind RLazy sig jt (JAtom n) | (_,sig,jt,n) <- constrargs ]
        constr = JConstr {attr = attrs [JPrivate], jtype = jtype,
                             args = constrargs,
                             body = JBlock super}
        namedfields = namedFields flds
        !super 
            | arity == 0 = []
            | otherwise = zipWith (assign g) namedfields constrargs
                                                     
        getters = -- if symt.product then [] else
                     atomMethod (conGetter sym.name) jtype "this" :
                     [ atomMethod (conGetter (Symbol.name con))
                                  (variantType g symtjt con) "null"
                          | con <- cons, Symbol.sid con != sym.sid ]  -- other constructors
        members  =  zipWith (mkMember g) namedfields constrargs
    stio [result]
conCode symt cons nocon = error "conCode: no Con"

mkMember g Field{pos, name = Just mem, doc, vis, strict=s, typ} (_,_,jt,_) 
            = JMember {attr = attrs [JFinal, JPublic],
                    jtype = jt,
                    name = mem, 
                    init = Nothing}
mkMember g f _ = error "mkMember: apply only named fields here"     -- see namedFields

assign :: Global -> ConField QName -> FormalArg -> JStmt
assign g Field{pos, name = Just toname, doc, vis, strict, typ} formalArg  
        = JAssign (JAtom toname) bind.jex
    where
        bind   = adaptArg g formalArg (if strict then S[] else U)
assign g f a = error "assign: apply only named fields here"     -- see namedFields

{--
  * Code for data types
  *
  * - Native types create a class @TName@ that acts as namespace for
  *   member definitions.
  * - Enumerations create a class @TName@ that contains final Box.Int DCon = Box.Int.mk(cid)
  * - Algebraic types create an interface @TName@ that extends @Val@
  *   implements @Lazy<FV>@ and contains
  *   an abstract method @DCon@ to get the variant associated with @DCon@.
  -}
symCode binds (sym@SymT {enum=true}) = do
     g <- getST
     let vals  = sortBy (comparing Symbol.name) (values sym.env)
         cons  = [ con | con@SymD {sid} <- vals ]                    -- constructors
         other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- non constructors

     lazyDefs <- lazyDeclarations vals 
     subDefs <- mapSt (symCode binds) other
 
     let jtype = Ref {jname = U.javaName g sym.name, typeargs = []}     -- TName
         !result = JClass {attr = attrTop, jtype,
                         extend = Nothing,
                         implement = [],
                         defs = (constr : conDefs) ++ lazyDefs ++ concat subDefs}
         constr = JConstr { attr = attrs [JPrivate], jtype, args=[], body = JBlock []}
         conDefs = [ JMember {attr = attrTop,
                         jtype = jtInt,
                         name = mangled name.base,
                         init = Just (JX.atom (show cid))}
                       | SymD {name, cid} <- cons ]
     stio [JComment (nice sym g), result]
 
 
symCode binds (sym@SymT {product=true, newt=true}) = do
     g <- getST
 
     let vals = sortBy (comparing Symbol.name) (values sym.env)
         other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- sub definitions
 
     lazyDefs <- lazyDeclarations other
     subDefs <- mapSt (symCode binds) other
 
     let jtype  = Ref (U.javaName g sym.name) []
         defs   = lazyDefs ++ concat subDefs
         !result = JClass {attr = attrs [JAbstract, JPublic, JStatic], jtype,
                          extend = Nothing, implement = [], defs}
     stio [JComment (nice sym g), result]
 
 
symCode binds (sym@SymT {product=true}) = do                    -- product
    g <- getST
 
    let vals    = sortBy (comparing Symbol.name) (values sym.env)
        other   = [ sym | sym <- vals, not (Symbol.{flds?} sym)]
    subDefs     <- mapSt (symCode binds) other
    lazyDefs    <- lazyDeclarations vals
    
    let symjt   = sigmaJT g sym.typ
        jtype   = symjt.{jname = U.javaName g sym.name}
        symd    = head [ con | con@SymD {sid} <- vals ]            -- constructor
    si <- symInfo symd
    let (_, argtys) = U.returnType symd.typ.rho
        -- struct      = symd.strsig.isStrict
        -- funty   = sigmaJT g symd.typ
        -- ftypes  = map (sigmaJT g) (map ConField.typ symd.flds)        -- field types
        -- argjts  = map (sigmaJT g) argtys
        arity   = length symd.flds
        imp     = []                              -- implements Value
        defs    = [comment, constr, cMethod symd.cid,
                         -- atomMethod "_v" jtype "this",
                         -- atomMethod "_e" jtype "this",
                         make] ++ members ++ lazyDefs ++ concat subDefs
        comment     = JComment (nice symd g)
        constrargs  = argDefs attrFinal si argNames
        args        = take arity (map JAtom argNames)
        constr      = JConstr {attr = attrs [JPrivate], jtype = jtype,
                             args = constrargs,
                             body = JBlock super}
        namedfields = namedFields symd.flds
        super = zipWith (assign g) namedfields constrargs
        make  = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                         gargs = jtype.typeargs, jtype, name = "mk",
                         args = constrargs,
                         body = JBlock [JReturn (JNew jtype args)]}
        members = zipWith (mkMember g) namedfields constrargs
        !result = JClass {attr = attrTop, jtype,
                          extend = Just jtAlgebraic, 
                          implement = imp, defs}
    stio [JComment (nice sym g), result]

symCode binds (sym@SymT{env = Nil, nativ = Nothing, product=false, enum=false, newt=false})
        = do
            g <- getST
            stio [JComment (nice sym g)]                          -- empty type
        
symCode binds (sym@SymT {nativ=Nothing}) = do                   -- sum type
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
         cons = [ con | con@SymD {sid} <- vals ]
         funs = [ sym | sym@SymV {sid} <- vals, not (Symbol.{flds?} sym)]
     funDefs <- mapSt (symCode binds) funs
     lazyFuns <- lazyDeclarations funs
     conDefs <- mapSt (conCode sym cons) cons
     let symjt = sigmaJT g sym.typ
     -- U.logmsg TRACEG sym.pos (text ("symCode: " ++ nicer sym g ++ " " ++ show symjt))
     let jtype
            | symjt.{jname?} = symjt.{jname = U.javaName g sym.name}
            | otherwise = Ref (JName "" "Strange") [symjt]
         getCons = [JMethod {attr = attrs [JPublic], gargs=[],
                             jtype = variantType g jtype con,
                             name = conGetter (Symbol.name con),
                             args = [], body = JEmpty}
             | con <- cons ]
         mClass | null funs = []
                | otherwise    = [JClass {attr = attrs [JPublic, JStatic, JFinal],
                                     jtype = Ref (JName "" "M") [],
                                     extend = Nothing, implement = [],
                                     defs = lazyFuns ++ concat funDefs}]
         result = JInterface {attr = attrs [JPublic], jtype,
                             implement = [jtValue, Lazy Lambda],
                             defs = getCons ++ concat conDefs ++ mClass}
     stio [JComment (nice sym g), result]
 
symCode binds (sym@SymT {sid, nativ = Just _}) = do                               -- nativ
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
     subDefs <- mapSt (symCode binds) vals
     lazyDefs <- lazyDeclarations vals
     let jtype = Ref {jname = U.javaName g sym.name, typeargs=[]}
         !result = JClass {attr = attrTop,
                             jtype, extend = Nothing, implement = [],
                             defs = lazyDefs ++ concat subDefs}
     stio [JComment (nice sym g), result]
 
{--
    Code for type classes
  
    - interface @Cname@</a/> where /a/ is the class variable
    - for each class method, an abstract method that returns a function (i.e. @Lambda@)
    - name space @I@ for default function implementations
    -}
symCode binds (sym@SymC {sid}) = do           -- type class
     g <- getST
     let vals = sortBy (comparing Symbol.name) (values sym.env)
     abstrFuns <- mapSt (abstractFun sym) vals
     let ivals = filter (isJust • Symbol.expr) vals         -- default implementations
     implFuns <- mapSt (symCode binds) ivals
     -- taujt    <- tauJT sym.tau
     let jtype = Ref (U.javaName g sym.name) []
         superclasses = [ Ref (U.javaName g nm) [] | nm <- sym.supers ]
         implDef
             | null implFuns = []
             | otherwise = [JClass {attr = attrs [JPublic, JStatic],
                             jtype = Ref (JName "" "I") [],
                             extend = Nothing, implement = [], defs = concat implFuns}]
         result = JInterface (attrs [JPublic]) jtype superclasses (concat abstrFuns ++ implDef)
     stio [JComment (nice sym g), result]
 
{--
     Code for instances
 
     - interface @Cname@</a/> where /a/ is the class variable
     - for each class method, an abstract method that returns a function
     - name space for default functions (?)
     -}
symCode binds (sym@SymI {sid}) = do             -- instance definition
     g <- getST
     csym <- U.findC sym.clas
 
     let -- bnds    = sym.typ.bound
         classes = sym.clas:csym.supers
         -- the functions we must provide in the instance
         superMethods = [ m.name.base | c <- classes,
                                   SymC{env} <- QName.findit c g,
                                   m@SymV{}  <- values env ]
         -- links in type that point to instance members of this class and its superclasses
         -- The goal is to have (links to) implementations of all super class methods. 
         methods1 = case U.instTSym (Symbol.typ sym) g of
              Just (tsym@SymT {pos}) -> [ alias |
                                SymL {alias} <- values tsym.env, alias.{tynm?},    -- links
                                alias.base `elem` superMethods,           -- mentioning one of our methods
                                SymI {clas} <- QName.findit alias.tynm g, -- pointing to an instance
                                SymC {supers} <- QName.findit clas g,     -- of a class that is in our hierarchy
                                clas `elem` classes || any (`elem` classes) supers]
              _ -> error "unexpexted result from instTSym"
         methods2 = [ name | name  <- map Symbol.name (values sym.env), name `notElem` methods1 ]
         methods  = methods1 ++ methods2
 
     let vals = sortBy (comparing Symbol.name) (values sym.env)
 
     instFuns  <- mapSt (instFun csym sym) methods
     instImpls <- mapSt (symCode binds) vals
     lazyImpls <- lazyDeclarations vals
     -- let symjt    = sigmaJT g sym.typ
     let constraints = map  (uncurry (makeConstraintDef g)) (zip sym.typ.rho.context ctxNames)
         constrargs  = map  (uncurry (makeConstraintArg g)) (zip sym.typ.rho.context argNames)
 
 
     let jtype = Ref (U.javaName g sym.name) []          -- jtargs
         etype = Ref (U.javaName g sym.clas) []          -- [instjt]
         constructor = JConstr {attr = attrs [JPublic],
                                 jtype = jtype,  
                                 args = constrargs,
                                 body = JBlock (take (length constraints)
                                                 (zipWith JAssign
                                                     (map JAtom ctxNames)
                                                     (map JAtom argNames)))}

         singleton
            | null constrargs = [JMember{attr = attrTop, jtype, name="it", 
                init = Just (JNew jtype [])}]
            | otherwise = [] 
         result = JClass {attr = attrs [JPublic, JFinal, JStatic], jtype,
                          extend = Nothing,
                          implement = [etype],
                          defs = (constructor : constraints)
                             ++ singleton
                             ++ concat instFuns
                             ++ lazyImpls
                             ++ concat instImpls}
     stio [JComment (nice sym g ++ " :: " ++ nice sym.typ g), result]
 
 
symCode _ (sym@SymL{}) = getST >>= stio • (:[]) • JComment • nice sym
symCode binds (sym@SymV {nativ = Just item}) = methClass sym
symCode binds (sym@SymV {expr = Just x})
    | sym.depth > 0 = do
        g <- getST
        trace g
        funCode sym binds
    | otherwise     = do
        g <- getST 
        trace g
        cafCode sym binds
    where
        trace g = U.logmsg TRACEG sym.pos (text ("compiling " ++ sym.nice g))
 
--- unimplemented items produce a comment and an error message
symCode binds sym = do
     g <- getST
     U.error sym.pos (text ("Can't generate code for " ++ nice sym g))
     stio [JComment (nice sym g)]
 
--- declare abstract class Member function
abstractFun symc (sym@SymV {sid}) = do
     g <- getST
     let classCtx = Ctx {pos=Position.null, 
                        cname = Symbol.name symc, 
                        tau = Symbol.tau symc, checked = false }
         ctxs = [ ctx | ctx <- sym.typ.rho.context,
                     not (TC.sameCtx ctx classCtx)]      -- filter out class context
 
     let constrformal = map (uncurry (makeConstraintArg g)) (zip ctxs ctxNames)
         cafMeth = sym.depth == 0
     let    result = JMethod {attr = attrs [JPublic],
                             gargs = [],       -- map targ (filter (!=tauvar) bnds),
                             jtype = if cafMeth 
                                        then (lazy . tauJT g . fst . U.returnType) sym.typ.rho 
                                        else Lambda,    
                             name = latinF ++ mangled sym.name.base,
                             args = constrformal,
                             body = JEmpty}
     stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]
abstractFun _ _ = undefined
 
{--
   >  class @Eq eq@
   >  instance `Eq_(,,,)` :: forall u v w x.(Eq v,Eq w,Eq x,Eq u) => (w,x,u,v)
   >  class member function `Eq.!=` :: forall eq.Eq eq => eq -> eq -> Bool
   >  instance member `Eq_(,,,).!=` :: forall a b c d.(Eq b,Eq c,Eq d,Eq a) => (c,d,a,b) -> (c,d,a,b) -> Bool
   Extra type variables and constraints in instance member must be retained.
   Therefore:
   1. rename all type variables in instance member type so that the type variables
   in the instance type and the instance member type are distinct
   2. unify class member type and instance member type, note what is bound to the class variable
   3. unify instance type and the result from previous step
   4. substitute it in instace member type
   5. reconstruct forall bound in instance member type
  -}
fakeInstSigma (symc@SymC{supers}) (symi@SymI{sid}) (sym@SymV{typ}) = do
     g <- getST
     let symjsb      = sym.typ.vars
         instjsb     = symi.typ.vars
 
     let newvars = [ TVar {pos=sym.pos, var, kind=KVar} |
                         var <- U.allBinders,
                         var `notElem` instjsb,
                         var `notElem` symjsb ]
         tree1 = Tree.fromList (zip symjsb newvars)
     rho1 <- U.substRho tree1 sym.typ.rho
     U.logmsg TRACEG sym.pos (text ("renamed  " ++ nicer sym.typ g ++ "  to  " ++ nicer rho1 g))
 
     let classes = symc.name:symc.supers
         memc = head [ sym | c <- classes, sym <- ((MName c sym.name.base).findit g).toList ]
     symc <- U.findC memc.name.tynm
     let clas = symc.tau
         tree2 = U.unifySigma g memc.typ (ForAll [] rho1.{context=[]})
     U.logmsg TRACEG sym.pos (text ("unifySigma (" ++ nicer memc.typ g ++ ") "
             ++ "(" ++ nicer (ForAll [] rho1.{context=[]}) g ++ ")"
             ++ " = " ++ show [(v, nicer t g) | (v,t) <- tree2.each]))
     let itau    = unJust (tree2.lookupS clas.var)       -- member type MUST mention it, see Classes.fr
         sigma2a = ForAll [] (RhoTau [] itau)
         validSigma rho = ForAll (map Tau.varkind (U.freeTVars [] rho)) rho
         sigma2 = validSigma sigma2a.rho
     U.logmsg TRACEG sym.pos (text ("class var  " ++ clas.var
             ++ "  in  " ++ nicer memc.typ g
             ++ " corresponds to  " ++ nicer sigma2 g))
 
     let tree3 = U.unifySigma g sigma2 symi.typ
     rho4   <- U.substRho tree3 rho1
 
     let sigma4 = validSigma rho4      -- provide type variables
         bvars  = filter (`elem` sigma4.vars) instjsb ++ filter (`notElem` instjsb) sigma4.vars
         s4tree = Tree.fromList sigma4.bound
         kinds  = map (maybe KVar id . lookup s4tree) bvars
         bound = zip bvars kinds
         sigma5 = ForAll bound rho4      -- binds in correct order
     U.logmsg TRACEG sym.pos (text ("fake type is  " ++ nicer sigma5 g))
     stio sym.{typ=sigma5}
fakeInstSigma _ _ _ = error "fakeInstSigma: bad args"
 
instFun :: Symbol -> Symbol -> QName -> StG [JDecl]
instFun symc symt mname = do
     g <- getST
     -- establish a fake type for instance member that matches the one of the instance
     -- cmem  <-  U.findV (MName (Symbol.name symc) (QName.base mname))
     sym   <-  U.findV mname
     sym   <-  fakeInstSigma symc symt sym
 
     -- let bndsV = sym.typ.bound
     --    bndsI = (Symbol.typ symt).bound
     let implies = impliesG g
         ctxs = [ ctx | ctx <- sym.typ.rho.context,
                        not (any (`implies` ctx) symt.typ.rho.context)]
         ourCtxNms = drop symt.typ.rho.context.length ctxNames   -- ctx3, ctx4, ....
         isCAF = null ctxs && sym.depth == 0
         csig = sym.typ.{rho <- Rho.{context = symt.typ.rho.context ++ ctxs}}
         csym = sym.{typ = csig}
 
     let cmeth = case sym.expr of
             Just (v@Vbl {name=MName cname bs})
                 | cname `elem` (symc.name:symc.supers),
                   Just (meth@SymV{}) <- v.name.findit g,    -- just class method
                   isJust meth.nativ || isJust meth.expr = meth
             other -> sym -- instance method
 
     mhbind <- compiling csym (instSym sym.pos cmeth sym.typ)
 
 
     let constrformal = map (uncurry (makeConstraintArg g)) (zip ctxs ourCtxNms)
         sjt          = if isCAF 
                            then (lazy . tauJT g . fst . U.returnType) sym.typ.rho 
                            else Lambda
     let -- constrargs   = map JAtom (take sym.typ.rho.context.length ctxNames)
         -- eosjt = erasedObj sjt
         result = JMethod {attr = attrs [JPublic, JFinal],
                             gargs = [],      -- ftargs,
                             jtype = sjt,     -- if higher then eosjt else sjt,
                             name = latinF ++ mangled sym.name.base,
                             args = constrformal,
                             body = JBlock ([JReturn impl])}
         impl = mhbind.jex
 --            | null constrargs = mhbind.jex
 --            | otherwise = JX.new [bindto] jtMH
 --            where bindto = fold app (JX.xmem "j" mhbind.jex) constrargs -- mh.j.bindTo(ctx1) ...
 --        app x a = (JX.invoke [a] • JX.xmem "bindTo") x
     stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]
 
 
 
{--
     Return the 'JName' of the worker function for the given symbol.
     [enum constructor]    @P.T.D@, actually a boxed int
     [newtype constructor] @P.T.mk@ (identity function)
     [product constructor] @P.T.mk@
     [sum constructor]     @P.T.D.mk@
     [let bound function/value] not usable, let bound definitions only accessible via 'Binding's
     [top level value]     @P.name@, @P.T.m.name@, @P.I.name@, @P.C.i.name@
     [top level function with constraints] @X.name.work@ (non static)
     [top level function, no constraints]  @X.name@
 -}
workerMethod :: Global -> Symbol -> JName
workerMethod g (sym@SymD {name, flds}) = case U.javaName g name of
         jname | Just (SymT {enum = true}) <- name.tynm.findit g = jname
               | null flds = U.memberOf jname "it"
               | otherwise = U.memberOf jname "mk"
workerMethod g (sym@SymV {name, depth = 0}) = U.javaName g name
workerMethod g (sym@SymV {name = Local{}})  = case g.gen.syminfo.lookup sym of
    Just si -> (U.javaName g sym.name).{base=workNameSI si}
    other -> error("No syminfo yet for " ++ nicer sym g)
workerMethod g (sym@SymV {name})            = U.javaName g name
workerMethod g _ = error "workerMethod: no SymV"
 
-- {--
--     Return the 'JName' of the lambda wrapper class for this symbol, if it has one.
--     This is mainly used to find the type argument for @*new*@.
-- 
--     [data constructors with arity 0]    'Nothing', has none
--     [data constructors with arity > 0]  'Nothing', singelton lambda made on the fly
--     [values] Nothing, has none
--     [let bound function] L/N/, where /N/ is unique. Only valid in scope of binding.
--     [top level function with constraints] @X.name@ (to be initialized with constraints)
--     [top level function, no constraints]  'Nothing', singleton lambda made on the fly
-- --}
-- wrapperClass :: Global -> Symbol -> Maybe JName
-- wrapperClass g (sym@SymD {}) = Nothing
--     -- null flds = Nothing
--     -- otherwise = Nothing
-- wrapperClass g (sym@SymV {name, depth, sid})
--     | depth == 0 = Nothing
--     | Local{} <- name = Just (JName "" ("L" ++ show sid))
--     | null sym.typ.rho.context = Nothing
--     | otherwise = Just (U.javaName g name)
-- wrapperClass g sym = error ("wrapperClass: bad arg " ++ sym.nice g)
-- 
-- 
-- {--
--     The name of the static variable that holds an instance of the 'wrapperClass'.
--     If this is a value or a nullary constructor, it returns the same as 'workerMethod'.
-- 
--     Note that let bound symbols must use the 'Binding' they are bound to.
-- 
--     [data constructors with arity > 0]   @M.T.D.ﬂmk@
-- --}
-- {-
-- wrapperInstance :: Global -> Symbol -> JName
-- wrapperInstance g (sym@SymD {strsig, flds})
--     | null flds = workerMethod g sym
--     | otherwise = (workerMethod g sym).{base <- (++ latinF)}
-- wrapperInstance g (sym@SymV {name}) 
--     | not name.isLocal = (workerMethod g sym).{base <- (++ latinF)}
-- wrapperInstance g sym = error ("wrapperInstance: bad arg " ++ sym.nice g)
-- -}
-- 
{--
     This is used for let bound functions and top level functions with constraints.
     Both have normally an @eval@ method that is lazy in all arguments and return type
     and a @work@ method that has at least one non lazy arg or the return type is not lazy.
 
     Sometimes it happens that he worker method would have the same method signatur
     as the eval method. In that case, we can just do the computation in the @eval@ method
     instead of passing the arguments to @work@. Saves at least one stack frame.
 
     This function returns @"eval"@ if the @eval@ function can do the work, otherwise @"work"@.
 --}
workName :: JType -> [JType] -> String
workName rt ats  
    | rt == Lazy Something,
      all (Lazy Something ==) ats = "eval"
    | otherwise = "work"

workNameSI :: SymInfo -> String
workNameSI si = workName si.returnJT si.argJTs 

{--
    @makeConstraintDef (Ctx cname tau) "ctx3"@ = final Ccname<tau> ctx3
-}
makeConstraintDef g (Ctx {cname,tau}) s =
         -- g    <- getST
         -- itau <- tauJT tau
         JMember {
             attr = attrFinal,
             jtype = Ref (U.javaName g cname) [],
             name = s,
             init = Nothing}
 
{--
    @makeConstraintArg (Ctx cname tau) "arg3"@ = (final,  Ccname<tau>, "ctx3")
  -}
makeConstraintArg g ctx s = (def.attr, (ForAll [] (RhoTau [ctx] (Context.tau ctx))), def.jtype, def.name)
     where def = makeConstraintDef g ctx s
 
 

{--
    the mode a certain argument is in, given strictness and sigma
    -}
-- argMode g s sig = jtRmode (argType g (Strictness.isStrict s) sig)

 
{--
     Adapt a 'Binding' to the required strictness and target type.
    --}
adaptBind :: Global -> Binding -> Strictness -> Binding
adaptBind g bind s
     = adaptSigmaWith (if Strictness.isStrict s then strict else lazy) g bind
        
 
--- adapt argument to wanted strictness
adaptArg g a s = adaptBind g (arg2Bind g a) s

--- instantiate 'Binding' for an Argument
instArg g a = adaptSigma g (arg2Bind g a)

{--
  * code for non-functions
  * - if there are constraints, we make a static function with constraint args.
  * - else, if the easy bit is off, we make an Delayed<type> and write the code in the eval function.
  * - else we just initialize
  -}
cafCode (sym@SymV {depth = 0, expr = Just x}) binds = do
    g    <- getST
    let bnds = sym.typ.bound
        ctxNames = drop (length (envCtxs g)) GenJava7.ctxNames
 
    let (rtyp, _) = U.returnTypeN 0 sym.typ.rho
        symtyp = ForAll bnds rtyp
        -- mode  = argMode g (if rlazy then U else S[]) symtyp
        rlazy = not g.toplevel && not sym.strsig.isStrict 
                 || not (RValue `member` sym.rkind)
        rsimple = RSimple `member` sym.rkind        
        ctxs  = if null bnds then [] else filter  (not • Context.checked) sym.typ.rho.context
        cargs = map  (uncurry (makeConstraintArg g)) (zip ctxs ctxNames)
         -- constraints = map  (uncurry (makeConstraintDef g)) (zip ctxs ctxNames)
        jtype = sigmaJT g symtyp
        rtype = returnType sym.rkind jtype
    selfrec <- if rsimple || g.toplevel then return 0 else T.references [sym.sid] x
    escode  <- if null cargs && rsimple
         then do
             ecode <- compiling sym (genExpr false rtype x binds)
             stio (Left ecode)
         else do
             let badguard = T.openCaseWhen g x
                 jthrow = [JThrow (JNew (Ref (JName "frege.runtime" "GuardFailed") []) [
                                                     JAtom (show (nicer sym g)),
                                                     JAtom (show sym.pos)])]
             code <- compiling sym (genStmts (autoboxed rtype) x binds)
             case badguard of
                 Just (Left x) -> do
                     U.warn (getpos x) (msgdoc ("guard (" ++ nice x g ++ ") may evaluate to false."))
                     stio (Right (code ++ jthrow))
                 Just (Right p) -> do
                     U.warn (getpos p) (msgdoc ("pattern guard (" ++ nice p g ++ ") may fail to match."))
                     stio (Right (code ++ jthrow))
                 Nothing -> stio (Right code)
 
 
    let name  = U.javaName g sym.name           -- P.foo
        left (Left c) = c
        left _ =  error "no ecode"
        right (Right c) = c
        right _ =  error "no scode"
        ecode  = left escode
        scode  = right escode
        
        comms = reverse [
                 JComment (either show (const "no binding") escode),
                 JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                 JComment (nicer sym.typ g), JComment (nicer x g)]
        jexpr = (adapt ecode rtype).jex
        static = if g.toplevel then JStatic else JFinal
        publik = if g.toplevel then JPublic else JFinal
        cafV  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                           name = name.base,
                           init = Just jexpr}
        utype = Ref jnDelayed []    -- Unknown<FV>
         -- ctype = Ref (JName "" cafV.name) (map targ bnds)
        newu  = JNewClass utype [] (unCommentG g [vMeth])          -- new Unknown<R>() { ... }
        theU
             | rlazy = newu
             | otherwise = (JX.invoke [] . JX.xmem "eval" ) newu
                                 
        theC = JX.jexmem 
            (JNewClass (Ref (JName "java.lang" "Object")[]) [] [cafU])
            cafV.name
        vMeth = JMethod { attr = attrs [JPublic, JFinal],
                           gargs = [],
                           -- @eval@ absolutely must return Lazy<T>
                           jtype = autoboxed rtype,
                           name = "eval", args = [], body = JBlock scode }
        cafU  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                           name = cafV.name,
                           init = Just theU}
         -- the following will be used for self-recursive local vars
         -- it is the lazy variant 'cafU' but enclosed in an extra class
         -- to avoid closure about a non-initialized value
        cafC  = cafU.{init = Just theC}                           
        cafF  = JMethod { attr = cafV.attr, jtype = boxed rtype,
                           gargs = [], name = cafV.name,
                           args = cargs, body = JBlock scode }
 
 
    when (!g.toplevel && not (null cargs)) do
         U.error sym.pos (text ("local CAF with constraints not allowed"))
    when (!g.toplevel && selfrec > 0) do
         U.hint sym.pos (text ("local self recursive values are expensive"))        
    let !caf = case (g.toplevel, not (null cargs), rsimple, selfrec > 0) of
             --top   cargs  simple, selfrec
             (false, false, false, true) -> cafC     -- self recursive local values
             (_,     false, false, _)    -> cafU
             (_,     false, true,  _)    -> cafV
             (true,  true,  _    , _)    -> cafF
             (false, true,  _    , _)    -> error "cannot happen"
    stio (reverse (caf:comms))
 
cafCode _ binds = error "cafCode: no caf"
-- --
-- --{--
-- -- * tell if a variable is implemented with a member or a class
-- -- -}
-- --varIsClass (sym@SymV {name, depth, rkind})
-- --    | depth > 0 = true
-- --    -- Local _ <- name = false
-- --    -- not (null (filter  (not • Context.checked) sym.typ.rho.context)) = true
-- --    | not (null sym.typ.bound) = true
-- --    | otherwise   = false
-- --    where
-- --        simple           = (rkind `band` 16) != 0
-- --        global (Local _) = false
-- --        global _         = true
-- --varIsClass _ = error "varIsClass: no var"
-- 
-- 
{--
    all the boilerplate code for a frege function
    -}
funCode (sym@SymV {expr = Just x}) binds = do
     g <- getST
     if g.toplevel then topFun   sym binds
                   else innerFun sym binds
funCode nofun binds = error "funClass: no function"
 
{--
    create new Lambda() { ...} from \x -> e
    -}
lambdaEx :: Expr -> Tree Symbol Binding -> StG Binding
lambdaEx (lam@Lam{pat,ex,typ=Just (sig@ForAll _ rho)}) binds = do
    g <- getST
    U.logmsg TRACEG (getpos ex) (text("lambdaEx: " ++ nice ex g ++ " :: " ++ nicer rho g))
    rho <- TC.zonkRho rho
    idsym <- U.findV  VName{pack=pPreludeBase, base="id"}
    rkind <- T.returnExprKind [] idsym lam
    
    let depth = U.lambdaDepth ex + 1
        argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
        (rty, atys) = U.returnTypeN depth rho
        lambdaTyp  = jtFunc depth 
        fake = (U.patLocal (getpos lam) 0 "\\lambda").{depth}
        -- sjt  = sigmaJT g sig
        rjt  = rhoJT g rty
        -- ajts = mapSt (sigmaJT g) atys
        workerArgs = evalArgDef attrFinal atys argNames
        -- mode = jtRmode retjt
        retjt = returnType rkind rjt
     
    
    stmts <- compiling fake (genLambda retjt lam workerArgs binds) 

    let worker = JMethod {attr = attrs [JFinal, JPublic],
                          gargs = [],
                          jtype = autoboxed retjt,
                          name = "eval",
                          args = reverse workerArgs,
                          body = JBlock stmts}
        theClass =  JNewClass lambdaTyp [] (unCommentG g [
            JComment  ("worker rkind=" ++ show rkind),
            worker])
    return (newBind g sig theClass)
 
lambdaEx ex binds = do
    g <- getST
    U.fatal (getpos ex) (text ("lambdaEx: bad lambda " ++ nice ex g))    
 
{--
     Create @final Func123 name = new Func123() { ... }
  -}
innerFun (sym@SymV {expr = Just x}) binds = do
     g <- getST
     si <- symInfo sym
     U.logmsg TRACEG sym.pos (text ("innerFun: " ++ nice sym.name g ++ " :: "
              ++ nice sym.typ.rho g ++ ", depth=" ++ show sym.depth))
     rho <- TC.zonkRho sym.typ.rho
 
     let argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
         argAttr = if RTailRec `member` sym.rkind then Attributes.empty else attrFinal
         -- (rty, _) = U.returnTypeN sym.depth sym.typ.rho
 
     let -- rjt        = rhoJT g rty
         wrkArgs    = argDefs argAttr si argNames
 
 
     let
         wrkType    = si.returnJT -- returnType sym.rkind rjt
         -- modew      = jtRmode wrkType
         wrkName    = workNameSI si
         letName    = U.javaName g sym.name
         lambdaTyp  = jtFunc sym.depth 
         classTyp   = Ref letName.{base <- ("F" ++)}  []
         thisName   = "this"  ++ show sym.sid
         thisBind   = Bind{stype = nicer sym.typ g,
                            ftype = sym.typ,
                            jtype = Lambda,
                            jex   = JAtom thisName}
         innerbinds = insert binds sym thisBind
 
     stmts        <- compiling  sym (genFunction sym wrkType wrkArgs innerbinds)
     lMethod      <- lazyMethod sym
 
     let worker = JMethod {attr = attrs [JFinal, JPublic],
                           gargs = [],
                           jtype = if wrkName == "eval" then autoboxed wrkType else wrkType,
                           name = wrkName,
                           args = wrkArgs,
                           body = JBlock (thisAssign:stmts)}
         -- final Lambda123 this123 = this;
         thisAssign = JLocal (JMember {attr = attrFinal, jtype=classTyp, name = thisName,
                                         init = Just (JAtom "this")})
         letVar = JMember { attr = attrFinal, jtype = classTyp, name = letName.base,
                             init = Just (JNew classTyp []) }
         defs
             | wrkName == "eval" =  [worker.{args <- reverse}]
             | otherwise      =  [worker, lMethod]
         theClass = JClass { attr = attrFinal, jtype = classTyp,
                             extend = Just lambdaTyp,
                             implement = [], defs}
 
 
 
 
     stio (unCommentG g [JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
         JComment (nicer sym.typ g),
         JComment (nicer x g),
         theClass, letVar
         ])
innerFun sym binds = error "innerFun: no function"


--- Generate code for a top level function 
topFun (sym@SymV {expr = Just x}) binds = do
    g <- getST
    si <- symInfo sym
    U.logmsg TRACEG sym.pos (text ("topFun: " ++ nice sym.name g ++ " :: "
              ++ nicer sym.typ.rho g 
              ++ ", depth=" ++ show sym.depth
              ++ ", rstate=" ++ show sym.rkind))
 
    let argNames    = drop (sum (map Symbol.depth g.genEnv)) GenJava7.argNames
        argAttr     = if RTailRec `member` sym.rkind then BitSet.empty else attrFinal 
        -- (rty, _) = U.returnTypeN sym.depth sym.typ.rho
        -- staticWorker = null sym.typ.rho.context
        constrargs  = map  (uncurry (makeConstraintArg g)) (zip sym.typ.rho.context ctxNames)
        -- rjt         = rhoJT g rty
        wrjt        = si.returnJT
        workerArgs  = argDefs argAttr si argNames
        -- modew       = jtRmode wrjt  -- wmode sym.rkind
        workerName  = (U.javaName g sym.name).base -- if staticWorker then (workerMethod g sym).base else workName g sym
 
    stmts           <- compiling sym (genFunction sym wrjt (workerArgs) binds)
     -- lClass <- prepareLazy sym  {- if staticWorker
     --             then return (JComment "has static worker")
     --             else lazyClass sym -}
 
    let worker      = JMethod {attr = attrs [JFinal, JPublic, JStatic],
                           gargs = targs sym.typ,
                           jtype = wrjt,
                           name  = workerName,
                           args  = constrargs ++ workerArgs,
                           body  = JBlock stmts}
 
        defs        = [{-lClass,-} worker]
           
    stio ([JComment ((nicer sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
         JComment (nicer sym.typ g),
         JComment (nicer x g)] ++ defs)
topFun _ _ = error "topFun: no function"


returnTau sigma = (fst • U.returnType) (Sigma.rho sigma)
sigmaTau f (ForAll [] (RhoTau [] ty)) = f ty
sigmaTau f (ForAll [] rhofun) = sigmaTau f (ForAll [] (U.tauRho rhofun))
sigmaTau f _ = Nothing
-- 
--- enumeration constants for the native interface kind
data NIKind = NIOp | NINew | NIMethod | NIMember | NICast | NINewArray | NIStatic
derive Eq NIKind
 
{--
    determine kind of java expression to generate, based on the item information
  -}
niKind "new"      = NINew
niKind #^\W+$#    = NIOp
niKind #^\w+$#    = NIMethod
niKind #^\.\w+$#  = NIMember
niKind #^\(.+\)$# = NICast
niKind #.+\[\]$#  = NINewArray
niKind _          = NIStatic
 
niArr s = strhead s (length s - 2)
 
niSpecial ty
     | Just _ <- U.isUnit ty      = true
     | Just _ <- U.isMaybe ty     = true
     | Just _ <- U.isException ty = true
     | Just _ <- U.isIO ty        = true
     | Just x <- U.isList ty      = true
     | otherwise = false
 
{--
  * check native method
  -}
methClass (sym@SymV {nativ = Just item, pur=true, typ})
     | Just (_, tau) <- U.isIO (returnTau typ) = do
         g <- getST
         U.error sym.pos (msgdoc ("contradictory declaration, " ++ nice sym.name g
             ++ " cannot be pure and have a return type of " ++ nicer (returnTau typ) g))
         stio []
     | Just _ <- U.isUnit (returnTau typ) = do
         U.error sym.pos (msgdoc ("void " ++ item ++ "(...) cannot be a pure function"))
         stio []
     | (_, [sig]) <- U.returnType typ.rho,
       Just _ <- sigmaTau U.isUnit sig = do
         U.error sym.pos (msgdoc (item ++ "() cannot be a pure function"))
         stio []
methClass (sym@SymV {nativ = Just item, pur=false, typ})
     | Nothing <- U.isIO (returnTau typ) = do
         g <- getST
         U.error sym.pos (msgdoc (nice sym.name g
             ++ " has an illegal return type for a method that is not pure,"
             ++ " perhaps  " ++ nicer (sttyp (returnTau typ)) g
             ++ "  would work"))
         stio []
     where
         sttyp tau
             | [s] <- keys (U.freeTauTVars [] Nil tau) = TApp (TApp st (tv s)) tau
             | otherwise = TApp (TApp st (tv "s")) tau
             where
                 st   = TCon {pos=sym.pos, name = TName pPreludeBase "ST"}
                 tv s = TVar {pos=sym.pos, var = s, kind = KType}
 
methClass (sym@SymV {nativ = Just item, pur, typ}) = do
         let
             nik = niKind item
         ok1 <- argsOk nik atys
         ok2 <- retOk  nik rty
         g <- getST
         si <- symInfo sym
         if ok1 && ok2 then return (methCode g sym si) else stio []
     where
         (rty, atys) = U.returnType typ.rho
         isMBU tau | Just x <- U.isMaybe tau, Just _ <- U.isUnit x = true
                   | Just x <- U.isException tau = isMBU x
                   | Just (_, x) <- U.isIO tau = isMBU x
                   -- Just _ <- U.isUnit tau = true
                   | otherwise             = false
         validIOtype tau | Just (_, x) <- U.isIO tau = case U.isUnit x of
                                                         Just _ -> true
                                                         _ -> validXtype x
                         | otherwise = validXtype tau
         validXtype tau  | Just x <- U.isException tau = case U.isUnit x of
                                                         Just _ -> true
                                                         _ -> validMBtype x
                         | otherwise = validMBtype tau
         validMBtype tau | Just x <- U.isMaybe tau = not (niSpecial x)
                         | Just x <- U.isList  tau = not (niSpecial x)
                         | otherwise = not (niSpecial tau)
         validCaftype tau | Just (_, x) <- U.isIO tau = validMBtype x
                          | otherwise = validMBtype tau
         validNIArg sigma | maybe true (const false) (sigmaTau Just sigma) = do
             g <- getST
             U.error sym.pos (msgdoc (nice sigma g ++ " is not valid for native method arguments"))
             stio false
         validNIArg sigma = do
             g <- getST
             let tau = maybe undefined id (sigmaTau Just sigma)
                 xio = isJust (U.isIO tau) || isJust (U.isException tau)
             if isMBU tau || isJust (U.isUnit tau)
                 then do
                     U.error sym.pos (msgdoc ("type  " ++ nice tau g
                         ++ "  is illegal for a native function argument,"
                         ++ " () may only appear to indicate an empty argument list."))
                     stio false
                 else if xio
                     then do
                         U.warn sym.pos (msgdoc (nice sym g ++ "  has an argument of type  "
                             ++ nice sigma g))
                         U.hint sym.pos (msgdoc ("Exception, ST and IO types have a special meaning"
                             ++ " in the native interface. "
                             ++ "Using them in argument position is most likely wrong."))
                         stio true
                     else stio true
         retOk _ tau | isMBU tau = do
             U.error sym.pos (msgdoc "The construct  Maybe ()  makes no sense in a native return type.")
             stio false
         retOk _ tau | not (validIOtype tau) = do
             U.error sym.pos (msgdoc "Illegal nesting of IO, ST, Exception, Maybe and () in the return type.")
             stio false
         retOk NIStatic tau | null atys, not (validCaftype tau) = do
             U.error sym.pos (msgdoc "A static member may not be void and it certainly throws no exceptions.")
             stio false
         retOk NIMember tau | not (validCaftype tau) = do
             U.error sym.pos (msgdoc "An instance member may not be void and it certainly throws no exceptions.")
             stio false
         retOk _ _ = stio true
         argsOk NIOp [x]   = validNIArg x
         argsOk NIOp [x,y] = liftM2 (&&) (validNIArg x) (validNIArg y)
         argsOk NIOp _ = do
             g <- getST
             U.error sym.pos (msgdoc ("Java operator " ++ nice sym.name g ++ " demands 1 or 2 operands."))
             stio false
         argsOk kind [] | kind `elem` [NINew, NIMethod, NICast] = do
             g <- getST
             U.error sym.pos (msgdoc ("Illegal type for " ++ nice sym.name g ++ ", must be function type"))
             stio false
         argsOk NICast [x]
             | Nothing <- sigmaTau U.isUnit x = stio true
         argsOk NICast _ = do
             U.error sym.pos (msgdoc "A java type cast must have exactly one argument which may not be ()")
             stio false
         argsOk NIMember (this:xs)
           | length xs > 0 = do
                 U.error sym.pos (msgdoc ("Getter for " ++ item ++ " cannot have more than 1 argument."))
                 stio false
           | otherwise = do
             g <- getST
             let sjt = sigmaJT g this
             let javatype = case sigmaTau Just this of
                    Just tau | Nativ{} <- tauJT g tau = true
                    _ -> false
             if javatype
                 then if maybe true (const false) (isPrimitive sjt)
                     then stio true
                     else do
                         U.error sym.pos (msgdoc ("Cannot get instance member " ++ item
                             ++ " from primitive"))
                         stio false
                 else do
                     U.error sym.pos (msgdoc ("Cannot get instance member " ++ item
                             ++ " from non-native object"))
                     stio false
         argsOk NIMethod (this:xs) = do
             g <- getST
             let sjt = sigmaJT g this
             let javatype = case sigmaTau Just this of
                    Just tau | Nativ{} <- tauJT g tau = true
                    _ -> false
             if javatype
                 then if maybe true (const false) (isPrimitive sjt)
                     then do
                         oks <- mapSt validNIArg xs
                         stio (and oks)
                     else do
                         U.error sym.pos (msgdoc ("Cannot invoke instance method " ++ item
                             ++ " on primitive type"))
                         stio false
                 else do
                     U.error sym.pos (msgdoc ("Cannot invoke instance method " ++ item
                             ++ " on non native type"))
                     stio false
         argsOk NINewArray xs | length xs > 1 = do
             U.error sym.pos (text "Array must have only one argument.")
             stio false
         argsOk kind [x] | kind != NIMethod, Just _ <- sigmaTau U.isUnit x  = stio true
         argsOk _ xs = do
             oks <- mapSt validNIArg xs
             stio (and oks)
methClass _  = undefined


--- Tells if a native symbol is wrapped 
wrapped (sym@SymV {nativ = Just item}) = niSpecial rty
     where
         (rty, _) = U.returnType sym.typ.rho
wrapped SymV {} = false
wrapped SymD {} = false
wrapped _ = error "wrapped: no symv"
-- 
-- {--
--  * Tell if a native function must be called through it's wrapper.
--  *
--  * Plain types and Maybe types can be called directly
--  -}
wrappedOnly (sym@SymV {nativ = Just item}) = niSpecial rty && isNothing (U.isMaybe rty)
    where
        (rty, _) = U.returnType sym.typ.rho
wrappedOnly sym = error "wrappedOnly - no native function"
-- 
-- 
--- returns a binding for a direct call of a native method
nativeCall g (sym@SymV {nativ = Just item}) abinds = newBind g bsig (call jrty args)
    where
        taus = [ tau | Just tau <- map (sigmaTau Just) sigmas ]
        brty = baserty rty
        bsig = ForAll [] (RhoTau [] brty)
        args | [tau] <- taus, Just _ <- U.isUnit tau = []   -- no arguments
             | otherwise = zipWith (argEx g)  abinds taus
        bjt = tauJT g brty
        jrty = strict  bjt
        -- retmode = maxStrict jrty         
        (rty, sigmas) = U.returnType sym.typ.rho
        argEx g bind tau
             | Just x <- U.isMaybe tau = JQC checknothing (JAtom "null") (justm1 x).jex
             | otherwise = sbind.jex
             where
                 sbind = primitiveBind  bind
                 checknothing = JBin con "==" (JAtom "0")
                 con = JInvoke (JExMem sbind.jex "_constructor" []) []
                 justm1 x = adaptSigma g  Bind{stype = nicer x g, 
                                 ftype = ForAll [] (RhoTau [] x), 
                                 jtype = Lazy Something,            -- i.e. Object 
                                 jex   = m1ex}
                 m1ex = JExMem just "mem1" []
                 just = JInvoke (JExMem sbind.jex "_Just" []) []
        baserty r
             | Just (_, x) <- U.isIO r   = baserty x
             | Just x <- U.isException r = baserty x
             | Just x <- U.isMaybe r     = baserty x
             | Just _ <- U.isUnit r      = r
             | otherwise                 = r
        call jrty args = case niKind item of
             NIOp -> case args of
                 [a,b] -> JBin a item b
                 [a]   -> JUnop item a
                 _     -> JAtom "null"           -- error was flagged before
             NINew -> JNew jrty args
             NICast -> case args of
                 [a] -> JInvoke (JAtom item) args    -- was: JCast (Ref (JName "" item) []) a
                 _   -> JAtom "null"
             NIMethod -> case args of
                 (a:as) -> case item of
                     "clone" -> JCast jrty (JInvoke (JExMem a item []) as) -- due to java brain damage
                     _ -> JInvoke (JExMem a item []) as
                 _ -> JAtom "null"
             NIMember -> case args of
                 [a] -> (JExMem a (tail item) [])
                 _ -> JAtom "null"
             NINewArray -> JNewArray  (Ref (JName "" (niArr item)) []) (head args)
             NIStatic -> case sigmas of
                 (_:_) -> JInvoke (JAtom item) args
                 _ -> JAtom item
nativeCall g sym abinds = error ("nativeCall: no function " 
    ++ show sym.pos.first.line
    ++ ", " ++ nicer sym g)
-- 
wrapCode g jreturn rtau (sym@SymV {nativ = Just item}) abinds
    | Just (stau, atau) <- U.isIO rtau = let
            -- sjt = tauJT g stau           -- type #1 for parameterization of ST s a
            ajt     = tauJT g atau          -- return type of the ST action
            ssig    = ForAll [] (RhoTau [] stau)
            mktup x = JReturn x -- (JInvoke (JStMem (JName "Prelude.tTuple2" "mk") [ajt, sjt])
            rbody   = wrapCode g mktup atau sym abinds
            -- tuple   = atau  -- TApp (TApp (TCon {pos=sym.pos, name = TName pPrelude "(,)"}) atau) stau
            -- frho    = RhoFun [] ssig (RhoTau [] atau)   -- s -> a
            -- tjt     = tauJT g tuple
            -- fjt     = rhoJT g frho
            ret     = jreturn fun -- (JNew jtFun [mkST])
            fun     = JNewClass lambda [] [rMethod]
            lambda  = jtFunc 1
            rMethod = JMethod {attr = attrs [JFinal, JPublic], gargs=[],
                                jtype = autoboxed ajt, name = "eval",
                                args = [(attrFinal, ssig, Something, "_state")],
                                body = JBlock rbody}
        in [ret]
    | Just mtau <- U.isException rtau = let
            -- mjt = tauJT g mtau
            -- xjt = tauJT g (TCon {pos = sym.pos, name = TName pPreludeBase "JException"})
            right x = jreturn (JInvoke (JStMem (JName (base ++ ".TEither.DRight") "mk")
                                                [])
                                        [x])
            left    = jreturn (JInvoke (JStMem (JName (base ++ ".TEither.DLeft")  "mk")
                                                [])
                                        [JAtom "ex"])
 
            code    = wrapCode g right mtau sym abinds
            try     = JBlockX "try" code
            catch   = JBlockX "catch (Exception ex)" [left]
        in [try, catch]
    | Just atau <- U.isMaybe rtau = let
            -- ajt    = tauJT g atau
            -- bind   = nativeCall g sym abinds
            mkmb   = {- case isPrimitive ajt of
                 Just prim ->
                     JInvoke (JStMem (JName base ("_" ++ prim++ "ToMaybe")) []) [bind.jex]
                 Nothing   -> -}
                     JInvoke (JStMem (JName base "_toMaybe") []) [bind.jex]
         in [jreturn mkmb]
    | Just atau <- U.isList rtau = let
            ajt    = tauJT g atau
            -- bind   = nativeCall g sym abinds
            mklst  = case isPrimitive ajt of
                 Just _  -> bind.jex
                 Nothing -> JInvoke (JStMem (JName base "_toList") []) [bind.jex]
         in [jreturn mklst]
     | Just _ <- U.isUnit rtau = let
            -- bind   = nativeCall g sym abinds
            unit   = JStMem (JName (base ++ ".TUnit") "Unit") []
         in [JEx bind.jex, jreturn unit]
     | otherwise = [jreturn (strictBind bind).jex]
     where
        bind   = nativeCall g sym abinds
        base = "PreludeBase"        
wrapCode g jreturn rtau sym abinds = error "wrapCode: no SymV"
 
 
{--
    code for native functions and/or members
  -}
methCode :: Global -> Symbol -> SymInfo -> [JDecl]
methCode g (sym@SymV {nativ = Just item}) si = [
        JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment item] ++
                (if arity > 0 then defs else [member])
    where
        rjt         = tauJT g rty
        rArgs       = evalArgDef attrFinal si.argSigs argNames
        wArgs       = argDefs attrFinal si argNames
        bnds        = sym.typ.bound
        name        = U.javaName g sym.name                        -- X.foo
        -- fname       = {-U.fName-} name                                 -- X.Ffoo
        ftargs      = targs sym.typ                                -- <a,b,c>
        -- ftype       = (Ref (fname) ftargs)                         -- Ffoo<a,b,c>
        -- dftype      = defining ftype
        args        = if haswrapper then wArgs else rArgs
        haswrapper  = arity > 0 && wrapped sym || (not (null bnds))
        -- callWrapper = (toBoxed bndWrapper).jex
        -- bndWrapper  = bndWcode invWrapper
        -- invWrapper  = JInvoke (JX.static name)
        jreturn     = if arity > 0 then JReturn else JEx
        bndWcode  x = newBind g (ForAll [] (RhoTau [] rty))  x
 
        wcode       = if wrapped sym
                        then wrapCode g jreturn rty sym (map (instArg g) args)
                        else let
                                bind = nativeCall g sym (map (instArg g) args)
                            in [jreturn bind.jex]
        wrappers    = if haswrapper then [{- inst, -} wrapper] else [{-inst-}]
        wrapper     = JMethod {attr = attrs [JPublic, JStatic, JFinal],
                                 gargs = ftargs, jtype = si.returnJT, name = name.base,
                                 args = wArgs, body = JBlock wcode}
        defs        = wrappers
        unex  [(JEx x)] = (strictBind (bndWcode x)).jex
        unex  _ = error "unex: need list with 1 ex"
        member = JMember {attr = attrs [JPublic, JStatic, JFinal],
                          jtype = rjt,
                          name = (U.javaName g sym.name).base,
                          init = Just (unex wcode)}
 
        (rty, atys) = U.returnType sym.typ.rho
        arity       = length atys
 
methCode g sym _ = Prelude.error ("line " ++ show sym.pos.first.line 
                    ++ ": can not compile " ++ nice sym g)
         
 
{--
    > compiling symbol action 
    
    run @action@ with @symbol@ in the current compiling environment
    -}
compiling sym action = do
    -- g <- getST
    changeST Global.{genEnv <- (sym:)}
    r <- action
    changeST Global.{genEnv <- tail}
    stio r
 
{--
    - invokes 'genLambda' to generate code for a function
    - wraps the code in a while statement for tail calling functions
    -}
genFunction (sym@SymV {expr = Just ex}) rmode args binds = do
        -- g <- getST
        if not (RTailRec `member` sym.rkind) -- if (sym.rkind `band` T.rkTail) == 0
            then genLambda rmode ex args binds
            else do
                let
                    fargs = [ (attrFinal, sig, jt, nm ++ "f") | (_,sig,jt,nm) <- args ]
                    decls = [ JMember { attr = attrFinal,
                                         jtype = jt,
                                         name = nm ++ "f",
                                         init = Just (JAtom nm)} | (_,sig,jt,nm) <- args ]
                    stmts = map JLocal decls
                code <- genLambda rmode ex fargs binds
                stio [JCond "tailrecursion: while" (JAtom "true") (stmts ++ code)]
                 
genFunction sym rmode args binds = error "genFunction: no function"
 

{--
  * Code for outer lambdas.
  *
  * Set's up a 'Binding' for the corresponding method argument and
  * 'match'es its pattern against it with the enclosed expression as continuation.
  -}
genLambda rm (Lam {pat, ex}) ((arg@(_, _, _, s)) : args) binds = do
    g <- getST
    ps <- T.patternStrictness pat
    let komplett = T.patsComplete g [pat]
        badguard = T.openCaseWhen g ex
        assert = isNothing komplett
         -- mustthrow = not assert && isNothing badguard
        margs = map JAtom [show ((last g.genEnv).name.nice g),
                                                 show (getpos pat)] ++ [JAtom s]
        -- construct new NoMatch("Module.foo", 42, arg$1)
        jthrow = [JThrow (JNew (Ref (JName "frege.runtime" "NoMatch") []) margs)]
 
    (_, code) <- match assert pat (adaptArg g arg ps)
                            (genLambda rm ex args) binds
    case komplett of
         Just p -> do
             U.warn (getpos pat) (msgdoc ("function pattern is refutable, "
                             ++ "consider adding a case for  "
                             ++ nice p g))
             stio (code ++ jthrow)
         _ -> case badguard of
             Just (Left x) -> do
                 U.warn (getpos x) (msgdoc ("guard (" ++ nice x g ++ ") may evaluate to false."))
                 stio (code ++ jthrow)
             Just (Right p) -> do
                 U.warn (getpos p) (msgdoc ("pattern guard (" ++ nice p g ++ ") may fail to match."))
                 stio (code ++ jthrow)
             Nothing -> stio code
 
 
genLambda rm x [] binds
    | Lam {pat} <- x = do
        g <- getST
        U.fatal (getpos x) (text ("genLambda: argument for " ++ nice pat g ++ " missing"))
    | otherwise = genStmts rm x binds
 
genLambda _ x _ _ = do
    g <- getST
    U.fatal (getpos x) (text ("genLambda: bad expression: " ++ nice x g))

genStmts, genCaseStmt :: JType -> Expr -> Tree Symbol Binding -> StG [JStmt] 
{--
  * The code for case statements can and will be optimized in various ways.
 
  * First, if the case expression is of the form @Con x1 x2 ... xn@, we can avoid
  * actual construction of the value if all the patterns are of
  * the form @Con p1 p2 ... pn@ or @_@ or @v@ where v is not used on the right hand side.
  * Indeed, every definition of a function with multiple arguments and more than one
  * alternative
  * > fun p1a p1b p1c = alt1
  * > fun p2a p2b p2c = alt2
  * > ...
  * results in code like
  * > \_a\_b\_c -> case (_a, _b, _c) of
  * >    (p1a, p1b, p1c)  -> alt1
  * >    (p2a, p2b, p2c)  -> alt2
  * >    ...
  * so naive implementation would cause an extra tuple construction on every function
  * call - this tuple would be created just to get deconstructed right away.
  *
  * Second, if we know that the set of patterns covers all possibilities, we
  * can avoid if-statements on the last alternative. In addition, we do not need
  * to arrange for the case that the pattern is not matched.
  * Therefore, we have a sophisticated algorithm to find this out, see 'T.patsComplete'
  *
  * The generated java code looks like this:
  * >  // compute case expression if needed
  * >  if (p1a matches) {
  * >    if (p1b matches) {
  * >        if (p1c matches) {
  * >            code for alternative1
  * >  }}} // fall through to next alternative
  * >  if (p2a matches) {
  * >        ... like above ...
  * >  }
  * >  ... yet more alternatives ....
  * >  throw new NoMatch("xy.fr", 345, case expression)
  -}
genCaseStmt rm (x@Case {ckind,ex=cex,alts=calts}) binds = do
         g <- getST
     -- case Con a b c  ... avoid actual creation of value unless a pattern is not
     -- itself a constructor application or a variable that is not referenced in its scope
         capp <- constrApp cex                      -- Just (Con, args) if this is Con a1 a2 ... an
         pats <- foldSt conUVarAlt true calts        -- true if all patterns are Con _ or _
         stri <- patternStrictness (head calts).pat -- strsig of 1st pattern
         -- rmex <- patternRMode (head calts).pat
         bcex <- genExpression false (if stri.isStrict then strict else lazy) cex binds              -- code for ordinary expression
         let makeBexs                                -- binds for cex or constr args
                 | pats, Just (con, xs) <- capp = case stri of
                         S ss -> mapSt exStr (zip xs (ss ++ allLazy))
                         U    -> mapSt exStr (zip xs allLazy)
                 | otherwise = stio [bcex]
         bexs <- makeBexs
         let con = if pats then maybe Nothing (Just • fst) capp else Nothing      -- constructor in case ex, if any
             complete
                 | T.caseOtherwise g x = Nothing         -- case true of true -> ...
                 | otherwise = T.patsComplete g (map CAlt.pat ralts)
             -- ralts are the alternatives that have no guard that could fail
             -- only the patterns of those alts are considered in deciding
             -- whether to throw exceptions or not
             -- walts are the alternatives that have an open case when
             (walts, ralts) = partitioned (isJust • T.openCaseWhen g • CAlt.ex) calts
             -- We will give a hint as to which guard is most likely
             -- causing trouble. If the patterns would be complete if there were
             -- no guards, then it is most likely the guard on an otherwise irrefutable
             -- pattern, if there is none, we assume it is the guard of the last alternative
             -- that has a guard.
             badguard = case T.patsComplete g (map CAlt.pat calts) of -- would it be complete
                 Just _  -> Nothing       -- case could not be made safe by adding guards
                 Nothing -> case filter (not • T.patternRefutable g • CAlt.pat) walts of
                     walt:_ -> T.openCaseWhen g walt.ex
                     []     -> case reverse walts of
                         walt:_ -> T.openCaseWhen g walt.ex
                         []     -> Nothing
 
             comment = sComment ("case  " ++ nice cex g ++ "  ... "
                         ++ (if ckind == CWhen then "(guard)" else ""))
             throw binds
                 | ckind == CWhen  = stio []                     -- guards always fall through
                 | Nothing <- con,
                   [bex1] <- binds = throwEx (strictBind  bex1)
                 | otherwise       = throwEx (strictBind  bcex)      -- construct case ex for throw
             throwEx arg
                 | isJust complete, Just (Left x) <- badguard = do
                     when (ckind != CNoWarn) do
                         U.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                     stio (jthrow arg)
                 | isJust complete, Just (Right p) <- badguard = do
                     when (ckind != CNoWarn) do
                         U.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))
 
                     stio (jthrow arg)
                 | Just p <- complete = do
                     when (ckind != CNoWarn) do
                         U.warn (last calts).pat.getpos (msgdoc ("pattern match is not exhaustive, "
                                 ++ "consider adding a case for  "
                                 ++ nicer p g))
                     stio (jthrow arg)
                 | otherwise = stio []                   -- no throw neeeded
 
             throwargs exb = map JAtom [show ((Prelude.last g.genEnv).name.nice g),
                                                 show (getpos x)] ++ [Binding.jex exb]
             jthrow exb = [JThrow (JNew (Ref (JName "frege.runtime" "NoMatch") []) (throwargs exb))]
 
         (nbexs, code) <- genAlts complete binds [] con bexs calts    -- make alternatives
         jthrow <- throw nbexs                               -- make throw statement
         stio (comment : concat (reverse (jthrow:code)))
 
     where
         genAlts complete binds codes con bexs ((calt@CAlt {pat, ex}):alts) = do
             g <- getST
             let last = finalAlt g calt || null alts
             -- when = T.openCaseWhen g ex
                 noif = last && isNothing complete
                 poss = map (getpos • CAlt.pat)  alts
                 unreachable p = U.warn p (text "equation or case alternative cannot be reached.")
             (codes, nbexs) <- genAlt noif binds codes con bexs calt
             if last
                 then do
                     when (ckind != CNoWarn) do
                         foreach poss unreachable
                     stio (nbexs, codes)
                 else genAlts complete binds codes con nbexs alts
         genAlts complete binds codes con bexs alts = error "genAlts: null alts"
 
         genAlt noif binds codes mbcon bexs (alt@CAlt {pat,ex})
             | Nothing  <- mbcon = do
                 g <- getST
                 (nbex, code) <- match noif pat (head bexs) (genStmts rm ex) binds
                 stio ((altComm g:code):codes, [nbex])
             | Just con <- mbcon = do
                 g <- getST
                 stri <- patternStrictness pat
                 case pat of
                     PCon {qname} -> do
                         sym <- U.findD qname
                         if sym.sid == Symbol.sid con then do
                                 let nbexs = case stri of
                                         S ss -> zipWith (bexStr g) bexs (ss ++ allLazy)
                                         _    -> bexs
                                 code <- matchCon noif pat con nbexs (genStmts rm ex) binds
                                 g <- getST
                                 stio ((altComm g:code):codes, nbexs)
                             else do
                                 U.warn (getpos pat) (text "case alternative will never be taken")
                                 stio ([]:codes, bexs)
                     _  -> do
                         g <- getST
                         -- uvar <- conUVarAlt true alt
                         -- if uvar then do
                         code <- genStmts rm ex binds
                         stio ((altComm g:code):codes, bexs)
             | otherwise = undefined
             where
                 altComm g = sComment ("... of  " ++ nice pat g ++ " -> " ++ nicer ex g)
 
 
         exStr  (ex, stri)
             | Strictness.isStrict stri = genExpression false strict  ex binds
             | otherwise                = genExpression false lazy    ex binds
         bexStr g bind stri
             | Strictness.isStrict stri = strictBind bind
             | otherwise = bind
             -- check if an expression is a constructor application
         constrApp (ex@App _ _ _) = case map fst (U.flatx ex) of
             Con {name}:xs -> do
                 sym <- U.findD name
                 if length sym.flds == length xs
                     then stio (Just (sym, xs))
                     else stio Nothing            -- for example:  case (,) a of mktuple -> mktuple b
             _ -> stio Nothing
         constrApp _ = stio Nothing      -- for example: let a = 1 in Just a
         -- check if a pattern is a constructor application or an unused variable
         conUVarAlt false _ = stio false
         conUVarAlt true (CAlt {pat = PCon {pos}}) = stio true
         conUVarAlt true (CAlt {pat = PVar {var,uid}, ex}) = do
             sym  <- U.findV (Local uid var)
             refs <- T.references [sym.sid] ex
             stio (refs == 0) 
         conUVarAlt _ _ = stio false
         -- check if there could match anything else after this alternative has matched
         finalAlt g (CAlt {pat,ex})
             | T.patternRefutable g pat = false
             | Just _ <- T.openCaseWhen g ex = false
             | otherwise = true
genCaseStmt rm nocase binds = error "genCaseStmt: no case"
 
{--
  * [usage] @genStmt rkind expression bindings@
  * [returns] A list of statements where the last one is a @return@
  *           or a @continue@ for a tailcall or a @throw@ from an
  *           incomplete case statement
  * This is called for return expressions only.
  -}
genStmts rm (x@Case {ckind,ex=cex,alts=calts}) binds = genCaseStmt rm x binds
 
genStmts rm (x@Let {env, ex}) binds = do
     case env of
         [k] -> do
             symv <- U.findV k
             case symv.expr of
                 Just vx
                     | symv.depth == 0,
                       symv.strsig.isStrict,
                       RSimple `member` symv.rkind,
                       RhoTau [] t <- symv.typ.rho = genStmts rm (cas vx) binds
                     where
                         cas vx = Case CWhen vx [alt] x.typ
                         alt = CAlt {ex, pat = PVar symv.pos symv.name.uid symv.name.base}
                 _ -> genLet rm x binds
         _ -> genLet rm x binds
 
genStmts rm (x@Let {env,ex}) binds = genLet rm x binds
 
genStmts rm (x@(Ifte c t e _)) binds {-| not (T.isSimple x) -} = do
         g <- getST
         cbnd <- genExpression false strict c binds
         tstm <- genStmts rm t binds
         estm <- genStmts rm e binds
         stio [sComment (nicer x g), 
            JCond "if" (strictBind cbnd).jex tstm, 
            JBlockX "else" estm]
 
 
genStmts rm ex binds
     {- | T.isSimple ex -} = do                                -- return or tailcall
         g   <- getST
         case ex of
             App _ _ _
                 | Vbl {name}:args <- map fst (U.flatx ex),
                   Just (sym@SymV {sid}) <- name.findit g,
                   sid == (head (g.genEnv)).sid,
                   length args == sym.depth = do
                        si <- symInfo sym
                        abinds   <- sequence (zipWith genEx si.argJTs args)
                        let assigns = zipWith JAssign (map JAtom argNames) (map Binding.jex abinds)
                            argNames = drop (fold (+) 0 (map Symbol.depth (tail g.genEnv))) GenJava7.argNames
                            comment = sComment ("tailcall  " ++ nicer ex g)
                        stio (comment:assigns ++ [JEx (JAtom "continue tailrecursion")])
                 where
                     genEx tt aex = genExpr false tt aex binds
             _ = do
                 bnd <- genExpr true rm ex binds
                 stio [sComment ("return " ++ show rm ++ "  " ++ nicer ex g),
                         sComment (show bnd),
                         JReturn bnd.jex]
 
-- {- genStmts rm ex binds = do
--         g <- getST
--         stio [JError ("code for " ++ nicer ex g)] -}
--
genLet :: JType -> Expr -> Tree Symbol Binding -> StG [JStmt] 
genLet rm (x@Let {env,ex}) binds = do
         g <- getST
         syms <- mapSt U.findV env
         (nbinds, stmtss) <- foldSt localdef (binds, []) syms
         stmts <- genStmts rm ex nbinds
         stio (comment g : ((map JLocal • concat • reverse) stmtss ++ stmts))
     where
         comment g = sComment (nicer x g)
         localdef (binds, codes) sym = do
             g <- getST
             let jt = sigmaJT g (Symbol.typ sym)
             let isClass = sym.depth > 0 -- && not (null sym.typ.bound)
                 mode = if isClass       then strict
                         else if RValue `member` Symbol.rkind sym  
                                 then strict else lazy
                 fjt  = jt -- if isClass then Lambda else jt
                 bjt  = mode fjt
                 name = (U.javaName g sym.name).base
                 bind = Bind (nicer sym.typ g) sym.typ bjt (JAtom name)
                 nbinds = insert binds sym bind
             code <- symCode nbinds sym
             stio (nbinds, code:codes)
genLet _ ex binds = do
     g <- getST
     U.fatal (getpos ex) (text("genLet: not a let  " ++ nice ex g))
 
 
impliesG g (Ctx _ d t1 _) (Ctx _ c t2 _) = U.isSuper c g d && sameTau t1 t2
 
envCtxs g = [ ctx | s <- reverse (Global.genEnv g),
                                     not (null (Symbol.typ s).bound),
                                     ctx <- (Symbol.typ s).rho.context ]
 
resolveConstraint pos (ctx@Ctx {cname, tau}) = do
         g <- getST
         -- ctx <- TC.reducedCtx ctx
         U.logmsg TRACEG (U.tauPos tau) (text (U.nicerctx [ctx] g))
         if make then makeCtx else findCtx
     where
         tauflat = tau.flat
         tcon  = head tauflat {- case head tauflat of
             TFun _ _ -> TCon {pos = Position.null, name = TName pPreludeBase "->"}  -- functions
             con      -> con -}
             
         -- targs = tail tauflat
         make | TCon {name} <- tcon = true
              | otherwise = false
 
         findCtx | Meta tv <- tau, tv.isFlexi = do
                         g <- getST
                         U.fatal pos (text ("unknwon context: " ++ nice cname g ++ " " ++ nice tau g))
                         stio (JAtom "null")
                 | otherwise = do
             g <- getST
             let
                 ctxsnms = zip (envCtxs g) ctxNames
                 implies = impliesG g
             U.logmsg TRACEG pos (text ("findCtx: looking for  " ++ nice cname g ++ " " ++ nice tau g))
             U.logmsg TRACEG pos (text ("findCtx: we have  " ++ U.nicectx (envCtxs g) g))
             let ok = [ name | (ctx1, name) <- ctxsnms, ctx1 `implies` ctx]
             U.logmsg TRACEG pos (text ("findCtx: ok= " ++ show ok))
             if (null ok)
                 then U.fatal pos (text ("Cant find context for " ++ nice cname g ++ " " ++ nice tau g))
                 else stio ((JAtom • head) ok)
         makeCtx  = do
             csym <- U.findC cname
             case tcon of
                 TCon {name} -> case filter ((name ==) • fst) csym.insts of
                     (_,iname):_ -> do
                         inst <- U.findI iname
                         g <- getST
                         let crho = RhoTau [] tau
                             csig = ForAll [] crho
                         U.logmsg TRACEG pos (text ("makeCtx: unify " ++ nice inst.typ g ++ "  with  "
                                 ++ nice csig g))
 
                         let tree = U.unifySigma g inst.typ csig
                         rho  <-  U.substRho tree inst.typ.rho
                         -- rhojt <- rhoJT rho
                         U.logmsg TRACEG pos (text ("makeCtx substituted: " ++ nice rho g))
                         subctx <- mapSt TC.reducedCtx  rho.context
                         args <- mapSt (resolveConstraint pos) subctx
                         let jiname = U.javaName g inst.name
                             -- jrho   = rhoJT g rho
                             -- jitargs0 = [ RhoTau [] t
                             --                 | v <- inst.typ.bound, t <- (tree.lookupS v).toList]
                         -- jitjts     <- mapSt rhoJT jitargs
                         let jit    = Ref jiname []              -- jitjts
                             jex    = if null args
                                 then JStMem (U.memberOf jiname "it") [] 
                                 else JNew jit args
                         U.logmsg TRACEG pos (text ("makeCtx: " ++ showJex jex))
                         stio jex
                     [] -> do
                         g <- getST
                         U.fatal pos (text ("makeCtx: instance " ++ nice cname g ++ " " ++ nice tau g ++ " not found."))
                 other -> do
                     g <- getST
                     U.fatal pos (text ("makeCtx: head is " ++ nice other g))
 
instSymDirect :: Position -> Symbol -> Sigma -> StG (Binding)
instSymDirect pos sym sigma = do
    g <- getST
    U.logmsg TRACEG pos (text ("instSymDirect: "
                             ++ nice sym g ++ "::" ++ nice sym.typ g
                             ++ " at " ++ nice sigma g))
 
    let inst = U.sigmaInst g sym.typ sigma
        -- gargs = mapSt (tauJT g) inst
    
    U.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    
    let -- jt    = sigmaJT g sigma
        str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
        model = newBind g sigma (JAtom "instSymDirect")
    strho    <- U.substRho (U.unifySigma g sym.typ sigma) str
    U.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    contexts <- mapSt  TC.reducedCtx  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts
 
    case sym of
        SymD {name=MName tynm _, flds} | null ctxs = do
            symt <- U.findT tynm
            if symt.enum
                then stio model.{jex = (JX.static (workerMethod g sym))}
                else if symt.newt
                    then do
                        sym <- U.findV (VName pPreludeBase "id")
                        instSymDirect pos sym sigma
                    else stio model.{jex = JX.static (workerMethod g sym)}
        SymV {name = Local {}, expr = Just _} = U.fatal sym.pos (text ("instSymDirect: " ++ nicer sym g))
        SymV {name, depth, rkind}
            | null ctxs = do
                let wm   = workerMethod g sym
                stio model.{jex = JX.static wm}
            | otherwise = do
                let instx = (JX.invoke ctxs • JX.static)
                                  (workerMethod g sym)
                stio model.{jex = instx}
        other -> U.fatal pos (text ("Can't instSymDirect " ++ nice sym g))
-- 
{--
  * instantiate a symbol at a given type
  -}
instSym :: Position -> Symbol -> Sigma -> StG Binding
instSym pos sym sigma = do
    g <- getST
    U.logmsg TRACEG pos (text ("instSym: "
                             ++ nice sym g ++ "::" ++ nice sym.typ g
                             ++ " at " ++ nice sigma g))
 
    let inst = U.sigmaInst g sym.typ sigma
 
 
    -- let gargs = map (tauJT g) inst
    U.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    let rstate = if sym.{rkind?} then sym.rkind else RState.singleton RValue
    let wjt    = returnType rstate (sigmaJT g sym.typ)
        model  = newBind g sigma (JAtom "instSym")
 
    let str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
    strho    <- U.substRho (U.unifySigma g sym.typ sigma) str
    U.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    contexts <- mapSt  TC.reducedCtx  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts
 
    let (_, ss) = U.returnType sym.typ.rho
 
    case sym of
         SymD {name=MName tynm _, flds} | null ctxs = do
             let mkOrEnum = JX.static (workerMethod g sym)
             symt <- U.findT tynm
             if symt.enum
                 then stio model.{jtype = jtInt, jex = mkOrEnum}
                 else if symt.newt
                     then do
                         sym <- U.findV (VName pPreludeBase "id")
                         instSym pos sym sigma
                     else if length flds == 0
                             then do
                                 let jx = {- JX.invoke [] -} mkOrEnum
                                     bind = model.{jtype=wjt, jex = jx}
                                 stio bind
                             else reqLam sym 
         SymV {name = MName clas m, depth, rkind} 
            | Just (SymC {tau}) <- clas.findit g = do
                 g <- getST
                 U.logmsg TRACEG pos (text ("instSym: " ++ m ++ " depth=" ++
                         show depth))
                 let inst   = JInvoke get (tail ctxs)
                     get    = JX.jexmem  (head ctxs) (latinF ++ mangled m)
                     mode   = if depth > 0
                                 then strict         -- function
                                 else lazy           -- by def in abstractFun
                     bind   = model.{jtype = mode wjt, jex = inst}
                 U.logmsg TRACEG pos (text ("instSym: " ++ show bind))                        
                 stio bind
         SymV {name, depth = 0, rkind} -> do
                 let
                     -- mode = jtRmode wjt
                     item = JX.static (workerMethod g sym)
                     func | null ctxs = item
                          | otherwise = JX.invoke ctxs item
                     bind = model.{jex = func, jtype = wjt}
                 stio bind
         SymV {name, depth, rkind} = do
             bind <- reqLam sym
             if null ctxs then return bind
                 else return bind.{jex <- JX.invoke ctxs}
             -- | Just wc <- wrapperClass g sym = do
             --     let instx = (JX.invoke ctxs • JX.static) (wrapperInstance g sym)
             --     stio (Bind RBoxed sigma jt instx)
             -- | null ctxs = reqLam sym -- do
                 -- let wm   = wrapperInstance g sym
                 -- stio (Bind RBoxed sigma jt (JX.static wm))
         other -> U.fatal pos (text ("Can't instSym " ++ nice sym g))
 
 
apply :: Position -> Binding -> Binding -> StG Binding
apply pos x b = do
    g <- getST
    U.logmsg TRACEG pos
         (text("apply: " ++ show x ++ "  to:  " ++ show b))
    stio x.{jtype=Applicable, 
                jex=JInvoke (JX.jexmem x.jex "apply") [b.jex]}

--- genExpression returnexpression f expr binds
--- Generate java code for expression.
--- The target java type is determined by @expr@ and modified with @f@ 
genExpression :: Bool -> (JType -> JType) -> Expr -> Tree Symbol Binding -> StG Binding
genExpression ret stri x binds = do
    g <- getST
    let nt = sigmaJT g (unJust x.typ) 
    genExpr ret (stri nt) x binds
 
{--
  * [usage] @genExpr rflag rmode expression binds@
  * [return] a binding that computes the frege expression in the desired 'RMode'
  * If the @rflag@ is true, special handling occurs for lazy calls: The arguments
  * of that tailcall are computed according to the strictness information of the
  * called function instead of all lazy. This is an optimization appropriate for
  * tail calls.
  -}
genExpr :: Bool -> JType -> Expr -> Tree Symbol Binding -> StG Binding
genExpr _ rm (Vbl {pos, name, typ = Just sigma}) binds
     | Local{} <- name = do
        g <- getST
        sym <- U.findV name
        case lookup binds sym of
             Just b = stio (adapt b rm)
             Nothing | Just _ <- sym.expr 
                 = instSym pos sym sigma
             Nothing -> do
                 g <- getST
                 U.error pos (msgdoc ("genExpr: " ++ nice sym g ++ " not bound"))
                 -- let sjt = sigmaJT g sigma
                 stio (newBind g sym.typ (JAtom ("UNBOUND." ++ name.base)))
     | otherwise = do
        g <- getST
        sym <- U.findV name
        bind <- instSym pos sym sigma
        let mbind = adapt bind rm
        U.logmsg TRACEG pos (msgdoc ("genExpr: got=" 
            ++ show bind
            ++ ", mode=" ++ show rm
            ++ ", return=" ++ show mbind)) 
        stio mbind
 
genExpr rflg rm (app@App a b (Just sigma)) binds = do
        g <- getST
        let flat  = map fst (U.flatx app)
            fun   = head flat
            args  = tail flat
        genApp fun args
    where
        pos = getpos app
        anys = repeat (Lazy Something)
        !isLazy = !(isStrictJT rm)
        lazyFun false jt  = jt
        lazyFun true  jt  = lazy jt
        genArgEx arm aex = genExpr false arm aex binds
        remaining call rargs 
            | null rargs = do
                    g <- getST
                    stio (adapt call rm)
            | otherwise  = do
                    g <- getST
                    rbinds <- sequence (zipWith genArgEx anys rargs)
                    r <- foldSt (apply pos) (call `adapt` Applicable) rbinds
                    stio (coerce g rm r.{ftype=sigma})
        coerce :: Global -> JType -> Binding -> Binding
        coerce g target  bind = adapt  bind.{stype = nicer bind.ftype g} target                    
        genApp (con@Con {pos, name, typ = Just csigma}) args = do
            g <- getST
            sym <- U.findD name
            si <- symInfo sym
            let a = length sym.flds
                -- asigs = map ConField.typ sym.flds
            if length args < a
                then genAnon con args          -- partial application
                else do
                    symt <- U.findT name.tynm
                    if symt.product && symt.newt
                        then do
                            genExpr rflg rm (head args) binds
                            -- b <- genExpr rflg rm (head args) binds
                            -- stio (coerce g rm b.{ftype=sigma})
                        else do
                            let 
                                !struct = any (ConField.strict) sym.flds
                                !sjt    = sigmaJT g sigma
                                !aargs  = take a args
                                !rargs  = drop a args
                                !ajts   = map (lazyFun isLazy) si.argJTs
                            abinds <- sequence (zipWith genArgEx ajts aargs)
                            
                            -- if there are any strict fields in the constructed value
                            -- and we need to be lazy, we must use the
                            -- conf.apply(...) form to be able to pass the arguments
                            -- lazily, except if the arguments are such that they can be
                            -- passed to the constructor.
                            -- If there are no strict fields, the arguments are demanded 
                            -- all lazy anyways, hence we can use the direct form, no matter
                            -- if it is required lazy or not. 
                            if struct && isLazy && 
                                    -- true if any binding would need conversion
                                    not (and (zipWith 
                                                isA (map Binding.jtype abinds) 
                                                si.argJTs)) 
                                then do
                                    dbind <- instSym pos sym csigma
                                    let jx = JX.xmem "apply" dbind.jex
                                        call = (newBind g sigma 
                                            (JInvoke jx (map Binding.jex abinds))).{jtype = lazy sjt}
                                    remaining call rargs
                                else do
                                    dbind <- instSymDirect pos sym csigma
                                    let jx = dbind.jex
                                        call = newBind g sigma 
                                            (JInvoke jx (map Binding.jex abinds))
                                    remaining call rargs
 
        genApp (vbl@Vbl {pos, name, typ = Just vsigma}) args = do
            g     <- getST
            sym   <- U.findV name
            let d = ari sym
            if d < 1 || d > length args
                then genAnon vbl args
                else case sym.name of
                    MName cname _
                        | Just (SymC {sid}) <- cname.findit g = genAnon vbl args
                    noclassmember -> case sym.nativ of
                        Just _    -> do
                                cenum <- isConstructorEnum sym vsigma
                                if cenum && length args == 1
                                     then genExpr rflg rm (head args) binds
                                     else genNative sym 
                        nonnative -> if isLazy && rflg && (RSafeTC `member` sym.rkind)
                                       then genExpr rflg (strict rm)  app binds
                                       else genDirect sym
          where
            isConstructorEnum (SymV {name=VName pp1 "constructor"})
                (ForAll [] (RhoFun []
                    (ForAll [] (RhoTau [] (TCon {name})))
                    (RhoTau [] (TCon {name=TName pp2 "Int"}))
                )) | pp1 == pPreludeBase, pp2 == pPreludeBase = do
                    symt <- U.findT name
                    stio symt.enum
            isConstructorEnum _ _ = stio false
            ari (sym@SymV {nativ=Just _}) = U.arity sym
            ari sym                       = sym.depth
            !tailcall   = rflg && isLazy
            
            genNative sym = do
                let !acall  = isLazy && not tailcall
                    !wcall  = not acall && (wrappedOnly sym || not (null sym.typ.bound))
                    atau    = fst (U.returnType (Symbol.typ sym).rho)
                    !depth      = ari sym
                    !aargs      = take depth args
                    !rargs      = drop depth args
                if acall || wcall then genDirect sym
                else do
                    g <- getST
                    si <- symInfo sym
                    abinds <- sequence (zipWith genArgEx si.argJTs aargs)
                    let call 
                            | wrapped sym = case wrapCode g JEx atau sym abinds of
                                    (JEx ex:_) -> Bind (nicer sigma g) sigma si.returnJT ex
                                    _ -> error "unexpected wrapCode result"
                            | otherwise = nativeCall g sym abinds
                    remaining call rargs
            genDirect :: Symbol -> StG Binding
            genDirect sym = do
                g <- getST
                si <- symInfo sym
                --          lazy type   returnflag      safe TC     
                --          false       false           false       strict
                --          false       false           true        strict
                --          false       true            false       MUST NOT HAPPEN*)
                --          false       true            true        strict
                --          true        false           false       lazy
                --          true        false           true        lazy
                --          true        true            false       lazy
                --          true        true            true        strict
                --
                -- *) Because in that case, we would use apply(...) to get a Delayed
                -- which would have to be forced immediatedly, which makes no sense
                when (not isLazy && rflg && not (RSafeTC `member` sym.rkind)
                        -- do not warn for CAFs
                        && all ((>0) . Symbol.depth) g.genEnv) do
                    U.hint pos (text ("deep recursion possible due to application of " 
                        ++ nicer sym g ++ " " ++ show sym.rkind
                        ++ " in strict context."))
                let callLazy = isLazy && not (rflg && (RSafeTC `member` sym.rkind))
                case lookup binds sym of
                    Just (b@Bind{jtype=Lambda})
                        | callLazy  = genStraight callLazy sym si b.{jex <- JX.xmem "apply"}
                        | otherwise = genStraight callLazy sym si b.{jex <- JX.xmem (workNameSI si)}
                    Just b -> genAnon vbl args  -- lambda bound function
                    Nothing
                        | callLazy = do
                            bcall <- instSym pos sym vsigma
                            genStraight callLazy sym si bcall.{jex <- JX.xmem "apply"}
                        | otherwise  = do
                            bcall <- instSymDirect pos sym vsigma
                            genStraight callLazy sym si bcall
            genStraight :: Bool -> Symbol -> SymInfo -> Binding -> StG Binding
            genStraight callLazy sym si vbind = do
                g <- getST
--                     U.logmsg TRACEG sym.pos (text("genStraight: " ++ nice sym g ++ " as " ++ nice vbind g))
--                     U.logmsg TRACEG sym.pos (anno vbind.jex)

                let jx = vbind.jex
                    (ctxs, static) = case jx of         -- be sure to collect context args
                        JInvoke x xs  -> (xs, x)
                        x             -> ([], x)
                    aew = case static of
                        JExMem {name} -> Just name      -- name of worker method, may be 
                                                        -- "apply", "eval" or "work"
                        _             -> Nothing
                    !rev = if aew == Just "eval" then reverse else id
                    !ajts = map (lazyFun callLazy) si.argJTs
                    !depth      = ari sym
                    !aargs      = take depth args
                    !rargs      = drop depth args

                abinds <- sequence (zipWith genArgEx ajts aargs)
                let call = Bind (nicer sigma g) sigma si.returnJT 
                            (JInvoke static (ctxs ++ map Binding.jex (rev abinds)))
                remaining call rargs
-- 
-- 
        genApp fun args = genAnon fun args
-- 
        genAnon fun args = do
            g      <-   getST
            fbind  <-   genExpr false Lambda fun binds
            abinds <-   sequence (zipWith genArgEx anys args) -- mapSt (flip (genExpression false lazy) binds) args
            appl   <-   foldSt (apply pos) fbind abinds
            let raw    = appl.{ftype=sigma}
            stio (coerce g rm raw)

genExpr _ rm (Con {pos, name, typ = Just sigma}) binds = do
    g    <- getST
    sym  <- U.findD name
    bind <- instSym pos sym sigma
    stio (adapt bind rm)
 
genExpr _ _ (Lit {kind, value, typ = Just sigma}) binds
    | kind != LRegex && kind != LBig = do
            g <- getST
            -- let jt = sigmaJT g sigma
            let v
                    | kind `elem` [LInt, LLong, LDouble, LFloat] = (#_#.matcher value).replaceAll ""
                    | otherwise = value
            stio (newBind g sigma  (JAtom v))

genExpr _ rm (x@Lit {kind,value,typ=Just sigma}) binds = do
        jname <- findConst x
        g <- getST
        -- let jt = sigmaJT g sigma
        let bind = newBind g sigma (JStMem jname [])  
        stio bind


genExpr rflg target (ifte@Ifte c t e (Just sigma)) binds 
    | not (isStrictJT target) = do
        g     <- getST
        -- let jt = sigmaJT g sigma
        cbind <- genExpr false (lazy Nativ{typ="boolean", typeargs=[]}) c binds
        tbind <- genExpr false target t binds
        ebind <- genExpr false target e binds
        let lif = VName pPreludeBase "lazyif"
        isym  <- U.findV lif
        ibind <- instSym (getpos ifte) isym isym.typ
        let rrho = U.tauRho sigma.rho
            rjt  = lazy (rhoJT g rrho)
 
        let jex = JInvoke   (JX.jexmem ibind.jex "apply")
                            (map Binding.jex [cbind, tbind, ebind])
        stio (adapt (newBind g sigma jex).{jtype=rjt} target)
 
genExpr _ target (ifte@Ifte c t e (Just sigma)) binds = do
     g <- getST
     cbind <- genExpr false Nativ{typ="boolean", typeargs=[]} c binds
     tbind <- genExpr false target      t binds
     ebind <- genExpr false target      e binds
     stio (adapt (newBind g sigma  
                            (JQC cbind.jex tbind.jex ebind.jex)) target)
 
genExpr _ rm (lam@Lam{}) binds = do
    g <- getST
    bind <- lambdaEx lam binds
    stio (adapt bind rm)
 
genExpr rflg rm ex binds = do
    g <- getST
    let ft = unJust (Expr.typ ex)
    U.error (getpos ex) (text ("Cannot genExpr: " ++ nicer ex g ++ " :: " ++ nicer ft g))
    return (newBind g TY.sigBool (JAtom "cannotgenexpression"))
