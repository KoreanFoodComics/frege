{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
    Java code generation for the frege compiler

    The generated code uses @java.lang.invoke.MethodHandle@s to represent functions
    and all data types are non-generic, so we make heavy use of casts.
 -}

{-
 * $Author$
 * $Revision$
 * $Date$
 * $Id$
 *
 -}

package frege.compiler.GenJava7 where

--- This is $Revision$
protected version = v "$Revision$" where
    v (m ~ #(\d+)#) | Just g <- m.group 1 = g.atoi
    v _ = 0

import frege.Prelude hiding(apply)
import frege.List (Tree, values, keys, each, insert, lookup, insertkv, updatekv)
import Data.List as DL(sortBy, partitioned)
import frege.IO   (URLClassLoader)

import frege.compiler.Data          as D
import frege.compiler.Utilities     as U() 
import frege.compiler.GenUtil       as GU except(group, break)
import frege.lib.PP()  -- (`<>`, `<+>`, `</>`, `<+/>`, `<~/>`, text, bracket)
import frege.compiler.Transform     as T(patternStrictness)
import frege.compiler.TCUtil        as TC(sameTau)
import frege.compiler.Typecheck     as TY(mainSigma, tc, tauString)
import frege.compiler.Classtools    as CT(getLambdas)
import frege.compiler.Import        as I(rebuildQN)


infixr 6 `<>`

--- Post condition of the code generation pass, always true
post = stio true

{--
    The mode of the java type assoicated with an expression
 -}
data RMode = RNative | RBoxed | RLazy
derive Eq   RMode
derive Ord  RMode
derive Show RMode

{--
    The mode of the return type of a function
--}
wmode n = case n `band` 7 of
    0 -> RLazy
    1 -> RBoxed
    2 -> RLazy
    4 -> RBoxed
    5 -> RBoxed
    6 -> RNative
    7 -> RNative
    _ -> RLazy
{--
    The mode of the return type of the functions MethodHandle
--}
rmode n = case n `band` 1 of
    0 -> RLazy
    _ -> RBoxed


{--
 * This data structure describes mode, java type and java expression associated with
 * some frege item. The task of code generation is to create, combine and
 * manipulate such bindings. Many code generating functions will take
 * a ('Tree' 'Symbol' 'Binding') of current bindings as last parameter.
 -}
data Binding = !Bind {mode :: RMode, ftype :: Sigma, jtype :: JType, jex :: JExpr}
instance Nice Binding where
    nice (Bind {mode, ftype, jtype, jex}) g = "Bind {" ++ show mode ++ ", "
                                            ++ ftype.nice g ++ ", "
                                            ++ showJty jtype ++  ", "
                                            ++ showJex jex ++ "}"

--- tell how strict this java type can get
maxStrict jt = case strict (boxed jt) of
    Nativ _ _  -> RNative
    _          -> RBoxed

--- bring a java expression to boxed mode
toBoxed (bind@Bind {mode=RNative, jex = JExMem jx "j"}) = bind.{mode = RBoxed, jtype <- boxed, jex = jx}
toBoxed (bind@Bind {mode=RNative, jtype = Nativ nx _}) = case boxed bind.jtype of
    bt@Ref jn t
        | jn == jtFun.jname        = bind.{mode=RBoxed, jtype = bt}
        | JName "" bx <- jn = bind.{mode=RBoxed, jtype = bt,
                                        jex = JInvoke (JStMem (JName bx "mk") t) [bind.jex]}
    other -> bind.{mode=RBoxed, jtype = other}      -- questionable whether this is right
toBoxed (bind@Bind {mode=RLazy}) = bind.{mode=RBoxed, jtype = bxtype, jex <- cast}
                        where bxtype = boxed bind.jtype
                              boxfun = JStMem (U.memberOf jtString.jname "box") []
                              cast
                                | Ref v [] <- bxtype,
                                  v == jtValue.jname
                                            = (JX.invoke [] • JX.xmem "_e")
                                | Ref v (_:_) <- bxtype,
                                  v == jtString.jname
                                            = JInvoke boxfun.{targs = bxtype.targs} • (:[]) • JX.invoke [] • JX.xmem "_e"
                                | otherwise = (JX.cast bxtype • JX.invoke [] • JX.xmem "_e")
toBoxed bind = bind

--- bring a java expression to desired strictness mode
toMode RLazy (bind@Bind {mode})
    | mode == RNative = toBoxed bind
    | otherwise = bind
toMode RBoxed bind = toBoxed bind
toMode RNative (bind@Bind {mode}) = case maxStrict bind.jtype of
    RBoxed -> toBoxed bind
    RNative
        | mode == RLazy  =  bind.{mode=RNative, jtype <- strict,
                                    jex = JExMem (toBoxed bind).jex "j"}
        | mode == RBoxed =  bind.{mode=RNative, jtype <- strict,
                                    jex = JExMem bind.jex "j"}
        | otherwise = bind
    _ -> error "toMode RNative: unexpected result from maxStrict"

{--
    make a binding strict
 -}
strictBind bind = toMode RNative bind
-- boxedBind  bind = toBoxed bind
notStrict (bind@Bind {mode=RNative}) = toBoxed bind
notStrict bind = bind
notLazy   (bind@Bind {mode=RLazy}) = toBoxed bind
notLazy   bind = bind

--- generate necessary casts so that java type accords to sigma type
coerce :: Binding -> StG Binding
coerce bind = do
    g   <- getST
    sigjt <- sigmaJT bind.ftype
    U.logmsg TRACEG Position.null (text ("coerce: " ++ nice bind g ++ " to " ++ showJty sigjt))
    U.logmsg TRACEG Position.null (anno bind.jex)
    -- if (bind.mode != RLazy && jtRmode bind.jtype == RLazy)
    -- then coerce (notLazy bind)
    -- else 
    if (bind.mode != jtRmode bind.jtype)
        then do 
            U.error Position.null (text  ("coerce: bind mode and mode of java type do not match: " ++ nice bind g))
            return bind
        else do
            let bjt = bind.jtype
                sjt = rmodeJt bind.mode sigjt
                fehler = do
                    U.error Position.null (text  ("Can't coerce " ++ showJty bind.jtype ++ "  to  " ++ showJty sjt))
                    stio bind
            case  bind.mode of
                RNative  | bjt == sjt = stio bind
                         | otherwise  = fehler
                RLazy    | bjt == sjt = stio bind
                         | bjt == lazy jtValue = stio (asType sigjt bind)
                         | otherwise  = fehler
                RBoxed -> case sjt of
                    Ref{} -> case bjt of
                        Ref{} | bjt.jname == sjt.jname,
                                sjt.targs == bjt.targs          = stio bind
                              | bjt.jname == jtValue.jname,
                                null sjt.targs                  = stio (cast sjt bind)
                              | bjt.jname == jtValue.jname,
                                sjt.jname == jtString.jname,
                                [boxed] <- sjt.targs            = stio (box sjt bind)
                        other -> fehler
                    other -> U.fatal Position.null (text  ("toBoxed " ++ nice bind.ftype g ++ " is " ++ showJty sjt ++ ", should be Ref"))
  where
    boxfun = JStMem (U.memberOf jtString.jname "box") []
    asType ta (bind@Bind{})   = bind.{jtype = lazy ta}
                                      -- jex = JInvoke asfun.{targs=[ta]} [bind.jex]}
    box  jt (bind@Bind{})     = (toBoxed bind).{
                                      jtype=jt,
                                      jex = JInvoke boxfun.{targs=jt.targs} [bind.jex]
                                 }
    cast jt (bind@Bind{mode}) = bind.{jtype=jtx, jex <- JCast jtc}
        where
            jtx = rmodeJt mode jt
            jtc | jtx.{targs?} = jtx.{targs=[]}
                | otherwise    = jtx

--- show a java expression
showJex jex | cheap jex = PP.pretty 1000 (anno jex)
            | otherwise = "complicated java expression"
--- show a java expression
showJty (Lazy t) = "Lazy<" ++ showJty t ++ ">"
showJty jty = PP.pretty 1000 (anno jty)


--- changes 'JName' of a 'Ref' so that it is suitable for the place where it is defined
defining (t@Ref {jname}) = t.{jname <- JName.{qual=""}}   --, targs <- map introduce-}
defining x = x
----- like defining, but suitable for type classes, TArgs will not extend Lazy
--definingTC (t@Ref {jname}) = t.{jname <- JName.{qual=""}}
--definingTC x = x
--
--introduce (TArg s) = TVbl s
--introduce t = t

--- the type constructor for 'Void'
-- voidTau = TCon {pos=0, name = TName pPreludeBase "Void"}
-- voidJT  = Ref (JName "" "Box") [Nativ "Void" []]


sigmaJT (ForAll _ rho)        = rhoJT rho
--subSigmaJT (ForAll [] rho)    = rhoJT rho
--subSigmaJT (ForAll bound rho) = do
--    let tree = Tree.fromList (zip bound (repeat voidTau))
--    rho <- U.substRho tree rho
--    rhoJT rho
rhoJT  (fun@RhoFun _ _ _) = stio jtFun {- do
        staus <- mapSt sigmaJT sigs
        rtau  <- tauJT tau
        stio (Ref (JName "" funN) (staus ++ [rtau]))
    where
        (tau, sigs) = U.returnType fun
        funN = "Fun" ++ show (length sigs) -}
rhoJT  (RhoTau {tau}) = tauJT tau

tauJT :: Tau -> StG JType

tauJT (app@TApp a b)
    | Just _ <- app.getFun = stio jtFun
    | otherwise = case app.flat of
        (TCon {pos,name}):rest -> taujtApp pos name rest
        other -> stio jtValue     -- we know nothing about it

tauJT  (TCon {pos, name}) = taujtApp pos name []

tauJT  (TVar {var}) = stio jtValue
tauJT  (Meta tv)    = stio jtValue

taujtApp pos qname rest = do
    sym   <- U.findT qname
    let arity   = length sym.typ.bound
    case sym of
        SymT {product=true, newt=true} -> do
            let sigmas = [ ConField.typ f | sym@SymD {flds} <- values sym.env, f <- flds ]

            -- the sigma is by Grammar.y in the form   ForAll [] (RhoTau [] tau)
            case sigmas of
                [] -> do
                    g <- getST
                    U.error pos (msgdoc (nice sym g ++ " has no fields"))
                    stio jtValue
                (s:_) -> rhoJT s.rho
        SymT {product,nativ,enum,pur}
            | Just s <- nativ = stio (boxed (Nativ s args))
            | enum            = stio jtInt
            | otherwise       = do g <- getST
                                   stio (Ref {jname = U.javaName g qname, targs = []})
            where args
                    | Just _  <- nativ,
                      not pur,
                      not (null sym.typ.bound) = take  (arity - 1) (repeat jtValue)
                    | otherwise = []
        other -> undefined   -- can not happen because catched in U.findT
--
--
--targ s = TArg {var = greek s}
--
--{--
-- * [usage] @prodArity g (SymT ....)@
-- * [returns] arity of first constructor of the type described by SymT
-- * [undefined] if the symbol does not describe a type that has constructors
-- -}
--prodArity g (SymT {env}) = length args where
--    (_, args) = U.returnType con1.typ.rho
--    con1 = head [ con | con@SymD {pos} <- values env ]
--prodArity g _ = error "ProdArity: no SymT"
--
--greek (s@#^[a-z]$#) = ctos (alphabet.charAt (ord (s.charAt 0) - ord 'a'))
--greek s = "Σ" ++ s
--alphabet = "αβγδεζηθιßκλμνξοπρςστυφχψωﬁﬂƒ"
--
--
numbers = (map show (iterate (1+) 1))
xxxNames xxx = zipWith (++) (repeat xxx) numbers
--- arg$1, arg$2, arg$3, ....
argNames = xxxNames "arg$"
--- ctx$1, ctx$2, ctx$3, ...
ctxNames = xxxNames "ctx$"
--- mem1, mem2, mem3 ...
memNames = xxxNames "mem"
--



--- get the mode a java type is in
jtRmode :: JType -> RMode
jtRmode (Lazy _) = RLazy
jtRmode (Nativ _ _) = RNative
jtRmode _ = RBoxed

--- bring a java type to desired mode
rmodeJt :: RMode -> JType -> JType
rmodeJt RBoxed  = boxed
rmodeJt RNative = strict
rmodeJt RLazy   = lazy


{--
    Check if a given java type is a primitive one.
    Return 'Nothing' if this is no primitive type
    or 'Just' /s/, where /s/ is a string like "int" that descirbes the type.
-}
isPrimitive (ref@Ref _ _) | n@Nativ _ _ <- strict ref = isPrimitive n
isPrimitive (Nativ (m ~ #^(byte|short|boolean|char|int|long|double|float)$#) _) = m.group 1
isPrimitive _ = Nothing

--- the main class name for this package
mainClass :: Global -> String
mainClass g = (g.thisPack.className g).base

--- the name of the interface that serves as namespace for this main class
constClass g = "Consts"

--- prefix for wrapper methods is ﬂ
flLigatur = "ﬂ"
--- prefix for method handles is ﬁ
fiLigatur = "ﬁ"
--- the name of the constant class is ĳ
ijLigatur = "ĳ"
--- prefix for class methods is ƒ
latinF    = "ƒ"


{--
    create a lazy method for the given symbol
-}
lazyMethod :: Symbol -> StG JDecl
lazyMethod sym | sym.{flds?} || sym.{rkind?} = do
        g <- getST
        let jname  = JX.static (workerMethod g sym)
            arity = if sym.{depth?} then sym.depth else length sym.flds
            isnative = sym.{nativ?} && isJust sym.nativ
            (rty, sigmas) = U.returnTypeN arity sym.typ.rho
            (rtau, _)     = U.returnType sym.typ.rho
        jrty    <- rhoJT rty
        argdefs <- argDef attrFinal Strictness.U sigmas (take arity argNames)
        wcode   <- if wrapped sym
                   then wrapCode JReturn rtau sym (map argBind argdefs)
                   else if isnative
                        then do
                                bind <- nativeCall sym (map argBind argdefs)
                                stio [JReturn bind.jex]
                        else stio []

        -- special support for native functions, call directly into native code
        let haswrapper  = arity > 0 && wrapped sym || (not (null sym.typ.bound))
        
        -- be sure to pass ctx1, ctx2, ....
        let ctxs = map JAtom (take (length sym.typ.rho.context) ctxNames)

        let args        = argdefs
            rm          = if sym.{flds?} then RBoxed else rmode sym.rkind
            wm          = if sym.{flds?} then RBoxed else wmode sym.rkind
            jtype
                | RLazy <- rm = lazy jrty
                | otherwise   = boxed jrty
            wtype       = case wm of
                RLazy   -> lazy jrty
                RBoxed  -> boxed jrty
                RNative -> strict jrty
            abinds
                | S ss <- sym.strsig = zipWith adaptArg argdefs (ss ++ allLazy)
                | otherwise          = map (notStrict • argBind) argdefs

            body = JBlock [(JReturn • bx • JX.invoke (ctxs ++ map Binding.jex abinds)) jname]
            rBody = if haswrapper then body -- JBlock [JReturn callWrapper]
                    else case wcode of
                            [JReturn x] = JBlock [JReturn (bx x)]
                            _ -> JBlock wcode
            bx jex = (toMode rm (Bind {mode = wm,
                                        ftype = ForAll [] rty,
                                        jtype = wtype, jex})).jex
            result = JMethod { attr = attrs [JFinal, JPublic],
                            gargs = [],
                            name = "eval",
                            jtype, args = reverse args,
                            body = if isnative then rBody else body }
        stio result
lazyMethod sym = error "lazyMeth: no SymV"

--- tells how many lazy functions go into one Lambda class.
--- *Important* This must be a power of 2!
fpC = 256
{--
    Prepare top level function for lazy usage.
    
    For every top level function, including native ones, there may be a
    Lambda object that one can pass to other functions if the need arises.
    
    The eval method of that object must invoke the actual function code.
    
    Since all eval() method signatures of functions with the same arity and the same
    list of constraints is the same, we can combine several functions in one
    class and one eval method that switches on a function id to do the right thing. 
    
    This helps to contain the class explosion problem - every function passed to
    a higher order function generates a class without that optimization.
    
    Given a toplevel symbol, we compute the arity
    and the the names of the constraints, and enter the symbol in the
    @Global.gen.lambdas tree. By the way, we assign every function a small
    index unique in its category.
    Finally, we generate a
    > final static public LambdaN funcf = new LambdaN(i);
    for unconstrained functions and
    > final static public LambdaN funcf(Constraint1 ctx1, Constraint2 ctx2) {
    >   return new Lambda2CC(i, ctx1, ctx2);
    > }
    for constrained ones. 
    -}
lazyDecl sym jname
    | SymV {name, depth, typ} <- sym, not name.isLocal = prep name depth         typ
    | SymD {name, typ} <- sym                          = prep name (U.arity sym) typ
    | otherwise = do
        g <- getST
        U.fatal sym.pos (text("prepareLazy: " ++ nicer sym g)) 
    where 
      prep :: QName -> Int -> Sigma -> StG JDecl
      prep name depth typ = do
        g <- getST
        let constr = map Context.cname typ.rho.context
            mrtyp  = Nativ ("frege.rt.Lam" ++ show depth) []
            key    = (depth, constr)
            lamid  n = lambdaName depth constr n 
            member n = JMember {
                        attr = attrTop, 
                        jtype = mrtyp, 
                        name  = JName.base jname, 
                        init  = Just (newfl n)}
            classTyp n = Ref {jname = JName (mainClass g) (lamid n), targs = []}
            args     = map JAtom (take (length constr) argNames)                         
            newfl n  = JNew (classTyp n) (JAtom (show (n `rem` fpC)):args) 
            method n = JMethod {
                        attr = attrTop, gargs = [],
                        jtype = mrtyp,
                        name = JName.base jname,
                        args = map  (uncurry (makeConstraintArg g)) (zip typ.rho.context argNames),
                        body = JBlock [JReturn (newfl n)]}
            result = if null constr then member else method
        case lookup g.gen.lambdas key of
            Just list -> do
                changeST Global.{gen <- GenSt.{lambdas <- updatekv key (sym:list)}}
                return (result (length list))
            Nothing -> do
                changeST Global.{gen <- GenSt.{lambdas <- insertkv key [sym]}}
                return (result 0)                         
        

lambdaName n constr i = "Lambda" ++ show n ++ cid ++ packed (replicate (length constr) 'C')
                        ++ hash
    where
        cid                = U.allAsciiBinders !! (i `quot` fpC)
        hash | null constr = ""
             | otherwise   = show conid
             where conid   = fold (\a \b -> a + a + unsigned (hashCode (QName.show b))) 0L constr
                   unsigned i = fromInt i `band` 0xffffffffL                          


--- emit all lazy definitions
emitLazy :: ((Int, [QName]), [Symbol]) -> StG [JDecl]
emitLazy ((n, constr), syms) = loop [] n constr (reverse syms) 0 where
    loop dcls n constr syms base
        | length syms <= fpC = do
            dcl <- emitLazyN n constr syms base
            return (dcl:dcls)
        | otherwise = do
            dcl <- emitLazyN n constr (take fpC syms) base
            loop (dcl:dcls) n constr (drop fpC syms) (base+fpC) 
--- emit a block of lazy definitions
emitLazyN n constr syms base = do
    g <- getST
    argdefs <- argDef attrFinal Strictness.U (replicate n TY.sigInt) (take n argNames)
    let cname        = lambdaName n constr base
        cltype       = Nativ cname []
        p0           = Position.null
        contexts     = [ Ctx p0 q TVar{pos=p0, var="a"} true | q <- constr ]
        indexargname = head GenJava7.argNames
        argNames     = tail GenJava7.argNames
        indexdef     = JMember { attr = attrFinal, 
                                jtype = strict jtInt,
                                name  = "index",
                                init = Nothing
                            }
        constraints  = map  (uncurry (makeConstraintDef g)) (zip contexts ctxNames)
        indexarg     = (attrFinal, TY.sigInt, strict jtInt, indexargname) 
        constrargs   = map  (uncurry (makeConstraintArg g)) (zip contexts argNames)
        initindex    = JAssign (JAtom indexdef.name) (JAtom indexargname)
        initctx      = take (length constraints)
                            (zipWith JAssign (map JAtom ctxNames) (map JAtom argNames))
        init         = JConstr { attr = attrs [JPublic], 
                                 jtype = cltype,
                                 args  = indexarg:constrargs, 
                                 body  = JBlock (initindex:initctx) }
        numbered   = zip syms (0 .. length syms)                                 
    
    stmts <- mapSt caseFor numbered
    
    let eval         = JMethod { attr = attrs [JFinal, JPublic], gargs = [],
                                 jtype = lazyVal,
                                 name  = "eval",
                                 args  = reverse argdefs,
                                 body  = JBlock [switch, bad] }
        -- jname  sym = JX.static (workerMethod g sym)
        switch = JCond "switch" (JAtom indexdef.name) stmts 
        bad    = JThrow (JNew (Nativ "java.lang.Error" []) [JAtom (show "bad function number " ++ " + index")])                            
    
    return JClass{
            attr = attrs [JFinal, JStatic, JPrivate],
            jtype = cltype,
            extend = Just (Nativ ("frege.rt.Lam" ++ show n) []),
            implement = [],
            defs = indexdef:constraints ++ [init,eval]
        }

caseFor (sym, n) = do 
    meth <- lazyMethod sym
    return JCase{jex = JAtom (show n), stmt = meth.body}
           
{--
    Construct a java name for a variable/method that
    holds or returns the lambda class for a given symbol.
    
    The names live in the _Consts_ subclass and are either
    static members (for function without constraints) or
    static methods that take the constraints for instantiation.
    
    For top level names we simply use the java name with an appended 
    latin "ƒ".
    
    For member names we use the hashkey of the @show qname@ so hopefully
    this will never generate the same key for 2 members of different
    types/instances/classes and never the same key for 2 functions
    in different classes. The mangled base name is included in every
    case.
    
    This way the java name generated depends only on the qualified name
    and remains constant.
-}
extFname :: Global -> Symbol -> JName
extFname g sym
    | VName p base <- qname,
      qname.our g               = mg (worker.base ++ latinF)
    | MName _ base <- qname,
      qname.our g               = mg ("m$" ++ ustr ++ mangled base)
    | VName _ base <- qname     = mx qname (worker.base ++ latinF)
    | MName tname base <- qname = mx tname ("m$" ++ ustr ++ mangled base)
    where qname = Symbol.name sym
          worker = workerMethod g sym
          hash  = hashCode qname.show
          ustr  = show (fromInt hash `band` 0xffffffffL)
          mg = U.memberOf (JName "" (constClass g))
          mx qn = U.memberOf ((U.javaName g qn).{base = constClass g})
extFname g sym = error ("extFname: bad symbol " ++ nicer sym g)

-- pure native hashCode :: String -> Int

{--
    Require that there be an instance of a Lambda suitable to call
    the symbol lazily at runtime and return a 'Binding' for that handle.
-}
reqLam :: Symbol -> StG Binding
reqLam sym = do
        g <- getST
        let jname = extFname g sym
        return Bind{mode=RBoxed, ftype=sym.typ, jtype=jtFun, jex=JX.static jname}

{--
    Generate the anonymous Lambdas for all symbols
--}
genAnonLams = do
        g <- getST
        let collectedenvs = g.thisTab : [ Symbol.env sy | sy <- values g.thisTab, 
                                            Symbol.{env?} sy,
                                            -- do not search type classes
                                            not (Symbol.{supers?} sy) ]
            collectedvars = [ v | env <- collectedenvs, v <- values env, 
                                            -- either SymV or SymD
                                            Symbol.{depth?} v && Symbol.depth v > 0
                                                || Symbol.{flds?} v && U.arity v > 0,
                                            -- not a newtype constructor
                                            not (T.newtypeCon v.name g),
                                            ]
    
        let jnames = map (extFname g) collectedvars
        mapSt (uncurry lazyDecl) (zip collectedvars jnames)
        


pass :: StG (String, Int)
pass = do
    g <- getST


    U.print "final public class "
    U.print (mainClass g)
    U.println " {"
    let vals = values g.thisTab

    let cClass = JMember {
            attr = attrTop,
            jtype = cType,
            name = ijLigatur, -- println ("final public static " ++ constClass g ++ "
            init = Just (JNew cType []) }
        cType = Ref (JName "" (constClass g)) []
    pp (anno cClass)

    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymT {sid} <- vals ])
        >>= ppSS
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymC {sid} <- vals ])
        >>= ppSS
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymI {sid} <- vals ])
        >>= ppSS
    mapSt (symCode Nil) (sortBy (comparing Symbol.name) [ s | s@SymV {sid} <- vals ])
        >>= ppSS

    -- anonymous lambdas
    -- now done within Consts: genAnonLams >>= mapM_ (pp • anno)

    -- constants
    makeConstants

    -- lazy lambda classes
    g <- getST
    foreach (each g.gen.lambdas) (emitLazy >=> sequence • map (pp • anno)) 

    let toMaybe | g.thisPack == pPreludeBase = [mkMaybe false, mkMaybe true] ++ primMaybes
                | otherwise = []
                where
                    primMaybes = map (uncurry primMaybe) (zip p1 p2)
                        where
                            p1 = map (flip Nativ []) ["boolean", "byte", "short", "char", "int", "long", "double", "float"]
                            p2 = map (flip Ref [] • JName "java.lang")
                                    ["Boolean", "Byte", "Short", "Character", "Integer", "Long", "Double", "Float"]
        {-
         * Code for the _toMaybe function(s)
         -}
        -- mbSigma  = ForAll ["a"] (RhoTau [] mbTau)
        -- mbTau    = TApp (TCon {pos=Position.null, name = TName pPreludeBase "Maybe"}) tvara
        tvara    = TVar {var = "a", pos=Position.null}

        mkMaybe boxd = toMaybeMethod
            where
                obj      = Ref (JName "" "Object") []
                -- boxeda   = if boxd then Ref (JName "" "Box") [] else jtValue
                toMaybeMethod = JMethod {attr = attrs [JUnchecked, JFinal, JPublic],
                                gargs = [],
                                jtype = Nativ "static" [],
                                name = "TMaybe _toMaybe",
                                args = [(attrFinal,
                                    ForAll [] (RhoTau [] tvara),
                                    if boxd then obj else lazy jtValue,
                                    "arg")],
                                body = JBlock [JReturn toMBex]}
                toMBex = JQC (JBin (JAtom "arg") "==" (JAtom "null"))
                            (JInvoke (JStMem (JName "TMaybe.DNothing" "mk") []) [])
                            (JInvoke (JStMem (JName "TMaybe.DJust"    "mk") []) [boxArg])
                boxArg = if boxd
                    then JInvoke (JStMem (JName "Box" "mk") []) [JAtom "arg"]
                    else JAtom "arg"
        -- create java code for primitive _toMaybe functions
        -- will be used whenever a native return type is Maybe x and x is a primitive type
        primMaybe prim ref = toMaybeMethod
            where
                primname = maybe "unsupported primitive type" id (isPrimitive prim)
                boxprim = boxed prim
                boxclass = case boxprim of
                    Ref x _ -> x
                    _ -> error "boxed prim must be Ref"
                toMaybeMethod = JMethod {
                        attr = attrs [JFinal, JPublic, JStatic],
                        gargs = [],
                        jtype = Ref (JName "" "TMaybe") [],
                        name = "_" ++ primname ++ "ToMaybe",
                        args = [(attrFinal, ForAll [] (RhoTau [] tvara), ref, "arg")],
                        body = JBlock [JReturn toMBex]}
                toMBex = JQC (JBin (JAtom "arg") "==" (JAtom "null"))
                            (JInvoke (JStMem (JName "TMaybe.DNothing" "mk") []) [])
                            (JInvoke (JStMem (JName "TMaybe.DJust" "mk")    []) [boxArg])
                boxArg = JInvoke (JStMem (U.memberOf boxclass "mk") []) [JAtom "arg"]

    invokeMain <- genMain
    ppSS [invokeMain, toMaybe]
    U.println "}"

    stio ("java7 class", 1)

-- print lists of lists of annotatable items
ppSS xss = foreach (concat xss) (pp • anno)

{--
    Find the 'D.JName' of a literal.
    If this literal does not have a name yet, it will be entered in the 'D.GenSt.consts'
    table.
-}
findConst (Lit {pos,kind,value})
    | kind == LBool = case value of
        "true" -> stio (JName "Box.Bool" "t")
        _      -> stio (JName "Box.Bool" "f")
    | otherwise  = do
        g <- getST
        case g.gen.consts.lookup (kind,value) of
            Just u
                | kind `elem` [LInt, LLong, LBig]
                            -> stio (JName ijLigatur (kinda kind ++ value))
                | otherwise -> stio (JName ijLigatur (kinda kind ++ show u))
            Nothing
                | kind `elem` [LInt, LLong, LBig] = do
                     changeST Global.{gen <- GenSt.{consts <- insertkv (kind, value) 0}}
                     stio (JName ijLigatur (kinda kind ++ value))
                | otherwise = do
                     u <- U.uniqid
                     changeST Global.{gen <- GenSt.{consts <- insertkv (kind, value) u}}
                     stio (JName ijLigatur (kinda kind ++ show u))

    where
        kinda LBool   = "bool"
        kinda LInt    = "int"
        kinda LRegex  = "rgx"
        kinda LString = "str"
        kinda LDouble = "dbl"
        kinda LFloat  = "flt"
        kinda LChar   = "chr"
        kinda LBig    = "big"
        kinda LLong   = "long"
findConst _ = error "findConst: no Lit"

makeConstants = do
        g <- getST
        lams   <- genAnonLams 
        consts <- mapSt genConst (keys g.gen.consts)
        let ccType = (Ref (JName "" (constClass g)) [])
            constclass = JClass   { attr = attrs [JPublic, JStatic],
                                    jtype = ccType,
                                    extend = Nothing,
                                    implement = [],
                                    defs = constructor:(lams ++ consts)}
            constructor = JConstr { attr = attrs [JPublic],
                                    jtype = ccType,
                                    args = [],
                                    body = JBlock []}
        pp (anno constclass)
        stio ()
    where
        genConst (kind,value) = do
            jname <- findConst Lit {pos=Position.null, typ = Nothing, kind, value}
            let lsigma = TY.litSigma kind
                numv = (#_#.matcher value).replaceAll ""
            bjt   <- sigmaJT lsigma
            let it = JMember { attr = attrs [JPublic, JFinal],
                               jtype = bjt, name = jname.base, init = Just bb.jex }
                ex = case kind of
                    LBig   -> JNew (Ref (JName "" "java.math.BigInteger") []) [JAtom (show numv)]
                    LRegex -> JInvoke
                                (JStMem (JName "java.util.regex.Pattern" "compile") [])
                                [JAtom value]
                    LInt      -> JAtom numv
                    LLong     -> JAtom numv
                    LDouble   -> JAtom numv
                    LFloat    -> JAtom numv
                    otherwise -> JAtom value

                nb = Bind RNative lsigma (strict bjt) ex
                bb = toBoxed nb
            stio it


genMain = do
    g <- getST
    case (VName g.thisPack "main").findit g of
        Just sym | sym.name.pack == g.thisPack = do         -- we have a main
            let -- tc n = TCon {pos=sym.pos, name = TName pPreludeBase n}
                tauSig tau = ForAll [] (RhoTau [] tau)
                sarr = TName (Pack.new "frege.prelude.Arrays") "StringArray"
                sarrTau = tauSig (TApp (TCon Position.null sarr) (tc "Immutable"))
            sarrJT <- sigmaJT sarrTau
            let args = [(attrFinal, sarrTau, strict sarrJT, "argv")]
            let st   = (tc "ST").name
                stpu = MName st "performUnsafe"
                toli = MName sarr "toList"
            vstpu <- U.findV stpu
            vtoli <- U.findV toli
            let avb = argBind (head args)
                slist = TApp (tc "[]") tauString
                sig1 = ForAll [] (RhoFun [] (sarrTau) (RhoTau [] slist))
            btoli <- instSymDirect sym.pos vtoli sig1
            let  apparg = JInvoke btoli.jex [avb.jex]
            bmain <- instSymDirect sym.pos sym mainSigma
            let applist = (JCast jtFun
                            • JX.invoke [] • JX.xmem "_e"
                            • JX.invoke [apparg]) bmain.jex
                iovoid = TApp (TApp (tc "ST") (tc "RealWorld")) (tc "()")
                sig2 = ForAll [] (RhoFun [] (tauSig iovoid) (RhoTau [] (tc "()")))
            bperf <- instSymDirect sym.pos vstpu sig2
            let appio = {- JCast jtFun -} (JInvoke bperf.jex [applist])
                -- appe  = JInvoke (JExMem appio "_e") []
                appe  = JInvoke (JStMem (JName "frege.RT" "fjMain") []) [appio]
                gettime s = JMember {attr = attrFinal, jtype = Nativ "long" [], name=s,
                            init = Just (JInvoke
                                (JStMem (JName "java.lang.System" "nanoTime") [])
                                [])}
                stmts = [ JLocal (gettime "t1"), JEx appe, JLocal (gettime "t2"), times ]
                times = JEx (JInvoke (JStMem (JName "java.lang.System.err" "println") [])
                                [ex1])
                ex1 = JBin (JAtom "\"runtime \"") "+" ex2
                ex2 = JBin ex3 "+" (JAtom "\" wallclock seconds.\"")
                ex3 = JBin ex4 "/" (JAtom "1e3")
                ex4 = JBin ex5 "/" (JAtom "1000000")
                ex5 = JBin ex6 "+" (JAtom "500000")
                ex6 = JBin (JAtom "t2") "-" (JAtom "t1")
                mMeth = JMethod {attr = attrs [JPublic, JStatic], gargs = [],
                            jtype = Nativ "void" [],        -- sure thing :)
                            name  = "main",
                            args, body = JBlock stmts }
            stio [mMeth]
        sonst -> stio []

--- the @constructor@ method
--- >final public int constructor() { return n; }
cMethod n = atomMethod "constructor" (Nativ "int" []) (show n)

--- the @_u@ method
--- >final public boolean _u() { return false; }
uMethod = atomMethod "_u" (Nativ "boolean" []) "false"

--- the @_v@ method
--- >final public Lazy<FV> _v() { return this; }
vMethod = atomMethod "_v" (lazy jtValue) "this"

--- the @_e@ method
--- >final public FV _e() { return this; }
eMethod = atomMethod "_e" jtValue "this"


{--
 * [usage] @atomMethod name type atom@
 * [returns] a 'JMethod' of the form @final public /type/ /name/() { return /atom/; }@
 -}
atomMethod s jt atom = JMethod {attr = attrs [JFinal, JPublic], gargs=[], jtype = jt,
                    name = s, args=[], body = JBlock [ JReturn (JAtom atom) ]}

----- returns @SuppressWarnings("unchecked") public final <x,y> T<x,y> coerce() { return (T<x,y>) this; }@
--coerceMethod typ = JMethod { attr = attrs [JUnchecked, JPublic, JFinal],
--                    gargs = JType.targs typ,
--                    jtype = typ,
--                    name = "coerce", args = [],
--                    body = JBlock [JReturn (JCast typ (JAtom "this"))]}
--
{--
 * [usage] @conGetter qname@
 * [return] the name of the method that gets the variant
 * [example] @conGetter (MName tname "Con")@ evaluates to @"_Con"@
 -}
conGetter (MName tname base) = "_" ++ mangled base
conGetter _ = error "conGetter: no member"


{--
 * [usage] @variantType g jtype symd@
 * [return] the type of the variant, i.e. @tMaybe.dJust<a>@, if jtype is the jt of the type
 -}
variantType :: Global -> JType -> Symbol -> JType
variantType g jtype symd = jtype.{jname = U.javaName g (Symbol.name symd)}


{--
  Code for data constructors

  - For nullary constructors, a subclass of @Val@ is derived that contains a singleton and
    an appropriate @mk@ method.
  - For non-strict constructors with arity > 0, a subclass of @Prod@/n/
    with a static @mk@ method is derived.
  - For strict constructors, the members are generated directly.
 -}
conCode symt cons (sym@SymD {flds, cid}) = do
    g <- getST
    symtjt <- sigmaJT (Symbol.typ symt)


    let jtype       = variantType g symtjt sym
        (_, argtys) = U.returnType sym.typ.rho
        struct      = sym.strsig.isStrict
    argjts  <- mapSt sigmaJT argtys
    funty   <- sigmaJT sym.typ
    -- wrapper <- if length flds == 0 
    --     then return (JComment "no wrapper") 
    --     else prepareLazy sym

    let djtype = defining jtype
        arity  = length flds
        comment = JComment (nice sym g)
        result = sumCon
        sumCon = JClass {attr = attrTop,
                            jtype = djtype, extend = ext, implement = imp, defs}
        !ext | arity == 0 = Just jtVal
             | struct     = Nothing
             | otherwise  = Just (Ref {jname=JName "" ("Prod" ++ show arity),
                                      targs=[]})
        imp = [symtjt]

        defs = [comment, constr, cMethod cid, make]
                 ++ wrapmk ++ single ++ getters ++ members
        single | arity == 0 = [JMember {attr = attrs [JFinal, JPrivate, JStatic],
                                        jtype = djtype,
                                        name = "single",
                                        init = Just (JX.new [] jtype)}]
               | otherwise = []
        wrapmk | struct, arity > 0 = [{- wrapper,-} uMethod, vMethod, eMethod]
               | arity == 0 = []
               | otherwise = [{-wrapper-}]



        !make | arity == 0 = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                    gargs = [], jtype = symtjt, name = "mk",
                                    args = [],
                                    body = JBlock [JReturn (JAtom "single")]}
              | struct     = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                    gargs = [], jtype = symtjt, name = "mk",
                                    args = structargs,
                                    body = JBlock [JReturn (JNew jtype args)]}
              | otherwise  = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                                    gargs = [], jtype = symtjt, name = "mk",
                                    args = constrargs,
                                    body = JBlock [JReturn (JNew jtype args)]}

        constrargs = [ (attrFinal, ty, lazy jt, n) |
                            (jt, (ty, n)) <- zip argjts (zip argtys argNames) ]
        args = take arity (map JAtom argNames)
        structargs = [ (attrFinal, ty, strict jt, n) |
                            (jt, (ty, n)) <- zip argjts (zip argtys argNames) ]
        -- rbinds = [ Bind RLazy sig jt (JAtom n) | (_,sig,jt,n) <- constrargs ]
        constr = JConstr {attr = attrs [JPrivate], jtype = djtype,
                            args = if struct then structargs else constrargs,
                            body = JBlock super}
        !super | arity == 0 = []
               | struct = take (length args) (zipWith JAssign
                                                    (map JAtom memNames)
                                                    (map JAtom argNames))
               | otherwise = [JEx (JInvoke (JAtom "super") args)]
        getters = -- if symt.product then [] else
                    atomMethod (conGetter sym.name) jtype "this" :
                    [ atomMethod (conGetter (Symbol.name con))
                                 (variantType g symtjt con) "null"
                         | con <- cons, Symbol.sid con != sym.sid ]  -- other constructors
        members | struct =  zipWith member argjts memNames
                | otherwise = []
        member jt name = JMember {attr = attrs [JFinal, JPublic],
                                    jtype = strict jt,
                                    name, init = Nothing}
    stio [result]
conCode symt cons nocon = error "conCode: no Con"
--
{--
 * Code for data types
 *
 * - Native types create a class @TName@ that acts as namespace for
 *   member definitions.
 * - Enumerations create a class @TName@ that contains final Box.Int DCon = Box.Int.mk(cid)
 * - Algebraic types create an interface @TName@ that extends @Val@
 *   implements @Lazy<FV>@ and contains
 *   an abstract method @DCon@ to get the variant associated with @DCon@.
 -}
symCode binds (sym@SymT {enum=true}) = do
    g <- getST
    let vals  = sortBy (comparing Symbol.name) (values sym.env)
        cons  = [ con | con@SymD {sid} <- vals ]                    -- constructors
        other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- non constructors

    subDefs <- mapSt (symCode binds) other

    let jtype = Ref {jname = U.javaName g sym.name, targs = []}     -- TName
        result = JClass {attr = attrTop, jtype,
                        extend = Nothing,
                        implement = [],
                        defs = (constr : conDefs) ++ concat subDefs}
        constr = JConstr { attr = attrs [JPrivate], jtype, args=[], body = JBlock []}
        conDefs = [ JMember {attr = attrTop,
                        jtype = jtInt,
                        name = mangled name.base,
                        init = Just (JX.invoke [JX.atom (show cid)]
                                                (JStMem (JName "Box.Int" "mk") [])
                                             )}
                      | SymD {name, cid} <- cons ]
    stio [JComment (nice sym g), result]


symCode binds (sym@SymT {product=true, newt=true}) = do
    g <- getST

    let vals = sortBy (comparing Symbol.name) (values sym.env)
        other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]      -- sub definitions

    subDefs <- mapSt (symCode binds) other

    let jtype  = Ref (U.javaName g sym.name) []
        defs   = concat subDefs
        result = JClass {attr = attrs [JAbstract, JPublic, JStatic], jtype,
                         extend = Nothing, implement = [], defs}
    stio [JComment (nice sym g), result]


symCode binds (sym@SymT {product=true}) = do                    -- product
    g <- getST

    let vals = sortBy (comparing Symbol.name) (values sym.env)
        other = [ sym | sym <- vals, not (Symbol.{flds?} sym)]
    subDefs <- mapSt (symCode binds) other
    symjt   <- sigmaJT sym.typ

    let jtype  = symjt.{jname = U.javaName g sym.name}
        symd   = head [ con | con@SymD {sid} <- vals ]            -- constructor
        (_, argtys) = U.returnType symd.typ.rho
        struct      = symd.strsig.isStrict
    funty      <- sigmaJT symd.typ
    ftypes     <- mapSt sigmaJT (map ConField.typ symd.flds)        -- field types
    argjts     <- mapSt sigmaJT argtys
    -- wrapper    <- prepareLazy symd
    let arity  = length symd.flds
        ext | struct     = jtVal                            -- extends FV/ProdN<...,...,...>
            | otherwise  = Ref {jname=JName "" ("Prod" ++ show arity), targs = []}
        imp        = [lazyVal]                              -- implements Lazy<Val>
        defs       = [comment, constr, -- cMethod symd.cid,
                        -- atomMethod "_v" jtype "this",
                        -- atomMethod "_e" jtype "this",
                        make] ++ members ++ concat subDefs
        comment    = JComment (nice symd g)
        constrargs = [ (attrFinal, ty, (lazy jt), n) |
                            ((ty, jt), n) <- zip (zip argtys argjts) argNames ]
        args       = take arity (map JAtom argNames)            -- arg1, arg2, arg3 ...
        structargs = map (\(a,b,c,d) -> (a,b, strict c, d)) constrargs
        -- rbinds = [ Bind RLazy sig jt (JAtom n) | (_,sig,jt,n) <- constrargs ]
        -- sargs = map (Binding.jex • strictBind) rbinds
        -- rargs = if struct then sargs else args
        constr = JConstr {attr = attrs [JPrivate], jtype = jtype,
                            args = if struct then structargs else constrargs,
                            body = JBlock super}
        super
            | struct = take (length args) (zipWith JAssign          -- m1 = arg1 ....
                                                    (map JAtom memNames)
                                                    (map JAtom argNames))
            | otherwise  = [(JEx • JX.invoke args • JX.atom) "super"]
        make    | struct     = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                        gargs = jtype.targs, jtype, name = "mk",
                        args = structargs,
                        body = JBlock [(JReturn • JX.new args) jtype]}
                | otherwise = JMethod {attr = attrs [JPublic, JFinal, JStatic],
                        gargs = jtype.targs, jtype, name = "mk",
                        args = constrargs,
                        body = JBlock [JReturn (JNew jtype args)]}
        members | struct = {- wrapper : -} zipWith member argjts memNames
                | otherwise = [{-wrapper-}]
        member jt name = JMember {attr = attrs [JFinal, JPublic],
                                    jtype = strict jt,
                                    name, init = Nothing}
        result = JClass {attr = attrTop, jtype,
                         extend = Just ext, implement = imp, defs}
    stio [JComment (nice sym g), result]

symCode binds (sym@SymT {nativ=Nothing}) = do                   -- sum type
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
        cons = [ con | con@SymD {sid} <- vals ]
        funs = [ sym | sym@SymV {sid} <- vals, not (Symbol.{flds?} sym)]
    funDefs <- mapSt (symCode binds) funs
    -- cafDefs <- mapSt (symCode binds) cafs
    conDefs <- mapSt (conCode sym cons) cons
    symjt   <- sigmaJT sym.typ
    let jtype = symjt.{jname = U.javaName g sym.name}
        getCons = [JMethod {attr = attrs [JPublic], gargs=[],
                            jtype = variantType g jtype con,
                            name = conGetter (Symbol.name con),
                            args = [], body = JEmpty}
            | con <- cons ]
        mClass | null funs = []
               | otherwise    = [JClass {attr = attrs [JPublic, JStatic, JFinal],
                                    jtype = Ref (JName "" "M") [],
                                    extend = Nothing, implement = [],
                                    defs = concat funDefs}]
        result = JInterface {attr = attrs [JPublic], jtype,
                            implement = [jtValue, lazyVal],
                            defs = getCons ++ concat conDefs ++ mClass}
    stio [JComment (nice sym g), result]

symCode binds (sym@SymT {sid, nativ = Just _}) = do                               -- nativ
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
    subDefs <- mapSt (symCode binds) vals
    let jtype = Ref {jname = U.javaName g sym.name, targs=[]}
        result = JClass {attr = attrTop,
                            jtype, extend = Nothing, implement = [],
                            defs = concat subDefs}
    stio [JComment (nice sym g), result]

{--
 * Code for type classes
 *
 * - interface @Cname@</a/> where /a/ is the class variable
 * - for each class method, an abstract method that returns a function (i.e. @frege.rt.MH@)
 * - name space @I@ for default function implementations
 -}
symCode binds (sym@SymC {sid}) = do           -- type class
    g <- getST
    let vals = sortBy (comparing Symbol.name) (values sym.env)
    abstrFuns <- mapSt (abstractFun sym) vals
    let ivals = filter (isJust • Symbol.expr) vals         -- default implementations
    implFuns <- mapSt (symCode binds) ivals
    -- taujt    <- tauJT sym.tau
    let jtype = Ref (U.javaName g sym.name) []
        -- jinterface = if sym.vkind == 0 then JInterface else JTCInterface
        superclasses = [ Ref (U.javaName g nm) [] | nm <- sym.supers ]
        implDef
            | null implFuns = []
            | otherwise = [JClass {attr = attrs [JPublic, JStatic],
                            jtype = Ref (JName "" "I") [],
                            extend = Nothing, implement = [], defs = concat implFuns}]
        result = JInterface (attrs [JPublic]) jtype superclasses (concat abstrFuns ++ implDef)
    stio [JComment (nice sym g), result]

{--
    Code for instances

    - interface @Cname@</a/> where /a/ is the class variable
    - for each class method, an abstract method that returns a function
    - name space for default functions (?)
    -}
symCode binds (sym@SymI {sid}) = do             -- instance definition
    g <- getST
    csym <- U.findC sym.clas

    let -- bnds    = sym.typ.bound
        classes = sym.clas:csym.supers
        -- the functions we must provide in the instance
        superMethods = [ m.name.base | c <- classes,
                                  SymC{env} <- QName.findit c g,
                                  m@SymV{}  <- values env ]
        -- links in type that point to instance members of this class and its superclasses
        -- The goal is to have (links to) implementations of all super class methods. 
        methods1 = case U.instTSym (Symbol.typ sym) g of
             Just (tsym@SymT {pos}) -> [ alias |
                               SymL {alias} <- values tsym.env, alias.{tynm?},    -- links
                               alias.base `elem` superMethods,           -- mentioning one of our methods
                               SymI {clas} <- QName.findit alias.tynm g, -- pointing to an instance
                               SymC {supers} <- QName.findit clas g,     -- of a class that is in our hierarchy
                               clas `elem` classes || any (`elem` classes) supers]
             _ -> error "unexpexted result from instTSym"
        methods2 = [ name | name  <- map Symbol.name (values sym.env), name `notElem` methods1 ]
        methods  = methods1 ++ methods2

    let vals = sortBy (comparing Symbol.name) (values sym.env)

    instFuns  <- mapSt (instFun csym sym) methods
    instImpls <- mapSt (symCode binds) vals
    symjt     <- sigmaJT sym.typ
    let constraints = map  (uncurry (makeConstraintDef g)) (zip sym.typ.rho.context ctxNames)
        constrargs  = map  (uncurry (makeConstraintArg g)) (zip sym.typ.rho.context argNames)


    let jtype = Ref (U.javaName g sym.name) []          -- jtargs
        etype = Ref (U.javaName g sym.clas) []          -- [instjt]
        constructor = JConstr {attr = attrs [JPublic],
                                jtype = jtype,  -- if csym.vkind > 0 then erased jtype else jtype,
                                args = constrargs,
                                body = JBlock (take (length constraints)
                                                (zipWith JAssign
                                                    (map JAtom ctxNames)
                                                    (map JAtom argNames)))}

        result = JClass {attr = attrs [JPublic, JFinal, JStatic], jtype,
                         extend = Nothing,
                         implement = [etype],
                         defs = (constructor : constraints)
                            -- singles
                            ++ concat instFuns
                            ++ concat instImpls}
    stio [JComment (nice sym g ++ " :: " ++ nice sym.typ g), result]

-- symCode binds (sym@SymV {}) = do
--        g <- getST
--        wrapper <- lazyMeth sym
--        stio [JComment (nice sym g ++ " :: " ++ nice sym.typ g), wrapper]

symCode _ (sym@SymL{}) = getST >>= stio • (:[]) • JComment • nice sym
symCode binds (sym@SymV {nativ = Just item}) = methClass sym



symCode binds (sym@SymV {expr = Just x})
    | sym.depth > 0 = do
        g <- getST
        trace
        funCode sym binds
    | otherwise     = do trace; cafCode sym binds
    where
        trace = do
            g <- getST
            U.logmsg TRACEG sym.pos (text ("compiling " ++ sym.nice g))


--- unimplemented items produce a comment and an error message
symCode binds sym = do
    g <- getST
    U.error sym.pos (text ("Can't generate code for " ++ nice sym g))
    stio [JComment (nice sym g)]

--- declare abstract class Member function

abstractFun symc (sym@SymV {sid}) = do
    g <- getST
    let classCtx = Ctx {pos=Position.null, cname = Symbol.name symc, tau = Symbol.tau symc, checked = false }
        ctxs = [ ctx | ctx <- sym.typ.rho.context,
                    not (TC.sameCtx ctx classCtx)]      -- filter out class context

    let constrformal = map (uncurry (makeConstraintArg g)) (zip ctxs ctxNames)
        cafMeth = {- null ctxs && -} sym.depth == 0
    -- sjt          <- sigmaJT funtyp
    let    result = JMethod {attr = attrs [JPublic],
                            gargs = [],       -- map targ (filter (!=tauvar) bnds),
                            jtype = if cafMeth then lazy jtValue else jtFun,    -- if symc.vkind > 0 then erasedObj sjt else sjt,
                            name = latinF ++ mangled sym.name.base,
                            args = constrformal,
                            body = JEmpty}
    stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]
abstractFun _ _ = undefined

{--
  >  class @Eq eq@
  >  instance `Eq_(,,,)` :: forall u v w x.(Eq v,Eq w,Eq x,Eq u) => (w,x,u,v)
  >  class member function `Eq.!=` :: forall eq.Eq eq => eq -> eq -> Bool
  >  instance member `Eq_(,,,).!=` :: forall a b c d.(Eq b,Eq c,Eq d,Eq a) => (c,d,a,b) -> (c,d,a,b) -> Bool
  Extra type variables and constraints in instance member must be retained.
  Therefore:
  1. rename all type variables in instance member type so that the type variables
  in the instance type and the instance member type are distinct
  2. unify class member type and instance member type, note what is bound to the class variable
  3. unify instance type and the result from previous step
  4. substitute it in instace member type
  5. reconstruct forall bound in instance member type
 -}
fakeInstSigma (symc@SymC{supers}) (symi@SymI{sid}) (sym@SymV{typ}) = do
    g <- getST
    let symjsb      = sym.typ.bound
        instjsb     = symi.typ.bound

    let newvars = [ TVar {pos=sym.pos, var} |
                        var <- U.allBinders,
                        var `notElem` instjsb,
                        var `notElem` symjsb ]
        tree1 = Tree.fromList (zip symjsb newvars)
    rho1 <- U.substRho tree1 sym.typ.rho
    U.logmsg TRACEG sym.pos (text ("renamed  " ++ nicer sym.typ g ++ "  to  " ++ nicer rho1 g))

    let classes = symc.name:symc.supers
        memc = head [ sym | c <- classes, sym <- ((MName c sym.name.base).findit g).toList ]
    symc <- U.findC memc.name.tynm
    let clas = symc.tau
        tree2 = U.unifySigma g memc.typ (ForAll [] rho1.{context=[]})
    U.logmsg TRACEG sym.pos (text ("unifySigma (" ++ nicer memc.typ g ++ ") "
            ++ "(" ++ nicer (ForAll [] rho1.{context=[]}) g ++ ")"
            ++ " = " ++ show [(v, nicer t g) | (v,t) <- tree2.each]))
    let itau    = unJust (tree2.lookupS clas.var)       -- member type MUST mention it, see Classes.fr
        sigma2a = ForAll [] (RhoTau [] itau)
        validSigma rho = ForAll (U.freeTVars [] rho) rho
        sigma2 = validSigma sigma2a.rho
    U.logmsg TRACEG sym.pos (text ("class var  " ++ clas.var
            ++ "  in  " ++ nicer memc.typ g
            ++ " corresponds to  " ++ nicer sigma2 g))

    let tree3 = U.unifySigma g sigma2 symi.typ
    rho4   <- U.substRho tree3 rho1

    let sigma4 = validSigma rho4      -- provide type variables
        bound  = filter (`elem` sigma4.bound) instjsb ++ filter (`notElem` instjsb) sigma4.bound
        sigma5 = ForAll bound rho4      -- binds in correct order
    U.logmsg TRACEG sym.pos (text ("fake type is  " ++ nicer sigma5 g))
    stio sym.{typ=sigma5}
fakeInstSigma _ _ _ = error "fakeInstSigma: bad args"

instFun :: Symbol -> Symbol -> QName -> StG [JDecl]
instFun symc symt mname = do
    g <- getST
    -- establish a fake type for instance member that matches the one of the instance
    -- cmem  <-  U.findV (MName (Symbol.name symc) (QName.base mname))
    sym   <-  U.findV mname
    sym   <-  fakeInstSigma symc symt sym

    -- let bndsV = sym.typ.bound
    --    bndsI = (Symbol.typ symt).bound
    let implies = impliesG g
        ctxs = [ ctx | ctx <- sym.typ.rho.context,
                       not (any (`implies` ctx) symt.typ.rho.context)]
        ourCtxNms = drop symt.typ.rho.context.length ctxNames   -- ctx3, ctx4, ....
        isCAF = null ctxs && sym.depth == 0
        csig = sym.typ.{rho <- Rho.{context = symt.typ.rho.context ++ ctxs}}
        csym = sym.{typ = csig}

    let cmeth = case sym.expr of
            Just (v@Vbl {name=MName cname bs})
                | cname `elem` (symc.name:symc.supers),
                  Just (meth@SymV{}) <- v.name.findit g,    -- just class method
                  isJust meth.nativ || isJust meth.expr = meth
            other -> sym -- instance method

    mhbind <- compiling csym (instSym sym.pos cmeth sym.typ)


    let constrformal = map (uncurry (makeConstraintArg g)) (zip ctxs ourCtxNms)
        sjt          = if isCAF then lazy jtValue else jtFun
    let -- constrargs   = map JAtom (take sym.typ.rho.context.length ctxNames)
        -- eosjt = erasedObj sjt
        result = JMethod {attr = attrs [JPublic, JFinal],
                            gargs = [],      -- ftargs,
                            jtype = sjt,     -- if higher then eosjt else sjt,
                            name = latinF ++ mangled sym.name.base,
                            args = constrformal,
                            body = JBlock ([JReturn impl])}
        impl = mhbind.jex
--            | null constrargs = mhbind.jex
--            | otherwise = JX.new [bindto] jtMH
--            where bindto = fold app (JX.xmem "j" mhbind.jex) constrargs -- mh.j.bindTo(ctx1) ...
--        app x a = (JX.invoke [a] • JX.xmem "bindTo") x
    stio [JComment ((nice sym g) ++ " :: " ++ nice sym.typ g), result]



{--
    Return the 'JName' of the worker function for the given symbol.
    [enum constructor]    @P.T.D@, actually a boxed int
    [newtype constructor] @P.T.mk@ (identity function)
    [product constructor] @P.T.mk@
    [sum constructor]     @P.T.D.mk@
    [let bound function/value] not usable, let bound definitions only accessible via 'Binding's
    [top level value]     @P.name@, @P.T.m.name@, @P.I.name@, @P.C.i.name@
    [top level function with constraints] @X.name.work@ (non static)
    [top level function, no constraints]  @X.name@
 -}
workerMethod :: Global -> Symbol -> JName
workerMethod g (sym@SymD {name, flds}) = case U.javaName g name of
        jname | Just (SymT {enum = true}) <- name.tynm.findit g = jname
              | otherwise = U.memberOf jname "mk"
workerMethod g (sym@SymV {name, depth = 0}) = U.javaName g name
workerMethod g (sym@SymV {name = Local{}})  = (U.javaName g sym.name).{base=(workName g sym)}
-- workerMethod g (sym@SymV {name, nativ=Nothing})
--     | not (null sym.typ.rho.context)        = U.memberOf (U.javaName g name) (workName g sym)
workerMethod g (sym@SymV {name})            = U.javaName g name
workerMethod g _ = error "workerMethod: no SymV"

{--
    Return the 'JName' of the lambda wrapper class for this symbol, if it has one.
    This is mainly used to find the type argument for @*new*@.

    [data constructors with arity 0]    'Nothing', has none
    [data constructors with arity > 0]  'Nothing', singelton lambda made on the fly
    [values] Nothing, has none
    [let bound function] L/N/, where /N/ is unique. Only valid in scope of binding.
    [top level function with constraints] @X.name@ (to be initialized with constraints)
    [top level function, no constraints]  'Nothing', singleton lambda made on the fly
--}
wrapperClass :: Global -> Symbol -> Maybe JName
wrapperClass g (sym@SymD {}) = Nothing
    -- null flds = Nothing
    -- otherwise = Nothing
wrapperClass g (sym@SymV {name, depth, sid})
    | depth == 0 = Nothing
    | Local{} <- name = Just (JName "" ("L" ++ show sid))
    | null sym.typ.rho.context = Nothing
    | otherwise = Just (U.javaName g name)
wrapperClass g sym = error ("wrapperClass: bad arg " ++ sym.nice g)


{--
    The name of the static variable that holds an instance of the 'wrapperClass'.
    If this is a value or a nullary constructor, it returns the same as 'workerMethod'.

    Note that let bound symbols must use the 'Binding' they are bound to.

    [data constructors with arity > 0]   @M.T.D.ﬂmk@
--}
{-
wrapperInstance :: Global -> Symbol -> JName
wrapperInstance g (sym@SymD {strsig, flds})
    | null flds = workerMethod g sym
    | otherwise = (workerMethod g sym).{base <- (++ latinF)}
wrapperInstance g (sym@SymV {name}) 
    | not name.isLocal = (workerMethod g sym).{base <- (++ latinF)}
wrapperInstance g sym = error ("wrapperInstance: bad arg " ++ sym.nice g)
-}

{--
    This is used for let bound functions and top level functions with constraints.
    Both have normally an @eval@ method that is lazy in all arguments and return type
    and a @work@ method that has at least one non lazy arg or the return type is not lazy.

    Sometimes it happens that he worker method would have the same method signatur
    as the eval method. In that case, we can just do the computation in the @eval@ method
    instead of passing the arguments to @work@. Saves at least one stack frame.

    This function returns @"eval"@ if the @eval@ function can do the work, otherwise @"work"@.
--}
workName :: Global -> Symbol -> String
workName g (sym@SymV {name, typ, strsig, depth, rkind})
    | depth > 0,
      local name || constrained typ,
      rmode rkind == wmode rkind,
      onlyLazyArgs strsig = "eval"
    | otherwise = "work"
    where
        local (Local{}) = true
        local _         = false
        constrained sigma = not (null (Sigma.rho sigma).context)
        onlyLazyArgs (S uuu) = all (U==) uuu
        onlyLazyArgs _ = false
workName g sym = "work"



{--
 * @makeConstraintDef (Ctx cname tau) "ctx3"@ = final Ccname<tau> ctx3
 -}
makeConstraintDef g (Ctx {cname,tau}) s =
        -- g    <- getST
        -- itau <- tauJT tau
        JMember {
            attr = attrFinal,
            jtype = Ref (U.javaName g cname) [],
            name = s,
            init = Nothing}

{--
 * @makeConstraintArg (Ctx cname tau) "arg3"@ = (final,  Ccname<tau>, "ctx3")
 -}
makeConstraintArg g ctx s = (def.attr, (ForAll [] (RhoTau [ctx] (Context.tau ctx))), def.jtype, def.name)
    where def = makeConstraintDef g ctx s


{--
 * generate method signature from strictness info and argument types
 -}
argDef attr stri sigmas argNms
    | S ss <- stri = mapSt argdef (zip ss      (zip sigmas argNms))
    | otherwise    = mapSt argdef (zip allLazy (zip sigmas argNms))
    where
        argdef (s, (sig, nm)) = do
            argjt <- sigmaJT sig
            if Strictness.isStrict s then stio  (attr, sig, strict argjt, nm)
                else stio (attr, sig, lazy argjt, nm)

{--
 * convert an arg quadrupel to a 'Binding'
 -}
argBind(_, sig, jt, s) = Bind (jtRmode jt) sig jt (JAtom s)

{--
 * the mode a certain argument is in, given strictness and sigma
 -}
argMode s sig
    | Strictness.isStrict s = do
        sjt <- sigmaJT sig
        stio (jtRmode (strict sjt))
    | otherwise = stio RLazy

{--
    adapt a 'Binding' to the required strictness
--}
adaptBind :: Binding -> Strictness -> Binding
adaptBind bind s
    | s.isStrict = strictBind bind
    | otherwise  = notStrict bind

--- adapt argument to wanted strictness
adaptArg a s = adaptBind (argBind a) s

{--
 * code for non-functions
 * - if there are constraints, we make a static function with constraint args.
 * - else, if the easy bit is off, we make an U<type> and write the code in the eval function.
 * - else we just initialize
 -}
cafCode (sym@SymV {depth = 0, expr = Just x}) binds = do
    g    <- getST
    let bnds = sym.typ.bound
        ctxNames = drop (length (envCtxs g)) GenJava7.ctxNames

    let (rtyp, _) = U.returnTypeN 0 sym.typ.rho
        symtyp = ForAll bnds rtyp
        mode  = if rlazy then RLazy else RBoxed
        rlazy = not g.toplevel && not sym.strsig.isStrict || sym.rkind `band` 1 == 0
        rsimple = sym.rkind `band` 16 != 0        
        ctxs  = if null bnds then [] else filter  (not • Context.checked) sym.typ.rho.context
        cargs = map  (uncurry (makeConstraintArg g)) (zip ctxs ctxNames)
        -- constraints = map  (uncurry (makeConstraintDef g)) (zip ctxs ctxNames)
    jtype <- sigmaJT symtyp
    selfrec <- if rsimple || g.toplevel then return 0 else T.references [sym.sid] x
    escode <- if null cargs && rsimple
        then do
            ecode <- compiling sym (genExpr  false mode x binds)
            stio (Left ecode)
        else do
            let badguard = T.openCaseWhen g x
                jthrow = [JThrow (JNew (Ref (JName "RT" "GuardFailed") []) [
                                                    JAtom (show (nicer sym g)),
                                                    JAtom (show sym.pos)])]
            code <- compiling sym (genStmts RBoxed x binds)
            case badguard of
                Just (Left x) -> do
                    U.warn (getpos x) (msgdoc ("guard (" ++ nice x g ++ ") may evaluate to false."))
                    stio (Right (code ++ jthrow))
                Just (Right p) -> do
                    U.warn (getpos p) (msgdoc ("pattern guard (" ++ nice p g ++ ") may fail to match."))
                    stio (Right (code ++ jthrow))
                Nothing -> stio (Right code)


    let name  = U.javaName g sym.name           -- P.foo
        left (Left c) = c
        left _ =  error "no ecode"
        right (Right c) = c
        right _ =  error "no scode"
        ecode  = left escode
        scode  = right escode
        rtype = if rlazy then lazy jtype else boxed jtype
        -- utype = if rlazy then jtValue
        comms = reverse [
                JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
                JComment (nicer sym.typ g), JComment (nicer x g)]
        jexpr = (toMode mode ecode).jex
        static = if g.toplevel then JStatic else JFinal
        publik = if g.toplevel then JPublic else JFinal
        cafV  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                          name = name.base,
                          init = Just jexpr}
        utype = Ref (JName "" "Unknown") [jtValue]    -- Unknown<FV>
        -- ctype = Ref (JName "" cafV.name) (map targ bnds)
        newu  = JNewClass utype [] [vMeth]          -- new Unknown<R>() { ... }
        theU
            | rlazy = newu
            | otherwise = (toBoxed (Bind RLazy symtyp (lazy jtype) newu)).jex
                                -- (JCast rtype • JX.invoke [] • JX.xmem "_e") newu
        -- fcode = if rlazy then [JReturn newu] else scode
        theC = JNewClass (Ref (JName "java.lang" "Object")[]) [] [cafU] `JExMem` cafV.name
        vMeth = JMethod { attr = attrs [JPublic, JFinal],
                          gargs = [],
                          -- @_v@ absolutely must return Lazy<T>
                          jtype = rtype,
                          name = "_v", args = [], body = JBlock scode }
        cafU  = JMember { attr = attrs [publik, JFinal, static], jtype = rtype,
                          name = cafV.name,
                          init = Just theU}
        -- the following will be used for self-recursive local vars
        -- it is the lazy variant 'cafU' but enclosed in an extra class
        -- to avoid closure about a non-initialized value
        cafC  = cafU.{init = Just theC}                           
        cafF  = JMethod { attr = cafV.attr, jtype = rtype,
                          gargs = [], name = cafV.name,
                          args = cargs, body = JBlock scode }


    when (!g.toplevel && not (null cargs)) do
        U.error sym.pos (text ("local CAF with constraints not allowed"))
    when (!g.toplevel && selfrec > 0) do
        U.hint sym.pos (text ("local self recursive values are expensive"))        
    let !caf = case (g.toplevel, not (null cargs), rsimple, selfrec > 0) of
            --top   cargs  simple, selfrec
            (false, false, false, true) -> cafC     -- self recursive local values
            (_,     false, false, _)    -> cafU
            (_,     false, true,  _)    -> cafV
            (true,  true,  _    , _)    -> cafF
            (false, true,  _    , _)    -> error "cannot happen"
    stio (reverse (caf:comms))

cafCode _ binds = error "cafCode: no caf"
--
--{--
-- * tell if a variable is implemented with a member or a class
-- -}
--varIsClass (sym@SymV {name, depth, rkind})
--    | depth > 0 = true
--    -- Local _ <- name = false
--    -- not (null (filter  (not • Context.checked) sym.typ.rho.context)) = true
--    | not (null sym.typ.bound) = true
--    | otherwise   = false
--    where
--        simple           = (rkind `band` 16) != 0
--        global (Local _) = false
--        global _         = true
--varIsClass _ = error "varIsClass: no var"


{--
 * all the boilerplate code for a frege function
 -}
-- funCode (sym@SymV {expr = Just x}) binds = topFun sym binds
funCode (sym@SymV {expr = Just x}) binds = do
    g <- getST
    if g.toplevel then topFun   sym binds
                  else {- if null sym.typ.bound
                    then -} innerFun sym binds
                    {- else innerQualifiedFun sym binds -}
funCode nofun binds = error "funClass: no function"

{--
    create new Lambda123() { ...} from \x -> e
    -}
lambdaEx :: Expr -> Tree Symbol Binding -> StG Binding
lambdaEx (lam@Lam{pat,ex,typ=Just (sig@ForAll _ rho)}) binds = do
    g <- getST
    U.logmsg TRACEG (getpos ex) (text("lambdaEx: " ++ nice ex g ++ " :: " ++ nicer rho g))
    rho <- TC.zonkRho rho
    let depth = U.lambdaDepth ex + 1
        argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
        (rty, atys) = U.returnTypeN depth rho
        lambdaTyp  = Nativ ("Lam"  ++ show depth) []
        fake = (U.patLocal (getpos lam) 0 "\\lambda").{depth}
    sjt  <- sigmaJT sig
    rjt  <- rhoJT rty
    ajts <- mapSt sigmaJT atys
    -- strsig <- T.lambdaStrictness lam
    workerArgs <- argDef attrFinal U atys argNames
    stmts <- compiling fake (genLambda RLazy lam workerArgs binds) 
    let worker = JMethod {attr = attrs [JFinal, JPublic],
                          gargs = [],
                          jtype = lazy rjt,
                          name = "eval",
                          args = reverse workerArgs,
                          body = JBlock stmts}
        theClass =  JNewClass lambdaTyp [] [worker]
    return Bind{mode=RBoxed, ftype = sig, jtype = sjt, jex = theClass}

lambdaEx ex binds = do
    g <- getST
    U.fatal (getpos ex) (text ("lambdaEx: bad lambda " ++ nice ex g))    

{--
    Create @final Lambda123 name = new Lambda123() { ... }
 -}
innerFun (symc@SymV {expr = Just x}) binds = do
    g <- getST
    U.logmsg TRACEG symc.pos (text ("innerFun: " ++ nice symc.name g ++ " :: "
             ++ nice symc.typ.rho g ++ ", depth=" ++ show symc.depth))
    rho <- TC.zonkRho symc.typ.rho

    let argNames = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
        envCtx   = envCtxs g
        implies = impliesG g
        ctxs = [ ctx | ctx <- rho.context,
                       hasVars (Context.tau ctx),
                       not (any (`implies` ctx) envCtx)]
        sym = symc.{typ <- Sigma.{rho <- Rho.{context = []}}}
        argAttr = if (sym.rkind `band` T.rkTail) == 0 then attrFinal else 0
        (rty, atys) = U.returnTypeN sym.depth sym.typ.rho
        hasVars (TVar{}) = true
        hasVars (TCon{}) = false
        -- hasVars (TFun a b) = hasVars a || hasVars b
        hasVars (TApp a b) = hasVars a || hasVars b
        hasVars (Meta{}) = true

    U.changeSym sym
    unless (null ctxs) do
        U.error sym.pos (msgdoc (nice sym g ++ " has context " ++ U.nicerctx ctxs g))

    rjt  <- rhoJT rty
    ajts <- mapSt sigmaJT atys
    workerArgs <- argDef argAttr sym.strsig atys argNames


    let modew = wmode sym.rkind

    let
        workerType = case modew of
                                RLazy  -> lazy rjt
                                RBoxed -> rjt
                                RNative -> strict rjt
        workerName = workName g sym
        letName    = U.javaName g sym.name
        lambdaTyp  = Nativ ("Lam"  ++ show sym.depth) []
        classTyp   = Nativ ("L" ++ show sym.sid) []
        thisName   = "this"  ++ show sym.sid
        thisBind   = Bind RNative sym.typ classTyp (JAtom thisName)
        innerbinds = insert binds sym thisBind

    stmts        <- compiling  sym (genFunction sym modew workerArgs innerbinds)
    lMethod      <- lazyMethod   sym
    -- let flMethod = lMethod.{attr = attrs [JFinal, JPublic], name = "eval", args <- reverse}
    -- handleMethod <- genLocalMH sym

    let worker = JMethod {attr = attrs [JFinal, JPublic],
                          gargs = [],
                          jtype = workerType,
                          name = workerName,
                          args = workerArgs,
                          body = JBlock (thisAssign:stmts)}
        -- final Lambda123 this123 = this;
        thisAssign = JLocal (JMember {attr = attrFinal, jtype=classTyp, name = thisName,
                                        init = Just (JAtom "this")})
        letVar = JMember { attr = attrFinal, jtype = classTyp, name = letName.base,
                            init = Just (JNew classTyp []) }
        defs
            | workerName == "eval" =  [worker.{args <- reverse}]
            | otherwise      =  [worker, lMethod]
        theClass = JClass { attr = attrFinal, jtype = classTyp,
                            extend = Just lambdaTyp,
                            implement = [], defs}




    stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment (nicer x g),
        theClass, letVar
        ])
innerFun sym binds = error "innerFun: no function"

topFun (sym@SymV {expr = Just x}) binds = do
    g <- getST
    U.logmsg TRACEG sym.pos (text ("topFun: " ++ nice sym.name g ++ " :: "
             ++ nice sym.typ.rho g ++ ", depth=" ++ show sym.depth))

    let argNames     = drop (fold (+) 0 (map Symbol.depth g.genEnv)) GenJava7.argNames
        argAttr      = if (sym.rkind `band` T.rkTail) == 0 then attrFinal else 0
        (rty, atys)  = U.returnTypeN sym.depth sym.typ.rho
        -- staticWorker = null sym.typ.rho.context
        constrargs   = map  (uncurry (makeConstraintArg g)) (zip sym.typ.rho.context ctxNames)

    rjt  <- rhoJT rty
    workerArgs <- argDef argAttr sym.strsig atys argNames


    let modew = wmode sym.rkind
        workerType = case modew of
                                RLazy  -> lazy rjt
                                RBoxed -> boxed rjt
                                RNative -> strict rjt
        workerName = (U.javaName g sym.name).base -- if staticWorker then (workerMethod g sym).base else workName g sym

    stmts  <- compiling sym (genFunction sym modew (workerArgs) binds)
    -- lClass <- prepareLazy sym  {- if staticWorker
    --             then return (JComment "has static worker")
    --             else lazyClass sym -}

    let worker = JMethod {attr = attrs [JFinal, JPublic, JStatic],
                          gargs = [],
                          jtype = workerType,
                          name = workerName,
                          args = constrargs ++ workerArgs,
                          body = JBlock stmts}

        defs = [{-lClass,-} worker]
          
    stio ([JComment ((nicer sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
        JComment (nicer sym.typ g),
        JComment (nicer x g)] ++ defs)
topFun _ _ = error "topFun: no function"


returnTau sigma = (fst • U.returnType) (Sigma.rho sigma)
sigmaTau f (ForAll [] (RhoTau [] ty)) = f ty
sigmaTau f (ForAll [] rhofun) = sigmaTau f (ForAll [] (U.tauRho rhofun))
sigmaTau f _ = Nothing

--- enumeration constants for the native interface kind
data NIKind = NIOp | NINew | NIMethod | NIMember | NICast | NINewArray | NIStatic
derive Eq NIKind

{--
 * determine kind of java expression to generate, based on the item information
 -}
niKind "new"      = NINew
niKind #^\W+$#    = NIOp
niKind #^\w+$#    = NIMethod
niKind #^\.\w+$#  = NIMember
niKind #^\(.+\)$# = NICast
niKind #.+\[\]$#  = NINewArray
niKind _          = NIStatic

niArr s = strhead s (length s - 2)

niSpecial ty
    | Just _ <- U.isUnit ty      = true
    | Just _ <- U.isMaybe ty     = true
    | Just _ <- U.isException ty = true
    | Just _ <- U.isIO ty        = true
    | otherwise = false

{--
 * check native method
 -}
methClass (sym@SymV {nativ = Just item, pur=true, typ})
    | Just (_, tau) <- U.isIO (returnTau typ) = do
        g <- getST
        U.error sym.pos (msgdoc ("contradictory declaration, " ++ nice sym.name g
            ++ " cannot be pure and have a return type of " ++ nicer (returnTau typ) g))
        stio []
    | Just _ <- U.isUnit (returnTau typ) = do
        U.error sym.pos (msgdoc ("void " ++ item ++ "(...) cannot be a pure function"))
        stio []
    | (_, [sig]) <- U.returnType typ.rho,
      Just _ <- sigmaTau U.isUnit sig = do
        U.error sym.pos (msgdoc (item ++ "() cannot be a pure function"))
        stio []
methClass (sym@SymV {nativ = Just item, pur=false, typ})
    | Nothing <- U.isIO (returnTau typ) = do
        g <- getST
        U.error sym.pos (msgdoc (nice sym.name g
            ++ " has an illegal return type for a method that is not pure,"
            ++ " perhaps  " ++ nicer (sttyp (returnTau typ)) g
            ++ "  would work"))
        stio []
    where
        sttyp tau
            | [s] <- keys (U.freeTauTVars [] Nil tau) = TApp (TApp st (tv s)) tau
            | otherwise = TApp (TApp st (tv "s")) tau
            where
                st   = TCon {pos=sym.pos, name = TName pPreludeBase "ST"}
                tv s = TVar {pos=sym.pos, var = s}

methClass (sym@SymV {nativ = Just item, pur, typ}) = do
        let
            nik = niKind item
        ok1 <- argsOk nik atys
        ok2 <- retOk  nik rty
        if ok1 && ok2 then methCode sym else stio []
    where
        (rty, atys) = U.returnType typ.rho
        isMBU tau | Just x <- U.isMaybe tau, Just _ <- U.isUnit x = true
                  | Just x <- U.isException tau = isMBU x
                  | Just (_, x) <- U.isIO tau = isMBU x
                  -- Just _ <- U.isUnit tau = true
                  | otherwise             = false
        validIOtype tau | Just (_, x) <- U.isIO tau = case U.isUnit x of
                                                        Just _ -> true
                                                        _ -> validXtype x
                        | otherwise = validXtype tau
        validXtype tau  | Just x <- U.isException tau = case U.isUnit x of
                                                        Just _ -> true
                                                        _ -> validMBtype x
                        | otherwise = validMBtype tau
        validMBtype tau | Just x <- U.isMaybe tau = not (niSpecial x)
                        | otherwise = not (niSpecial tau)
        validCaftype tau | Just (_, x) <- U.isIO tau = validMBtype x
                         | otherwise = validMBtype tau
        validNIArg sigma | maybe true (const false) (sigmaTau Just sigma) = do
            g <- getST
            U.error sym.pos (msgdoc (nice sigma g ++ " is not valid for native method arguments"))
            stio false
        validNIArg sigma = do
            g <- getST
            let tau = maybe undefined id (sigmaTau Just sigma)
                xio = isJust (U.isIO tau) || isJust (U.isException tau)
            if isMBU tau || isJust (U.isUnit tau)
                then do
                    U.error sym.pos (msgdoc ("type  " ++ nice tau g
                        ++ "  is illegal for a native function argument,"
                        ++ " () may only appear to indicate an empty argument list."))
                    stio false
                else if xio
                    then do
                        U.warn sym.pos (msgdoc (nice sym g ++ "  has an argument of type  "
                            ++ nice sigma g))
                        U.hint sym.pos (msgdoc ("Exception, ST and IO types have a special meaning"
                            ++ " in the native interface. "
                            ++ "Using them in argument position is most likely wrong."))
                        stio true
                    else stio true
        retOk _ tau | isMBU tau = do
            U.error sym.pos (msgdoc "The construct  Maybe ()  makes no sense in a native return type.")
            stio false
        retOk _ tau | not (validIOtype tau) = do
            U.error sym.pos (msgdoc "Illegal nesting of IO, ST, Exception, Maybe and () in the return type.")
            stio false
        retOk NIStatic tau | null atys, not (validCaftype tau) = do
            U.error sym.pos (msgdoc "A static member may not be void and it certainly throws no exceptions.")
            stio false
        retOk NIMember tau | not (validCaftype tau) = do
            U.error sym.pos (msgdoc "An instance member may not be void and it certainly throws no exceptions.")
            stio false
        retOk _ _ = stio true
        argsOk NIOp [x]   = validNIArg x
        argsOk NIOp [x,y] = liftM2 (&&) (validNIArg x) (validNIArg y)
        argsOk NIOp _ = do
            g <- getST
            U.error sym.pos (msgdoc ("Java operator " ++ nice sym.name g ++ " demands 1 or 2 operands."))
            stio false
        argsOk kind [] | kind `elem` [NINew, NIMethod, NICast] = do
            g <- getST
            U.error sym.pos (msgdoc ("Illegal type for " ++ nice sym.name g ++ ", must be function type"))
            stio false
        argsOk NICast [x]
            | Nothing <- sigmaTau U.isUnit x = stio true
        argsOk NICast _ = do
            U.error sym.pos (msgdoc "A java type cast must have exactly one argument which may not be ()")
            stio false
        argsOk NIMember (this:xs)
          | length xs > 0 = do
                U.error sym.pos (msgdoc ("Getter for " ++ item ++ " cannot have more than 1 argument."))
                stio false
          | otherwise = do
            g <- getST
            sjt <- sigmaJT this
            javatype <- case sigmaTau Just this of
                Just tau -> U.isJavaType tau
                _ -> stio false
            if javatype
                then if maybe true (const false) (isPrimitive sjt)
                    then stio true
                    else do
                        U.error sym.pos (msgdoc ("Cannot get instance member " ++ item
                            ++ " from primitive"))
                        stio false
                else do
                    U.error sym.pos (msgdoc ("Cannot get instance member " ++ item
                            ++ " from non-native object"))
                    stio false
        argsOk NIMethod (this:xs) = do
            g <- getST
            sjt <- sigmaJT this
            javatype <- case sigmaTau Just this of
                Just tau -> U.isJavaType tau
                _ -> stio false
            if javatype
                then if maybe true (const false) (isPrimitive sjt)
                    then do
                        oks <- mapSt validNIArg xs
                        stio (and oks)
                    else do
                        U.error sym.pos (msgdoc ("Cannot invoke instance method " ++ item
                            ++ " on primitive type"))
                        stio false
                else do
                    U.error sym.pos (msgdoc ("Cannot invoke instance method " ++ item
                            ++ " on non native type"))
                    stio false
        argsOk NINewArray xs | length xs > 1 = do
            U.error sym.pos (text "Array must have only one argument.")
            stio false
        argsOk kind [x] | kind != NIMethod, Just _ <- sigmaTau U.isUnit x  = stio true
        argsOk _ xs = do
            oks <- mapSt validNIArg xs
            stio (and oks)
methClass _  = undefined

wrapped (sym@SymV {nativ = Just item}) = niSpecial rty
    where
        (rty, _) = U.returnType sym.typ.rho
wrapped SymV {} = false
wrapped SymD {} = false
wrapped _ = error "wrapped: no symv"

{--
 * Tell if a native function must be called through it's wrapper.
 *
 * Plain types and Maybe types can be called directly
 -}
wrappedOnly (sym@SymV {nativ = Just item}) = niSpecial rty && isNothing (U.isMaybe rty)
    where
        (rty, _) = U.returnType sym.typ.rho
wrappedOnly sym = error "wrappedOnly - no native function"


--- returns a binding for a direct call of a native method
nativeCall (sym@SymV {nativ = Just item}) abinds = do
        g <- getST
        let
            taus = [ tau | Just tau <- map (sigmaTau Just) sigmas ]
            brty = baserty rty
            bsig = ForAll [] (RhoTau [] brty)
            args | [tau] <- taus, Just _ <- U.isUnit tau = stio []   -- no arguments
                 | otherwise = mapSt (uncurry argEx) (zip abinds taus)
        bjt <- tauJT brty
        let jrty = strict  bjt
            retmode = maxStrict jrty
        as <- args
        stio (Bind retmode bsig jrty (call jrty as))
    where
        (rty, sigmas) = U.returnType sym.typ.rho
        argEx bind tau
            | Just x <- U.isMaybe tau = do
                    jt <- tauJT x
                    stio (JQC checknothing (JAtom "null") (justm1 x jt).jex)
            | otherwise = stio sbind.jex
            where
                sbind = toMode RNative bind
                checknothing = JBin con "==" (JAtom "0")
                con = JInvoke (JExMem sbind.jex "constructor") []
                justm1 x jt = toMode RNative (Bind RLazy (ForAll [] (RhoTau [] x)) jt m1ex)
                m1ex = JExMem just "mem1"
                just = JInvoke (JExMem sbind.jex "_Just") []
        baserty r
            | Just (_, x) <- U.isIO r   = baserty x
            | Just x <- U.isException r = baserty x
            | Just x <- U.isMaybe r     = baserty x
            | Just _ <- U.isUnit r      = r
            | otherwise                 = r
        call jrty args = case niKind item of
            NIOp -> case args of
                [a,b] -> JBin a item b
                [a]   -> JUnop item a
                _     -> JAtom "null"           -- error was flagged before
            NINew -> JNew jrty args
            NICast -> case args of
                [a] -> JInvoke (JAtom item) args    -- was: JCast (Ref (JName "" item) []) a
                _   -> JAtom "null"
            NIMethod -> case args of
                (a:as) -> case item of
                    "clone" -> JCast jrty (JInvoke (JExMem a item) as) -- due to java brain damage
                    _ -> JInvoke (JExMem a item) as
                _ -> JAtom "null"
            NIMember -> case args of
                [a] -> (JExMem a (tail item))
                _ -> JAtom "null"
            NINewArray -> JNewArray  (Ref (JName "" (niArr item)) []) (head args)
            NIStatic -> case sigmas of
                (_:_) -> JInvoke (JAtom item) args
                _ -> JAtom item
nativeCall sym abinds = error "nativeCall: no function"

wrapCode jreturn rtau (sym@SymV {nativ = Just item}) abinds
    | Just (stau, atau) <- U.isIO rtau = do
        g <- getST

        sjt     <- tauJT stau          -- type #1 for parameterization of ST s a
        ajt     <- tauJT atau          -- type #2 for parameterization of ST s a
        let ssig    = ForAll [] (RhoTau [] stau)
            mktup x = JReturn x -- (JInvoke (JStMem (JName "Prelude.tTuple2" "mk") [ajt, sjt])
                                --        [x, JAtom "_state"])
        rbody <- wrapCode mktup atau sym abinds

        let tuple   = atau  -- TApp (TApp (TCon {pos=sym.pos, name = TName pPrelude "(,)"}) atau) stau
            frho    = RhoFun [] ssig (RhoTau [] atau)   -- s -> a
        tjt     <- tauJT tuple
        fjt     <- rhoJT frho
        let ret     = jreturn fun -- (JNew jtFun [mkST])
            -- mkST    = (JX.invoke [JAtom "where"] • JX.xmem "handle") fun -- JInvoke (JStMem (JName "Prelude.TST" "mk") [sjt, ajt]) [fun]
            fun     = JNewClass lambda [] [rMethod]
            lambda  = Nativ "Lam1" []
            rMethod = JMethod {attr = attrs [JFinal, JPublic], gargs=[],
                               jtype = lazyVal, name = "eval",
                               args = [(attrFinal, ssig, lazy sjt, "_state")],
                               body = JBlock rbody}
        stio [ret]
    | Just mtau <- U.isException rtau = do
        g          <- getST

        mjt     <- tauJT mtau
        xjt     <- tauJT (TCon {pos = sym.pos, name = TName pPreludeBase "JException"})
        let right x = jreturn (JInvoke (JStMem (JName (base ++ ".TEither.DRight") "mk")
                                               [])
                                       [x])
            left    = jreturn (JInvoke (JStMem (JName (base ++ ".TEither.DLeft")  "mk")
                                               [])
                                       [JInvoke (JStMem (JName "Box" "mk")
                                                        [head xjt.targs])
                                                [JAtom "ex"]])

        code       <- wrapCode right mtau sym abinds
        let try     = JBlockX "try" code
            catch   = JBlockX "catch (Exception ex)" [left]
        stio [try, catch]
    | Just atau <- U.isMaybe rtau = do
        g          <- getST
        ajt        <- tauJT atau
        bind       <- nativeCall sym abinds
        let mkmb    = case isPrimitive ajt of
                Just prim ->
                    JInvoke (JStMem (JName base ("_" ++ prim++ "ToMaybe")) []) [bind.jex]
                Nothing   ->
                    JInvoke (JStMem (JName base "_toMaybe") []) [bind.jex]
        stio [jreturn mkmb]
    | Just _ <- U.isUnit rtau = do
        g          <- getST
        bind       <- nativeCall sym abinds
        let unit    = JStMem (JName (base ++ ".TUnit") "Unit") []
        stio [JEx bind.jex, jreturn unit]
    | otherwise = do
        g          <- getST
        bind       <- nativeCall sym abinds
        stio [jreturn (toBoxed bind).jex]
    where
        base = "PreludeBase"        
wrapCode jreturn rtau sym abinds = error "wrapCode: no SymV"


{--
 * code for native functions and/or members
 -}
methCode (sym@SymV {nativ = Just item})
    {- | arity >= 0 -} = do
        g              <- getST
        rjt            <- tauJT rty
        ajts           <- mapSt sigmaJT atys
        extend         <- sigmaJT sym.typ
        rArgs          <- argDef attrFinal U atys argNames
        wArgs          <- argDef attrFinal (S allStrict) atys argNames
        let bnds        = sym.typ.bound
        let name        = U.javaName g sym.name                        -- X.foo
            -- fname       = {-U.fName-} name                                 -- X.Ffoo
            ftargs      = [] -- map targ bnds                                -- <a,b,c>
            -- ftype       = (Ref (fname) ftargs)                         -- Ffoo<a,b,c>
            -- dftype      = defining ftype
            args        = if haswrapper then wArgs else rArgs
            haswrapper  = arity > 0 && wrapped sym || (not (null bnds))
            -- callWrapper = (toBoxed bndWrapper).jex
            -- bndWrapper  = bndWcode invWrapper
            -- invWrapper  = JInvoke (JX.static name)
            --                    (map (Binding.jex • strictBind • argBind) rArgs)
            jreturn     = if arity > 0 then JReturn else JEx
            bndWcode  x = Bind (maxStrict rjt)    -- (if wrapped sym then  jstrict rjt else maxStrict rjt)
                            (ForAll [] (RhoTau [] rty)) (strict rjt) x

        wcode          <- if wrapped sym
                                then wrapCode jreturn rty sym (map argBind args)
                                else do
                                    bind <- nativeCall sym (map argBind args)
                                    stio [jreturn bind.jex]


        -- inst            <- if arity > 0 
        --                     then prepareLazy sym
        --                     else return (JComment "no wrapper")

        let wrappers    = if haswrapper then [{- inst, -} wrapper] else [{-inst-}]
            wrapper     = JMethod {attr = attrs [JPublic, JStatic, JFinal],
                                gargs = ftargs, jtype = strict rjt, name = name.base,
                                args = wArgs, body = JBlock wcode}
            defs        = wrappers
            unex  [(JEx x)] = (toBoxed (bndWcode x)).jex
            unex  _ = error "unex: need list with 1 ex"
            member = JMember {attr = attrs [JPublic, JStatic, JFinal],
                                jtype = rjt,
                                name = (U.javaName g sym.name).base,
                                init = Just (unex wcode)}

        stio ([JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
               JComment (nicer sym.typ g),
               JComment item] ++
               (if arity > 0 then defs else [member]))
    where
        (rty, atys) = U.returnType sym.typ.rho
        arity       = length atys

methCode sym = do
        g <- getST
        U.error sym.pos (text ("can not compile " ++ nice sym g))
        stio [JComment ((nice sym g) ++ "  " ++ show sym.strsig ++ "  " ++ show sym.rkind),
              JComment (nicer sym.typ g)]

{--
 * runs action with symbol in the current compiling environment
 -}
compiling sym action = do
    g <- getST
    changeST Global.{genEnv <- (sym:)}
    r <- action
    changeST Global.{genEnv <- tail}
    stio r

{--
 * - invokes 'genLambda' to generate code for a function
 * - wraps the code in a while statement for tail calling functions
 -}
genFunction (sym@SymV {expr = Just ex}) rmode args binds = do
        g <- getST
        -- let oldsym = g.genSym
        -- changeST Global.{gen <- GenSt.{genSym = sym}}
        code <- if (sym.rkind `band` T.rkTail) == 0
            then genLambda rmode ex args binds
            else do
                let
                    fargs = [ (attrFinal, sig, jt, nm ++ "f") | (_,sig,jt,nm) <- args ]
                    decls = [ JMember { attr = attrFinal,
                                        jtype = jt,
                                        name = nm ++ "f",
                                        init = Just (JAtom nm)} | (_,sig,jt,nm) <- args ]
                    stmts = map JLocal decls
                code <- genLambda rmode ex fargs binds
                stio [JCond "tailrecursion: while" (JAtom "true") (stmts ++ code)]
        -- changeST Global.{gen <- GenSt.{genSym = oldsym}}
        stio code
genFunction sym rmode args binds = error "genFunction: no function"

{--
 * [usage] @realize bind@
 *
 * code to create a local variable and an updated bind
 -}
realize name bind
    | cheap (Binding.jex bind) = stio (bind, [])
    | otherwise = do
        u <- U.uniqid
        g <- getST
        let vname = m name -- ++ underline ++ show u  -- must correspond to U.javaName
            m "$" = "$" ++ show u
            m s   = s
            -- underline = if name == "$" then "" else "_"
            member = JMember {attr = attrFinal,
                                jtype = Binding.jtype bind,
                                name = vname,
                                init = Just (Binding.jex bind)}
            nbind = bind.{jex = JAtom vname}
        stio (nbind, [sComment ("realize " ++ name ++ " bound to " ++ nice bind g), JLocal member])


--- make a statement comment
sComment = (JLocal • JComment)

{--
 * [usage] @match pattern bind continuation bindings@
 * [returns] a list of java statements and an updated binding
 * generate code and/or extend current @bindings@ that performs and/or reflects
 * a match of @pattern@
 * against the java expression in @bind@ and generate the code for a successful match
 * by applying @continuation@ to the extended bindings.
 *
 * Generated code will look like this:
 * > comment
 * > auxiliary local definitions
 * > if (patternmatches) {
 * >           code generated by continuation
 * > }
 * There does not have to be an @if@ or any other code at all, for example when
 * the pattern is irrefutable. The code generated by the continuation *must* return,
 * if the control flow reaches the closing brace of the if this will be
 * an indication that the pattern match failed.
 -}
match assert (PVar {uid,var}) bind cont binds = do
        vsym <- U.findV local
        if vsym.strsig.isStrict then strictVar vsym else lazyVar vsym
    where
        local = Local uid var
        jname g = (U.javaName g local).base
        strictVar vsym = do
            g <- getST
            (rbind, code) <- realize (jname g) (notLazy bind)
            let stmt = if null code
                    then [sComment ("bind strict var " ++ nice (Symbol.name vsym) g
                                        ++ "  to  " ++ nice rbind g)]
                    else code
                nbinds = insert binds vsym rbind
            rest <- cont nbinds
            stio (rbind, stmt++rest)
        lazyVar vsym = do
            g <- getST
            let nbinds = insert binds vsym bind
                comment = "bind lazy var " ++ nice (Symbol.name vsym) g ++ "  to  " ++ nice bind g
            rest <- cont nbinds
            stio (bind, sComment comment:rest)

match assert (p@PAt {pat,uid,var}) bind cont binds = do
        g <- getST
        prm <- patternRMode pat
        let local = Local uid var
            jname = (U.javaName g local).base
        vsym <- U.findV local
        let vrm = if vsym.strsig.isStrict then RBoxed else RLazy
            rm = min prm vrm
            ourBind = toMode rm bind
            comment = sComment ("match " ++ nice p g ++ " with " ++ nice ourBind g)
        (rbind, code1) <- realize jname ourBind
        let nbinds = insert binds vsym rbind
        (xbind, code2) <- match assert pat rbind cont nbinds
        stio (xbind, comment : code1++code2)

match assert (pat@PLit {kind=LBool, value}) bind cont binds = do
    g <- getST
    -- (bind,code) <- realize "$" (notLazy bind)
    body <- cont binds
    let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        sbnd = strictBind bind
        jex = if value == "true" then sbnd.jex else JUnop "!" sbnd.jex
        ifc = if assert then JAssert jex : body else [JCond "if" jex body]
    stio (bind, comment:ifc)

match assert (pat@PCon {pos,qname,pats}) bind cont binds = do
        -- g <- getST
        symd <- U.findD qname                   -- forall a.a -> List a -> List a
        symt <- U.findT symd.name.tynm          -- forall a.List a
        if symt.enum then matchEnum symd symt
            else if symt.product
                then if symt.newt
                    then match assert (head pats) bind cont binds
                    else matchProd    symd symt -- pat bind cont binds
                else matchVariant symd symt -- pat bind cont binds
    where
        comment g = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        -- matchNewt :: Symbol -> Symbol -> StG (Binding, [JStmt])
        -- matchNewt symd symt = match (head pats) bind cont binds
        matchEnum :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchEnum symd symt = do
            g <- getST
            (bind, code1) <- realize "$" bind
            body  <- cont binds
            let sbnd = strictBind bind
                comp = (JBin sbnd.jex "==" (JAtom (show symd.cid)))
                ifc  = if assert then JAssert comp : body else [JCond "if" comp body]
            stio (bind, (comment g:code1) ++ ifc)

        matchVariant :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchVariant symd symt = do
            g <- getST

            let box1 = toBoxed bind                     -- List b
                tree = U.unifySigma g symt.typ bind.ftype   -- a -> b

            rho <- U.substRho tree symd.typ.rho       -- b -> List b -> List b
            (boxd, code1) <- realize "$" box1
            pss <- mapSt patternStrictness pats
            datajt <- sigmaJT symt.typ

            let -- smode = any Strictness.isStrict pss
                cname = "_" ++ mangled qname.base
                vbind = Bind RBoxed boxd.ftype
                        (variantType g datajt symd).{targs = boxd.jtype.targs}
                        (JInvoke (JExMem boxd.jex cname) [])

            (varb, code2) <- realize "$" vbind

            let bcon = varb -- if smode then varb else vbind
                scon = symd.strsig.isStrict               -- is this a strict Constructor?
                (_,sigs) = U.returnType rho               -- [b, List b]
                (_,msigs) = U.returnType symd.typ.rho
            sjts <- mapSt sigmaJT (if scon then msigs else sigs)
            let sigssjts = zip sigs sjts
                pbinds
                    | symd.strsig.isStrict = [ Bind (jtRmode (strict sjt)) sig (strict sjt) (JExMem (bcon.jex) m)
                                    | ((sig, sjt), m) <- zip sigssjts memNames ]
                    | otherwise = [ Bind RLazy sig (lazy sjt) (JExMem (bcon.jex) m)
                                                    | ((sig, sjt), m) <- zip sigssjts memNames ]
            
            pbinds <- if scon then mapSt coerce pbinds else return pbinds                                                    

            rest <- matches assert pats pbinds cont binds

            let -- comp = (JBin (JInvoke (JExMem boxd.jex "constructor") [])
                --                    "=="
                --                    (JAtom (show symd.cid)))
                notnull = JBin bcon.jex "!=" (JAtom "null")
                -- ifc = if assert then JAssert comp : body else [JCond "if" comp body]
                ifn = if assert then JAssert notnull : rest else [JCond "if" notnull rest]
                -- body = if smode then code2 ++ rest else rest
            stio (boxd, (comment g : code1) ++ code2 ++ ifn)

        matchProd :: Symbol -> Symbol -> StG (Binding, [JStmt])
        matchProd symd symt = do
            g <- getST
            let tree = U.unifySigma g symt.typ bind.ftype   -- a -> b
            rho <- U.substRho tree symd.typ.rho       -- b -> List b -> List b
            (boxd, code1) <- realize "$" (toBoxed bind)
            pss <- mapSt patternStrictness pats

            let smode = symd.strsig.isStrict || any Strictness.isStrict pss
                bcon = if smode then boxd else bind
                scon = symd.strsig.isStrict                 -- is this a strict Constructor?
                (rty,sigs) = U.returnType rho               -- [b, List b]
                (_,msigs) = U.returnType symd.typ.rho
            rjt <- tauJT rty
            sjts <- mapSt sigmaJT (if scon then msigs else sigs)
            let -- sigjts = sjts ++ [rjt]
                sigssjts = zip sigs sjts
                {-
                field prod f sig = JInvoke applya [Binding.jex prod]
                    where
                        applya = JExMem getmh "apply"
                        prodnm = "Prod" ++ show (length sigs)
                        getnm  = "mh" ++ "get" ++ show f
                        getmh = JStMem (JName prodnm getnm) []
                        -}
                field _ f _ = JExMem boxd.jex ("mem" ++ show f)                        

                pbinds
                    | symd.strsig.isStrict = [ Bind (jtRmode (strict sjt)) sig (strict sjt) (JExMem (bcon.jex) m)
                                    | ((sig, sjt), m) <- zip sigssjts memNames ]
                    | smode = [ Bind RLazy sig (lazy sjt) (JExMem (bcon.jex) m)
                                    | ((sig, sjt), m) <- zip sigssjts memNames ]
                    | otherwise = [ Bind RLazy sig (lazy sjt) (field bcon f sig)
                                    | ((sig, sjt), f) <- zip sigssjts (1..length sigs) ]
                -- make sure refutable patterns are matched first so that
                -- realization of strict variables does not occur outside an if
            pbinds <- if scon then mapSt coerce pbinds else return pbinds
            let ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats pbinds)
            rest <- matches assert (map fst ppbs) (map snd ppbs) cont binds
            let body = if true || smode then code1 ++ rest else rest
            stio (bcon, comment g: body)

match assert (pat@PLit {kind=LString, value}) bind cont binds = do
    g <- getST
    (bind,code) <- realize "$" (notLazy bind)
    body <- cont binds
    let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
        sbnd = strictBind bind
        jex = JInvoke (JExMem (JAtom value) "equals") [sbnd.jex]
        ifc = if assert then JAssert jex : body else [JCond "if" jex body]
    stio (bind, (comment:code) ++ ifc)

match assert (pat@PLit {kind, value}) bind cont binds
    | kind `elem` [LChar, LInt, LLong, LDouble, LFloat] = do
        g <- getST
        (bind,code) <- realize "$" (notLazy bind)
        body <- cont binds
        let comment = sComment ("match  " ++ nice pat g
                                    ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            jex = JBin (JAtom value) "==" sbnd.jex
            ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ ifc)
    | kind == LBig = do
        g <- getST
        (bind, code) <- realize "$" (notLazy bind)
        body <- cont binds
        let comment = sComment ("match  " ++ nice pat g
                                    ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            lit = Lit {pos = pat.pos, kind = LBig, value, typ = Just (TY.sigInteger)}
        xbnd <- genExpr false RNative lit binds
        let jex = JInvoke (JExMem xbnd.jex "equals") [sbnd.jex]
            ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ ifc)
    | kind == LRegex = do
        g <- getST
        (bind,code) <- realize "$" (notLazy bind)
        body <- cont binds

        let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            lit = Lit {pos = pat.pos, kind = LRegex, value, typ = Just (TY.sigRegex)}
        xbnd <- genExpr false RNative lit binds

        let matcher = JInvoke (JExMem xbnd.jex "matcher") [sbnd.jex]
            jex = JInvoke (JExMem matcher "find") []
            ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ ifc)

match assert (pat@PMat {pos, uid, var, value}) bind cont binds = do
        g <- getST
        vsym <- U.findV (Local uid var)
        (bind,code) <- realize "$" (notLazy bind)
        mjt <- sigmaJT (TY.sigMatcher)
        let comment = sComment ("match  " ++ nice pat g
                                ++ "  with  " ++ showJex (Binding.jex bind))
            sbnd = strictBind bind
            lit = Lit {pos, kind = LRegex, value, typ = Just (TY.sigRegex)}

        xbnd <- genExpr false RNative lit binds
        let mbnd = Bind RNative (TY.sigMatcher) (strict mjt)
                    (JInvoke (JExMem xbnd.jex "matcher") [sbnd.jex])
        (mbnd,code2) <- realize (U.javaName g (Local uid var)).base mbnd
        body <- cont (binds.insert vsym mbnd)

        let  jex = JInvoke (JExMem mbnd.jex "find") []
             ifc = if assert then JAssert jex : body else [JCond "if" jex body]
        stio (bind, (comment:code) ++ code2 ++ ifc)

match assert (PAnn {pat})    bind cont binds = match assert pat bind cont binds
match assert (PStrict {pat}) bind cont binds = match assert pat bind cont binds
match _ pat b c bs = do
    g <- getST
    stio (b, [JError ("match  " ++ nice pat g ++ "  with  " ++ showJex (Binding.jex b))])

{--
 * A variant of 'match' that matches the components of a product against a pattern
 *
 * @pat@ must be a constructor application whose constructor is the same
 * as given in @con@
 -}
matchCon assert (PCon {pos,qname, pats}) con bexs cont binds = do
        g <- getST
        sym <- U.findD qname
        if sym.sid != Symbol.sid con
            then do
                U.fatal pos (text ("matchCon: " ++ nice qname g ++ " against " ++ nice con g))
            else do
                -- make sure refutable patterns are matched first so that
                -- realization of strict variables does not occur outside an if
                ppbs = (reverse • sortBy (comparing (T.patternRefutable g • fst))) (zip pats bexs)
                matches assert (map fst ppbs) (map snd ppbs) cont binds
matchCon assert pcon con bexs cont binds = error "matchCon: no constructor"

matches assert []     []     cont binds = cont binds
matches assert (p:ps) (b:bs) cont binds = do
        (_, code) <- match assert p b (matches assert ps bs cont) binds
        stio code
matches assert _ _ _ _ = Prelude.error "matches: cannot happen when compiler is sane"

{--
 * Code for outer lambdas.
 *
 * Set's up a 'Binding' for the corresponding method argument and
 * 'match'es its pattern against it with the enclosed expression as continuation.
 -}
genLambda rm (Lam {pat, ex}) ((_, sig, jt, s) : args) binds = do
    g <- getST
    let komplett = T.patsComplete g [pat]
        badguard = T.openCaseWhen g ex
        assert = isNothing komplett
        -- mustthrow = not assert && isNothing badguard
        margs = map JAtom [show ((last g.genEnv).name.nice g),
                                                show (getpos pat)] ++ [JAtom s]
        jthrow = [JThrow (JNew (Ref (JName "RT" "NoMatch") []) margs)]

    (_, code) <- match assert pat (Bind (jtRmode jt) sig jt (JAtom s))
                           (genLambda rm ex args) binds
    case komplett of
        Just p -> do
            U.warn (getpos pat) (msgdoc ("function pattern is refutable, "
                            ++ "consider adding a case for  "
                            ++ nice p g))
            stio (code ++ jthrow)
        _ -> case badguard of
            Just (Left x) -> do
                U.warn (getpos x) (msgdoc ("guard (" ++ nice x g ++ ") may evaluate to false."))
                stio (code ++ jthrow)
            Just (Right p) -> do
                U.warn (getpos p) (msgdoc ("pattern guard (" ++ nice p g ++ ") may fail to match."))
                stio (code ++ jthrow)
            Nothing -> stio code


genLambda rm x [] binds
    | Lam {pat} <- x = do
        g <- getST
        U.fatal (getpos x) (text ("genLambda: argument for " ++ nice pat g ++ " missing"))
    | otherwise = genStmts rm x binds

genLambda _ x _ _ = do
    g <- getST
    U.fatal (getpos x) (text ("genLambda: bad expression: " ++ nice x g))
{--
 * tell in which 'RMode' the case expression should best be computed to match pattern
 -}
patternRMode p = do
    g <- getST
    case p of
        PVar {uid,var} -> do
            v <- U.findV (Local uid var)
            if v.strsig.isStrict
                then case v.typ.rho of
                    RhoTau _ t -> do
                        b <- U.isJavaType t
                        stio (if b then RNative else RBoxed)
                    _ -> stio RBoxed
                else stio RLazy
        PAt {pos,uid,var,pat} -> do
            rm <- patternRMode pat
            if rm == RLazy then patternRMode (PVar {pos,uid,var}) else stio rm
        PStrict {pat} -> patternRMode pat
        PLit {pos} -> stio RNative
        PMat {pos} -> stio RNative
        PAnn {pat} -> patternRMode pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (T.productCon qname g) then stio RBoxed
                  else do
                    ps <- mapSt patternRMode pats
                    if all (RLazy==) ps then stio RLazy else stio RBoxed
        PConFS {pos} -> U.fatal pos (text ("patternRMode: found PConFS")) -- not allowed anymore at this time



{--
 * The code for case statements can and will be optimized in various ways.

 * First, if the case expression is of the form @Con x1 x2 ... xn@, we can avoid
 * actual construction of the value if all the patterns are of
 * the form @Con p1 p2 ... pn@ or @_@ or @v@ where v is not used on the right hand side.
 * Indeed, every definition of a function with multiple arguments and more than one
 * alternative
 * > fun p1a p1b p1c = alt1
 * > fun p2a p2b p2c = alt2
 * > ...
 * results in code like
 * > \_a\_b\_c -> case (_a, _b, _c) of
 * >    (p1a, p1b, p1c)  -> alt1
 * >    (p2a, p2b, p2c)  -> alt2
 * >    ...
 * so naive implementation would cause an extra tuple construction on every function
 * call - this tuple would be created just to get deconstructed right away.
 *
 * Second, if we know that the set of patterns covers all possibilities, we
 * can avoid if-statements on the last alternative. In addition, we do not need
 * to arrange for the case that the pattern is not matched.
 * Therefore, we have a sophisticated algorithm to find this out, see 'T.patsComplete'
 *
 * The generated java code looks like this:
 * >  compute case expression if needed
 * >  if (p1a matches) {
 * >    if (p1b matches) {
 * >        if (p1c matches) {
 * >            code for alternative1
 * >  }}} // fall through to next alternative
 * >  if (p2a matches) {
 * >        ... like above ...
 * >  }
 * >  ... yet more alternatives ....
 * >  throw new NoMatch("xy.fr", 345, case expression)
 -}
genCaseStmt rm (x@Case {ckind,ex=cex,alts=calts}) binds = do
        g <- getST
    -- case Con a b c  ... avoid actual creation of value unless a pattern is not
    -- itself a constructor application or a variable that is not referenced in its scope
        capp <- constrApp cex                      -- Just (Con, args) if this is Con a1 a2 ... an
        pats <- foldSt conUVarAlt true calts        -- true if all patterns are Con _ or _
        stri <- patternStrictness (head calts).pat -- strsig of 1st pattern
        rmex <- patternRMode (head calts).pat
        bcex <- genExpr false rmex cex binds              -- code for ordinary expression
        let makeBexs                                -- binds for cex or constr args
                | pats, Just (con, xs) <- capp = case stri of
                        S ss -> mapSt exStr (zip xs (ss ++ allLazy))
                        U    -> mapSt exStr (zip xs allLazy)
                | otherwise = stio [bcex]
        bexs <- makeBexs
        let con = if pats then maybe Nothing (Just • fst) capp else Nothing      -- constructor in case ex, if any
            complete
                | T.caseOtherwise g x = Nothing         -- case true of true -> ...
                | otherwise = T.patsComplete g (map CAlt.pat ralts)
            -- ralts are the alternatives that have no guard that could fail
            -- only the patterns of those alts are considered in deciding
            -- whether to throw exceptions or not
            -- walts are the alternatives that have an open case when
            (walts, ralts) = partitioned (isJust • T.openCaseWhen g • CAlt.ex) calts
            -- We will give a hint as to which guard is most likely
            -- causing trouble. If the patterns would be complete if there were
            -- no guards, then it is most likely the guard on an otherwise irrefutable
            -- pattern, if there is none, we assume it is the guard of the last alternative
            -- that has a guard.
            badguard = case T.patsComplete g (map CAlt.pat calts) of -- would it be complete
                Just _  -> Nothing       -- case could not be made safe by adding guards
                Nothing -> case filter (not • T.patternRefutable g • CAlt.pat) walts of
                    walt:_ -> T.openCaseWhen g walt.ex
                    []     -> case reverse walts of
                        walt:_ -> T.openCaseWhen g walt.ex
                        []     -> Nothing

            comment = sComment ("case  " ++ nice cex g ++ "  ... "
                        ++ (if ckind == CWhen then "(guard)" else ""))
            throw binds
                | ckind == CWhen  = stio []                     -- guards always fall through
                | Nothing <- con,
                  [bex1] <- binds = throwEx (toBoxed bex1)
                | otherwise       = throwEx (toBoxed bcex)      -- construct case ex for throw
            throwEx arg
                | isJust complete, Just (Left x) <- badguard = do
                    when (ckind != CNoWarn) do
                        U.warn (getpos x) (msgdoc ("guard (" ++ nicer x g ++ ") may evaluate to false."))
                    stio (jthrow arg)
                | isJust complete, Just (Right p) <- badguard = do
                    when (ckind != CNoWarn) do
                        U.warn (getpos p) (msgdoc ("pattern guard (" ++ nicer p g ++ ") may fail to match."))

                    stio (jthrow arg)
                | Just p <- complete = do
                    when (ckind != CNoWarn) do
                        U.warn (last calts).pat.getpos (msgdoc ("pattern match is not exhaustive, "
                                ++ "consider adding a case for  "
                                ++ nicer p g))
                    stio (jthrow arg)
                | otherwise = stio []                   -- no throw neeeded

            throwargs exb = map JAtom [show ((Prelude.last g.genEnv).name.nice g),
                                                show (getpos x)] ++ [Binding.jex exb]
            jthrow exb = [JThrow (JNew (Ref (JName "RT" "NoMatch") []) (throwargs exb))]

        (nbexs, code) <- genAlts complete binds [] con bexs calts    -- make alternatives
        jthrow <- throw nbexs                               -- make throw statement
        stio (comment : concat (reverse (jthrow:code)))

    where
        genAlts complete binds codes con bexs ((calt@CAlt {pat, ex}):alts) = do
            g <- getST
            let last = finalAlt g calt || null alts
            -- when = T.openCaseWhen g ex
                noif = last && isNothing complete
                poss = map (getpos • CAlt.pat)  alts
                unreachable p = U.warn p (text "equation or case alternative cannot be reached.")
            (codes, nbexs) <- genAlt noif binds codes con bexs calt
            if last
                then do
                    when (ckind != CNoWarn) do
                        foreach poss unreachable
                    stio (nbexs, codes)
                else genAlts complete binds codes con nbexs alts
        genAlts complete binds codes con bexs alts = error "genAlts: null alts"

        genAlt noif binds codes mbcon bexs (alt@CAlt {pat,ex})
            | Nothing  <- mbcon = do
                g <- getST
                (nbex, code) <- match noif pat (head bexs) (genStmts rm ex) binds
                stio ((altComm g:code):codes, [nbex])
            | Just con <- mbcon = do
                stri <- patternStrictness pat
                case pat of
                    PCon {qname} -> do
                        sym <- U.findD qname
                        if sym.sid == Symbol.sid con then do
                                let nbexs = case stri of
                                        S ss -> map bexStr (zip bexs (ss ++ allLazy))
                                        _    -> bexs
                                code <- matchCon noif pat con nbexs (genStmts rm ex) binds
                                g <- getST
                                stio ((altComm g:code):codes, nbexs)
                            else do
                                U.warn (getpos pat) (text "case alternative will never be taken")
                                stio ([]:codes, bexs)
                    _  -> do
                        g <- getST
                        -- uvar <- conUVarAlt true alt
                        -- if uvar then do
                        code <- genStmts rm ex binds
                        stio ((altComm g:code):codes, bexs)
            | otherwise = undefined
            where
                altComm g = sComment ("... of  " ++ nice pat g ++ " -> " ++ nicer ex g)


        exStr  (ex, stri)
            | Strictness.isStrict stri = genExpr false RNative ex binds
            | otherwise                = genExpr false RLazy   ex binds
        bexStr (bind, stri)
            | Strictness.isStrict stri = notLazy bind
            | otherwise = bind
            -- check if an expression is a constructor application
        constrApp (ex@App _ _ _) = case map fst (U.flatx ex) of
            Con {name}:xs -> do
                sym <- U.findD name
                if U.arity sym == length xs
                    then stio (Just (sym, xs))
                    else stio Nothing            -- for example:  case (,) a of mktuple -> mktuple b
            _ -> stio Nothing
        constrApp _ = stio Nothing      -- for example: let a = 1 in Just a
        -- check if a pattern is a constructor application or an unused variable
        conUVarAlt false _ = stio false
        conUVarAlt true (CAlt {pat = PCon {pos}}) = stio true
        conUVarAlt true (CAlt {pat = PVar {var,uid}, ex}) = do
            sym  <- U.findV (Local uid var)
            refs <- T.references [sym.sid] ex
            stio (refs == 0) 
        conUVarAlt _ _ = stio false
        -- check if there could match anything else after this alternative has matched
        finalAlt g (CAlt {pat,ex})
            | T.patternRefutable g pat = false
            | Just _ <- T.openCaseWhen g ex = false
            | otherwise = true
genCaseStmt rm nocase binds = error "genCaseStmt: no case"

{--
 * [usage] @genStmt rkind expression bindings@
 * [returns] A list of statements where the last one is a @return@
 *           or a @continue@ for a tailcall or a @throw@ from an
 *           incomplete case statement
 * This is called for return expressions only.
 -}
genStmts rm (x@Case {ckind,ex=cex,alts=calts}) binds = genCaseStmt rm x binds

genStmts rm (x@Let {env, ex}) binds = do
    case env of
        [k] -> do
            symv <- U.findV k
            case symv.expr of
                Just vx
                    | symv.depth == 0,
                      symv.strsig.isStrict,
                      symv.rkind `band` T.rkSimple != 0,
                      RhoTau [] t <- symv.typ.rho = genStmts rm (cas vx) binds
                    where
                        cas vx = Case CWhen vx [alt] x.typ
                        alt = CAlt {ex, pat = PVar symv.pos symv.name.uid symv.name.base}
                _ -> genLet rm x binds
        _ -> genLet rm x binds

genStmts rm (x@Let {env,ex}) binds = genLet rm x binds

genStmts rm (x@(Ifte c t e _)) binds {-| not (T.isSimple x) -} = do
        g <- getST
        cbnd <- genExpr false RNative c binds
        tstm <- genStmts rm t binds
        estm <- genStmts rm e binds
        stio [sComment (nicer x g), JCond "if" (strictBind cbnd).jex tstm, JBlockX "else" estm]


genStmts rm ex binds
    {- | T.isSimple ex -} = do                                -- return or tailcall
        g   <- getST
        case ex of
            App _ _ _
                | Vbl {name}:args <- map fst (U.flatx ex),
                  Just (sym@SymV {sid}) <- name.findit g,
                  sid == (head (g.genEnv)).sid,
                  length args == sym.depth = do
                        let ss = case sym.strsig of
                                    S ss -> ss ++ allLazy
                                    _    -> allLazy
                            asigs = snd (U.returnTypeN sym.depth sym.typ.rho)
                            argNames = drop (fold (+) 0 (map Symbol.depth (tail g.genEnv))) GenJava7.argNames
                        argmodes <- mapSt (uncurry argMode) (zip ss asigs)
                        abinds   <- mapSt (uncurry genEx)   (zip argmodes args)
                        let assigns = zipWith JAssign (map JAtom argNames) (map Binding.jex abinds)
                            comment = sComment ("tailcall  " ++ nicer ex g)
                        stio (comment:assigns ++ [JEx (JAtom "continue tailrecursion")])
                where
                    genEx arm aex = genExpr false arm aex binds
            _ = do
                bnd <- genExpr true rm ex binds
                stio [sComment ("return " ++ show rm ++ "  " ++ nicer ex g),
                        sComment (nice bnd g),
                        JReturn bnd.jex]

{- genStmts rm ex binds = do
        g <- getST
        stio [JError ("code for " ++ nicer ex g)] -}

genLet rm (x@Let {env,ex}) binds = do
        g <- getST
        syms <- mapSt U.findV env
        (nbinds, stmtss) <- foldSt localdef (binds, []) syms
        stmts <- genStmts rm ex nbinds
        stio (comment g : ((map JLocal • concat • reverse) stmtss ++ stmts))
    where
        comment g = sComment (nicer x g)
        localdef (binds, codes) sym = do
            g <- getST
            jt <- sigmaJT (Symbol.typ sym)
            let isClass = sym.depth > 0 -- && not (null sym.typ.bound)
                mode = if isClass       then RNative
                        else if Symbol.rkind sym `band` 1 == 0 then RLazy else RBoxed
                fjt  = if isClass       then Nativ "Lambda42" [] else jt
                bjt  = if mode == RLazy then lazy fjt            else fjt
                name = (U.javaName g sym.name).base
                bind = Bind mode sym.typ bjt (JAtom name)
                nbinds = insert binds sym bind
            code <- symCode nbinds sym
            stio (nbinds, code:codes)
genLet _ ex binds = do
    g <- getST
    U.fatal (getpos ex) (text("genLet: not a let  " ++ nice ex g))


impliesG g (Ctx _ d t1 _) (Ctx _ c t2 _) = U.isSuper c g d && sameTau t1 t2

envCtxs g = [ ctx | s <- reverse (Global.genEnv g),
                                    not (null (Symbol.typ s).bound),
                                    ctx <- (Symbol.typ s).rho.context ]

resolveConstraint pos (ctx@Ctx {cname, tau}) = do
        g <- getST
        -- ctx <- TC.reducedCtx ctx
        U.logmsg TRACEG (U.tauPos tau) (text (U.nicerctx [ctx] g))
        if make then makeCtx else findCtx
    where
        tauflat = tau.flat
        tcon  = head tauflat {- case head tauflat of
            TFun _ _ -> TCon {pos = Position.null, name = TName pPreludeBase "->"}  -- functions
            con      -> con -}
            
        -- targs = tail tauflat
        make | TCon {name} <- tcon = true
             | otherwise = false

        findCtx | Meta tv <- tau, tv.isFlexi = do
                        g <- getST
                        U.fatal pos (text ("unknwon context: " ++ nice cname g ++ " " ++ nice tau g))
                        stio (JAtom "null")
                | otherwise = do
            g <- getST
            let
                ctxsnms = zip (envCtxs g) ctxNames
                implies = impliesG g
            U.logmsg TRACEG pos (text ("findCtx: looking for  " ++ nice cname g ++ " " ++ nice tau g))
            U.logmsg TRACEG pos (text ("findCtx: we have  " ++ U.nicectx (envCtxs g) g))
            let ok = [ name | (ctx1, name) <- ctxsnms, ctx1 `implies` ctx]
            U.logmsg TRACEG pos (text ("findCtx: ok= " ++ show ok))
            if (null ok)
                then U.fatal pos (text ("Cant find context for " ++ nice cname g ++ " " ++ nice tau g))
                else stio ((JAtom • head) ok)
        makeCtx  = do
            csym <- U.findC cname
            case tcon of
                TCon {name} -> case filter ((name ==) • fst) csym.insts of
                    (_,iname):_ -> do
                        inst <- U.findI iname
                        g <- getST
                        let crho = RhoTau [] tau
                            csig = ForAll [] crho
                        U.logmsg TRACEG pos (text ("makeCtx: unify " ++ nice inst.typ g ++ "  with  "
                                ++ nice csig g))

                        let tree = U.unifySigma g inst.typ csig
                        rho  <-  U.substRho tree inst.typ.rho
                        -- rhojt <- rhoJT rho
                        U.logmsg TRACEG pos (text ("makeCtx substituted: " ++ nice rho g))
                        subctx <- mapSt TC.reducedCtx  rho.context
                        args <- mapSt (resolveConstraint pos) subctx
                        let jiname = U.javaName g inst.name
                            -- jrho   = rhoJT g rho
                            -- jitargs0 = [ RhoTau [] t
                            --                 | v <- inst.typ.bound, t <- (tree.lookupS v).toList]
                        --  jitargs = if csym.vkind > 0 then rho : jitargs0 else jitargs0
                        -- jitjts     <- mapSt rhoJT jitargs
                        let jit    = Ref jiname []              -- jitjts
                            jex    = {- if null subctx
                                then JInvoke (JStMem (U.memberOf jiname "ƒNew") jitjts) []
                                else -} JNew jit args
                        U.logmsg TRACEG pos (text ("makeCtx: " ++ showJex jex))
                        stio jex
                    [] -> do
                        g <- getST
                        U.fatal pos (text ("makeCtx: instance " ++ nice cname g ++ " " ++ nice tau g ++ " not found."))
                other -> do
                    g <- getST
                    U.fatal pos (text ("makeCtx: head is " ++ nice other g))

instSymDirect :: Position -> Symbol -> Sigma -> StG (Binding)
instSymDirect pos sym sigma = do
    g <- getST
    U.logmsg TRACEG pos (text ("instSymDirect: "
                            ++ nice sym g ++ "::" ++ nice sym.typ g
                            ++ " at " ++ nice sigma g))

    let inst = U.sigmaInst g sym.typ sigma
        -- jname = U.javaName g sym.name


    gargs    <- mapSt tauJT inst
    U.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    jt       <- sigmaJT sigma

    let str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
    strho    <- U.substRho (U.unifySigma g sym.typ sigma) str
    U.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    contexts <- mapSt  TC.reducedCtx  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts

    case sym of
        SymD {name=MName tynm _, flds} | null ctxs = do
            -- let mkn = "mk"
            symt <- U.findT tynm
            if symt.enum
                then stio (Bind RBoxed sigma jtInt (JX.static (workerMethod g sym)))
                else if symt.newt
                    then do
                        sym <- U.findV (VName pPreludeBase "id")
                        instSymDirect pos sym sigma
                    else stio (Bind RBoxed sigma jt (JX.static (workerMethod g sym)))
        SymV {name = Local {}, expr = Just _} = U.fatal sym.pos (text ("instSymDirect: " ++ nicer sym g))
        SymV {name, depth, rkind}
            | null ctxs = do
                let wm   = workerMethod g sym
                stio (Bind RBoxed sigma jt (JX.static wm))
            | otherwise = do
                let instx = (JX.invoke ctxs • JX.static)
                                  (workerMethod g sym)
                stio (Bind RBoxed sigma jt instx)
        other -> U.fatal pos (text ("Can't instSymDirect " ++ nice sym g))

{--
 * instantiate a symbol at a given type
 -}
instSym :: Position -> Symbol -> Sigma -> StG Binding
instSym pos sym sigma = do
    g <- getST
    U.logmsg TRACEG pos (text ("instSym: "
                            ++ nice sym g ++ "::" ++ nice sym.typ g
                            ++ " at " ++ nice sigma g))

    let inst = U.sigmaInst g sym.typ sigma
        -- jname = U.javaName g sym.name


    gargs    <- mapSt tauJT inst
    U.logmsg TRACEG pos (text ("instSym: gargs = " ++ show (map (flip nice g) inst)))
    jt       <- sigmaJT sigma

    let str | Local {} <- sym.name, null sym.typ.bound = sym.typ.rho.{context = []}
            | otherwise = sym.typ.rho
    strho    <- U.substRho (U.unifySigma g sym.typ sigma) str
    U.logmsg TRACEG pos (text ("instSym: strho = " ++ nice strho g))
    contexts <- mapSt  TC.reducedCtx  strho.context
    ctxs     <- mapSt (resolveConstraint pos) contexts

    let (_, ss) = U.returnType sym.typ.rho

    case sym of
        SymD {name=MName tynm _, flds} | null ctxs = do
            let mkOrEnum = JX.static (workerMethod g sym)
            symt <- U.findT tynm
            if symt.enum
                then stio (Bind RBoxed sigma jtInt mkOrEnum)
                else if symt.newt
                    then do
                        sym <- U.findV (VName pPreludeBase "id")
                        instSym pos sym sigma
                    else if length flds == 0
                            then do
                                let jx = JX.invoke [] mkOrEnum
                                    bind = Bind RBoxed sigma jt jx
                                stio bind
                            else reqLam sym 
        SymV {name = MName clas m, depth, rkind} | Just (SymC {vkind,tau}) <- clas.findit g = do
                g <- getST
                U.logmsg TRACEG pos (text ("instSym: " ++ m ++ " depth=" ++
                        show depth ++ ", vkind=" ++ show vkind))
                let inst   = JInvoke get (tail ctxs)
                    get    = JExMem  (head ctxs) (latinF ++ mangled m)
                    mode   = if depth > 0
                                then RBoxed         -- function
                                else RLazy          -- by def in abstractFun
                stio (Bind mode sigma jt inst)
        SymV {name, depth = 0, rkind} -> do
                let
                    mode = if rkind `band` 1 == 0 then RLazy else RBoxed
                    item = JX.static (workerMethod g sym)
                    func | null ctxs = item
                         | otherwise = JX.invoke ctxs item
                    bind = Bind mode sigma jt func
                stio bind
        SymV {name, depth, rkind} = do
            bind <- reqLam sym
            if null ctxs then return bind
                else return bind.{jex <- JX.invoke ctxs}
            -- | Just wc <- wrapperClass g sym = do
            --     let instx = (JX.invoke ctxs • JX.static) (wrapperInstance g sym)
            --     stio (Bind RBoxed sigma jt instx)
            -- | null ctxs = reqLam sym -- do
                -- let wm   = wrapperInstance g sym
                -- stio (Bind RBoxed sigma jt (JX.static wm))
        other -> U.fatal pos (text ("Can't instSym " ++ nice sym g))


apply :: Binding -> Binding -> StG Binding
apply x b = do
    g <- getST
    U.logmsg TRACEG Position.null
         (text("apply: " ++ nice x g ++ "  to:  " ++ nice b g))
    -- U.logmsg TRACEG sym.pos (anno vbind.jex)
    let ns = notStrict b
        xe = notLazy (notStrict x)
    xf <- coerce xe.{ftype = ForAll [] (RhoFun [] (ForAll [] TY.rhoBool) (TY.rhoBool))}
    stio x.{mode=RLazy, jtype=lazy jtValue, jex=JInvoke (JExMem xf.jex "apply") [ns.jex]}

{--
 * [usage] @genExpr rflag rmode expression binds@
 * [return] a binding that computes the frege expression in the desired 'RMode'
 * If the @rflag@ is true, special handling occurs for lazy calls: The arguments
 * of that tailcall are computed according to the strictness information of the
 * called function instead of all lazy. This is an optimization appropriate for
 * tail calls.
 -}
genExpr :: Bool -> RMode -> Expr -> Tree Symbol Binding -> StG Binding
genExpr _ rm (Vbl {pos, name, typ = Just sigma}) binds
    | Local{} <- name = do
        sym <- U.findV name
        case lookup binds sym of
            Just b = stio (toMode rm b)
            Nothing | Just _ <- sym.expr -- , sym.anno, length sym.typ.rho.context > 0
                = instSym sym.pos sym sigma
            Nothing -> do
                g <- getST
                U.error pos (msgdoc ("genExpr: " ++ nice sym g ++ " not bound"))
                sjt      <- sigmaJT sigma
                stio (Bind rm sym.typ sjt (JAtom ("UNBOUND." ++ name.base)))
    | otherwise = do
        sym <- U.findV name
        bind <- instSym pos sym sigma
        stio (toMode rm bind)

genExpr _ rm (Con {pos, name, typ = Just sigma}) binds = do
    sym <- U.findD name
    bind <- instSym pos sym sigma
    stio (toMode rm bind)

genExpr _ rm (Lit {kind = LBool, value, typ = Just sigma}) binds
    | rm != RNative, value == "true"   =  stio (Bind RBoxed  sigma bool t)
    | rm != RNative, value == "false"  =  stio (Bind RBoxed  sigma bool f)
    where
        bool = Ref (JName "" "Box.Bool") []
        t = JStMem (U.memberOf bool.jname "t") []
        f = JStMem (U.memberOf bool.jname "f") []


genExpr _ RNative (Lit {kind, value, typ = Just sigma}) binds
    | kind != LRegex && kind != LBig = do
        jt <- sigmaJT sigma
        let v
                | kind `elem` [LInt, LLong, LDouble, LFloat] = (#_#.matcher value).replaceAll ""
                | otherwise = value
        stio (Bind RNative sigma (strict jt) (JAtom v))

genExpr _ rm (x@Lit {kind,value,typ=Just sigma}) binds = do
    jname <- findConst x
    jt    <- sigmaJT sigma
    let bind = Bind RBoxed sigma jt (JStMem jname [])   -- genExpr RNative x binds
    stio (toMode rm bind)

genExpr rflg rm (app@App a b (Just sigma)) binds = do
        g <- getST
        let flat  = map fst (U.flatx app)
            fun   = head flat
            args  = tail flat
        genApp rm binds fun args
    where
        genEx arm aex = genExpr false arm aex binds
        genApp rm binds (con@Con {pos, name, typ = Just csigma}) args = do
            sym <- U.findD name
            let a = length sym.flds
                (_, asigs) = U.returnTypeN a sym.typ.rho
            if length args < a
                then genAnon rm binds con args          -- partial application
                else do
                    symt <- U.findT name.tynm
                    if symt.product && symt.newt
                        then genExpr rflg rm (head args) binds
                        else do
                            let islazy = rm == RLazy && !rflg
                                struct = sym.strsig.isStrict
                            sjt   <- sigmaJT sigma
                            aargs = take a args
                            rargs = drop a args
                            sss = if islazy then allLazy
                                        else case sym.strsig of
                                            S ss -> ss
                                            U    -> allLazy
                            amodes <- mapSt (uncurry argMode) (zip sss asigs)
                            abinds <- mapSt (uncurry genEx)   (zip amodes aargs) -- mapSt (flip (genExpr false RLazy) binds) aargs
                            rbinds <- mapSt (flip (genExpr false RLazy) binds) rargs
                            let result call
                                    | null rargs = stio call
                                    | otherwise  = do
                                            -- sjt <- sigmaJT sigma
                                            r <- foldSt apply call rbinds
                                            let b = Bind RLazy sigma (lazy sjt) r.jex
                                            stio (toMode rm b)
                            if struct && islazy
                                then do
                                    dbind <- instSym pos sym csigma
                                    let jx = JX.xmem "apply" dbind.jex
                                        call = Bind RBoxed sigma sjt (JInvoke jx (map Binding.jex abinds))
                                    result call
                                else do
                                    dbind <- instSymDirect pos sym csigma
                                    let jx = dbind.jex
                                        call = Bind RBoxed sigma sjt (JInvoke jx (map Binding.jex abinds))
                                    result call

        genApp rm binds (vbl@Vbl {pos, name, typ = Just vsigma}) args = do
                g     <- getST
                sym   <- U.findV name
                let d = ari sym
                if d < 1 || d > length args
                    then genAnon rm binds vbl args
                    else case sym.name of
                        MName cname _
                            | Just (SymC {sid}) <- cname.findit g = genAnon rm binds vbl args
                        noclassmember -> case sym.nativ of
                            Just _    -> do
                                        cenum <- isConstructorEnum sym vsigma
                                        if cenum && length args == 1
                                            then genExpr rflg rm (head args) binds
                                            else genNative sym --genAnon rm binds vbl args
                            nonnative ->
                                if tailcall && (sym.rkind `band` T.rkSafeTC) != 0
                                    then genApp RBoxed binds vbl args
                                    else genDirect sym
            where
                isConstructorEnum (SymV {name=VName pp1 "constructor"})
                    (ForAll [] (RhoFun []
                        (ForAll [] (RhoTau [] (TCon {name})))
                        (RhoTau [] (TCon {name=TName pp2 "Int"}))
                    ))
                    | pp1 == pPreludeBase, pp2 == pPreludeBase = do
                        symt <- U.findT name
                        stio symt.enum
                isConstructorEnum _ _ = stio false
                ari (sym@SymV {nativ=Just _}) = U.arity sym
                ari sym                       = sym.depth
                tailcall = rflg && rm == RLazy
                -- safetailcall = tailcall
                -- genEx arm aex = genExpr false arm aex binds


                genNative sym = do
                    -- vbind <- funBind sym
                    let acall = rm == RLazy && not tailcall
                        wcall = not acall && (wrappedOnly sym || not (null sym.typ.bound))
                        (atau, asigs) = U.returnType (Symbol.typ sym).rho
                        depth         = ari sym
                        aargs         = take depth args
                        rargs         = drop depth args
                        sss           = case Symbol.strsig sym of
                                S ss -> ss ++ allLazy
                                U    -> allLazy
                    if acall || wcall then genDirect sym
                        else do
                            sjt   <- sigmaJT sigma
                            ajt   <- tauJT atau
                            let rjt   = strict  ajt
                                cmode = maxStrict rjt
                            amodes   <- mapSt (uncurry argMode) (zip sss asigs)
                            abinds   <- mapSt (uncurry genEx)   (zip amodes aargs)
                            rbinds   <- mapSt (flip (genExpr false RLazy) binds) rargs
                            call     <- if wrapped sym
                                then do
                                    code <- wrapCode JEx atau sym abinds
                                    case head code of
                                        JEx ex -> stio (Bind cmode sigma rjt ex)
                                        _ -> error "unexpected wrapCode result"
                                else nativeCall sym abinds

                            let result
                                    | null rargs = do
                                        raw <- coerce call
                                        stio (toMode rm raw)
                                    | otherwise  = do
                                            r     <- foldSt apply call rbinds
                                            let b = Bind RLazy sigma (lazy jtValue) r.jex
                                            raw <- coerce b
                                            stio (toMode rm b)
                            result
                genDirect :: Symbol -> StG Binding
                genDirect sym = do
                    g <- getST
                    let callLazy = (rm == RLazy && not tailcall || sym.rkind `band` T.rkSafeTC == 0)
                    case lookup binds sym of
                        Just (b@Bind{mode=RNative, jtype=Nativ #^L(am(bda)?)?\d+$# _})
                            | callLazy  = genStraight sym b.{jex <- JX.xmem "apply"}
                            | otherwise = genStraight sym b.{jex <- JX.xmem (workName g sym)}
                        Just b -> genAnon rm binds vbl args
                        Nothing
                            | callLazy = do
                                bcall <- instSym pos sym vsigma
                                genStraight sym bcall.{jex <- JX.xmem "apply"}
                            | otherwise  = do
                                bcall <- instSymDirect pos sym vsigma
                                genStraight sym bcall
                genStraight :: Symbol -> Binding -> StG Binding
                genStraight sym vbind = do
                    g <- getST
                    U.logmsg TRACEG sym.pos (text("genStraight: " ++ nice sym g ++ " as " ++ nice vbind g))
                    U.logmsg TRACEG sym.pos (anno vbind.jex)
                    let jx = vbind.jex
                        (ctxs, static) = case jx of
                            JInvoke x xs  -> (xs, x)
                            x             -> ([], x)
                        aew = case static of
                            JExMem {name} -> Just name
                            _             -> Nothing
                        callLazy = (rm == RLazy && not tailcall || sym.rkind `band` T.rkSafeTC == 0)
                        rev = aew == Just "eval"
                        rr xs = if rev then reverse xs else xs
                    sjt   <- sigmaJT sigma
                    let depth = ari sym
                        (arho, asigs) = U.returnTypeN depth sym.typ.rho
                    symjt  <- rhoJT arho
                    let aargs = take depth args
                        rargs = drop depth args
                        sss = if callLazy then allLazy else case sym.strsig of
                                S ss -> ss ++  allLazy
                                U    -> allLazy
                        cmode = if callLazy || aew == Just "apply" then RLazy
                                else if rev then rmode sym.rkind
                                else             wmode sym.rkind
                        rjt | cmode == RLazy   = lazy symjt
                            | cmode == RNative = strict symjt
                            | otherwise        = boxed symjt
                    amodes   <- mapSt (uncurry argMode) (zip sss asigs)
                    let argmodes = if rev then map tcmode amodes else amodes
                        tcmode RNative = RBoxed
                        tcmode r       = r
                    abinds   <- mapSt (uncurry genEx)   (zip argmodes aargs)
                    rbinds   <- mapSt (flip (genExpr false RLazy) binds) rargs
                    let call = Bind cmode sigma rjt (JInvoke static (ctxs ++ map Binding.jex (rr abinds)))
                        result
                            | null rargs = do
                                    raw <- coerce call
                                    stio (toMode rm raw)
                            | otherwise  = do
                                    let jt =  rmodeJt cmode jtValue
                                    r      <- foldSt apply call.{jtype=jt} rbinds
                                    let b  =  Bind RLazy sigma (lazy jtValue) r.jex
                                    raw    <- coerce b
                                    stio   (toMode rm raw)
                    result


        genApp rm binds fun args = genAnon rm binds fun args

        genAnon rm binds fun args = do
            fbind  <-   genExpr false RBoxed fun binds
            abinds <-   mapSt (flip (genExpr false RLazy) binds) args
            -- sjt    <-   sigmaJT sigma
            appl   <- foldSt apply fbind abinds
            let raw    = Bind RLazy sigma (lazy jtValue) appl.jex
            result <- coerce raw
            stio (toMode rm result)



genExpr rflg RLazy (ifte@Ifte c t e (Just sigma)) binds = do
    g     <- getST
    jt    <- sigmaJT sigma
    cbind <- genExpr false RLazy c binds
    tbind <- genExpr false RLazy t binds
    ebind <- genExpr false RLazy e binds

    let lif = VName pPreludeBase "lazyif"
    isym  <- U.findV lif
    ibind <- instSym (getpos ifte) isym isym.typ

    let rrho = U.tauRho sigma.rho
    rjt  <- rhoJT rrho

    let res = ibind.{jex <- JX.invoke (map (Binding.jex • notStrict) [cbind, tbind, ebind])
                          • JX.xmem "apply"}
    stio res.{mode=RLazy, ftype=sigma, jtype=lazy rjt}

genExpr _ rm (ifte@Ifte c t e (Just sigma)) binds = do
    -- g <- getST
    cbind <- genExpr false RNative c binds
    tbind <- genExpr false rm      t binds
    ebind <- genExpr false rm      e binds
    stio (toMode rm (Bind (jtRmode (Binding.jtype tbind)) sigma (Binding.jtype tbind) (JQC cbind.jex tbind.jex ebind.jex)))

genExpr _ rm (lam@Lam{}) binds = lambdaEx lam binds

genExpr _ rm ex binds = do
    g <- getST
    let ft = unJust (Expr.typ ex)
    U.fatal (getpos ex) (text ("Cannot genExpr: " ++ nicer ex g ++ " :: " ++ nicer ft g))
