{- «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»

    Copyright © 2011, Ingo Wechsung
    All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, are permitted provided that the following
    conditions are met:

        Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

        Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution. Neither the name of the copyright holder
        nor the names of its contributors may be used to endorse or
        promote products derived from this software without specific
        prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
    OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
    USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
    THE POSSIBILITY OF SUCH DAMAGE.

    «•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•»«•» -}

{--
 * This package deals with various transformations.
 * In compiler pass 7, we unroll let definitions like so:
 * > let a = ex1; b = ex2 in ex3  ==> let a = ex1 in let b = ex2 in ex3
 * provided /ex2/ does not reference /a/.
 -}


package frege.compiler.Transform where


import frege.List (Tree, lookup, insert, insertkv, update, keys, values, each,
                    fromKeys, including, contains, union, isEmpty)
import Data.List as DL(uniq, sort, partitioned, elemBy)
                    
import frege.compiler.Data
import frege.compiler.Nice except (group, break)
import frege.compiler.Utilities     as U(allourvars, allvars)
import frege.compiler.Typecheck     as TC(checkRho, substInst, zonkExpr)
import frege.compiler.TCUtil        as TCU()

post = stio true

pass7 = do
    g <- getST

    -- unroll let expressions
    let collectedvars = allourvars g
    foreach collectedvars unrollSym

    -- simplify let expressions by lifting local function bindings to the top
    -- or inlining variables
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars unLetSym

    stio ("expressions", 2 * length collectedvars)

--- actually, this runs after 'pass9' and before 'pass10'
pass8 = do
    g <- getST

    -- find closed lambdas and make them private global functions
    let collectedvars = allourvars g 
    foreach collectedvars closedLambdaSym
    stio ("expressions", length collectedvars)



{--
 * Strictness analysis
 *
 * - native functions are strict in all arguments
 * - constructors are lazy in all arguments (but we can adapt this later if the need arises)
 * - every symbol will get a strictness signature and status StrictChecked
 -}
pass10 = do
        g <- getST
        let ourvars = allourvars g
        names <- mapSt U.fundep ourvars

        let groups = U.tsort names

        g <- getST
        U.logmsg TRACES Position.null (text ("names: " ++ joined " " (map (flip QName.nice g • fst) names)))
        U.logmsg TRACES Position.null (text ("groups: " ++ display (map (map (flip QName.nice g)) groups)))

        foreach groups checkgroup
        
        -- bring default class methods in good shape
        g <- getST
        let classmethods = [ sym | SymC{env} <- values g.thisTab, sym@SymV{expr = Just _} <- values env ]
        foreach classmethods easyClassMethodSym 

        stio ("functions", length names)
    where
        -- checkgroup :: [QName] -> StG ()
        checkgroup nms = do
            foreach nms (strictName [])         -- compute strictness
            returnNames [] nms                  -- compute return type of java methods

{--
 * In this pass, we make sure that all expressions are in
 * a form we need for code generation. We say that an expression is, or is not /easy/.
 *
 * - Every simple expression is also easy.
 * - A literal is simple.
 * - A variable is simple.
 * - A constructor name is simple.
 * - @(x::t)@ has the same properties as @x@
 * - @if a then b else c@ is easy if @b@ and @c@ are easy and @a@ is simple.
 *   If @b@ and @c@ are also simple, then the whole expression is simple.
 * - @a b@ is simple if @a@ and @b@ are both simple. Otherwise the application is
 *   not easy.
 * - @let v = x in e@ is easy, if @x@ is simple and @e@ is easy.
 * - @\p -> x@ is simple, if @x@ is easy
 * - @case x of { p1 -> a1; ...; pn -> an }@ is easy if @x@ is simple and
 *   all alternatives @a1@ ... @an@ are easy.
 *
 * An example for an expression that is not easy would be 
 * > f (case x of p -> e)
 * This is because
 * for an application to be easy, all subexpressions must be simple, 
 * and a case expression can only be easy, but never simple.
 *
 * It can be seen, that an arbitrary expression can be made easy if there is
 * a way to make any expression simple.
 * The latter is indeed possible, because for any expression /x/ 
 * > (\_ -> ex) C
 * is simple, where /ex/ is an easy version of /x/. Together with the
 * observation, that to make an expression easy, only /strictly smaller/
 * expressions need to be made simple (and easy), 
 * which guarantees progress and termination, the proof is complete.

 * This pass should run before strictness analysis so that local definitions
 * we need to introduce get strictness info.
 -}
pass9 = do
    g <- getST
    -- set lambdadepth for each symbol
    let collectedvars = allourvars g
    foreach collectedvars depthSym
    -- make all expressions easy
    g <- getST
    let collectedvars = allourvars g
    foreach collectedvars easySym
    
    stio ("expressions", length collectedvars)

easySym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- easyExpression x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
easySym sym = do
    g <- getST
    U.fatal sym.pos (text ("easySym no SymV : " ++ sym.nice g))

{--
    All default class methods must be exported, so instances can derive their own version.
    Not all expressions can be exported.
    In particular they can't if at least one
    of the following applies:
    - a lambda contains a pattern that is refutable
    - a case contains a set of patterns that is refutable
    - it references a private item because this would not resolve when the code is imported
    - it contains a let or where, because the metadata does not know lets (often, lets in
      the source code are transformed to a case, or it's dropped).
    
    To nevertheless being able to export such a class method, the complicated code is moved
    to a new top level function, and the class will only contain an application of this new
    function to the arguments.
    > method a b = let c = b+1 in a c
    transforms to:
    > anon a b = let c = b+1 in a c
    > method a' b' = anon a' b'   
    -}
easyClassMethodSym :: Symbol -> StG ()
easyClassMethodSym (sym@SymV{expr = Just x, typ}) = do
        easy <- goodClassMethod x
        unless ( easy && RSafeTC `member` sym.rkind && not (RTailRec `member` sym.rkind)) do
            g <- getST
            U.warn sym.pos (text (nice sym g
                ++ (if easy then "" else " is not easy enough ") 
                ++ (if RSafeTC  `member` sym.rkind  then "" else " recurses deeply ")
                ++ (if RTailRec `member` sym.rkind  then " is tail recursive " else "")))
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            
            nx <- replName sym.sid name x
            
            let anon = sym.{sid=0, name, vis = Protected, expr = Just nx}
                vbl = Vbl{name, pos=anon.pos.change VARID name.base, typ=Just (ForAll [] sym.typ.rho)}
                rk = (sym.rkind.unionE RSafeTC).differenceE RTailRec
            U.enter anon  
            x <- etaExpand vbl
            U.changeSym sym.{expr = Just x, rkind = rk}
    where
        -- goodClassMethod :: Expr -> StG Bool
        goodClassMethod x = do
            g <- getST
            -- l <- return sym.depth
            case x of
                Ann{} -> goodClassMethod x.ex
                App{} -> liftM2 (&&) (goodClassMethod x.fun) (goodClassMethod x.arg)
                Vbl{name=Local{}} -> return true
                Vbl{name} -> do
                    vsym <- U.findV name
                    return (vsym.vis != Private)
                Con{name} -> return true        -- constructors always exported
                Case{} -> do
                    g <- getST
                    let pok = if x.ckind == CWhen
                            then isNothing (openCaseWhen g x) 
                            else isNothing (patsComplete g (map CAlt.pat x.alts))
                    if pok then do
                        eok <- mapM goodClassMethod (map CAlt.ex x.alts)
                        return (and eok)
                    else return false                    
                Lam{pat,ex}   -> do
                    g <- getST
                    case patsComplete g [pat] of
                        Just _  -> return false      -- incomplete pattern
                        nothing -> goodClassMethod ex
                Ifte{}  -> do
                    c <- goodClassMethod x.cnd
                    if c then 
                        liftM2 (&&) (goodClassMethod x.thn) (goodClassMethod x.els)
                    else return false                        
                Lit{}   -> return true
                Let{}   -> return false     -- not allowed
                ConFS{} -> return false     -- may not happen
                Mem{}   -> return false     -- may not happen 
easyClassMethodSym sym = return ()


depthSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- depthExpr x
        let depth = U.lambdaDepth nx
        when (depth > length sigmas) do
                g <- getST
                U.error vsym.pos (msgdoc (nice vsym.name g
                    ++ ": the expression " ++ nicer nx g
                    ++ " has more nested lambdas (" ++ show depth 
                    ++ ") than permitted by the arity (" ++ show (length sigmas)
                    ++ ") of its type " ++ nicer typ g))
                U.hint vsym.pos (msgdoc ("This is probably a compiler error."))
        if (depth >= length sigmas)
            then U.changeSym vsym.{expr = Just nx, typ, depth}       -- fine, unless error
            else do
                g <- getST                                      -- depth < sigmas, eta expand it
                newx <- etaExpand nx
                let newd = U.lambdaDepth newx
                U.logmsg TRACE9 (vsym.pos) (text ("eta expanded "
                    ++ nice vsym.name g ++ "::" ++ nice typ g
                    ++ " to lambda depth " ++ show newd))
                U.logmsg TRACE9 vsym.pos (text ("old expr: " ++ nice nx   g ++ " :: "
                        ++ maybe "nix" (flip nice g) nx.typ))
                U.logmsg TRACE9 vsym.pos (text ("new expr: " ++ nice newx g
                        ++ " :: " ++ maybe "nix" (flip nice g) nx.typ))
                U.changeSym vsym.{expr = Just newx, typ, depth = newd}
                when (newd != (length sigmas)) do
                    U.fatal vsym.pos (text (nice vsym g ++ ": after eta expansion depth="
                        ++ show newd ++ ", length sigmas=" ++ show (length sigmas)
                        ++", turn on -x9")) 
    | otherwise = U.changeSym vsym.{depth = length sigmas}
    where
        typ = vsym.typ.{rho <- U.unTau} -- a -> (b->c)  -->  a -> b -> c
        (_, sigmas) = U.returnType typ.rho
        depthExpr = U.mapEx false depthX
        depthX  x
            | Let {env} <- x = do
                syms <- mapSt U.findV env
                foreach syms depthSym
                stio (Left x)
            | otherwise = stio (Left x)


depthSym sym = do
    g <- getST
    U.fatal sym.pos (text ("depthSym no SymV : " ++ sym.nice g))

{--
    Eta expansion, applied to a value @x@ with function type
    yields another expression @\\n -> x n@ with the same type.

    This is done as long as the lambda body has still function type.

    This will remove points free stype from definitions like

    > sum = fold (+) 0

    and will turn it into

    > sum n = fold (+) 0 n

    thus promoting fully satisfied applications as often as possible.

    Eta expansion must be done after type check and should be done before strictness check.
-}
etaExpand :: Expr -> StG Expr

etaExpand (lam@Lam {}) = do                 -- eta (\a -> x) = \a -> eta x
            nex <- etaExpand lam.ex
            stio lam.{ex=nex}

etaExpand (x@Ann {}) = do                   -- eta (x :: y) = (eta x :: y)
            nex <- etaExpand x.ex
            stio x.{ex=nex}

etaExpand x = case x.typ of                 -- all other expressions
    Just (ForAll [] (RhoTau ctx tau))
        | Just (farg, fret) <- tau.getFun = do
            uniq <- U.uniqid
            let var = "η" ++ show uniq
                pos  = (getpos x).change VARID var
                arg = ForAll [] (RhoTau [] farg)
                res = RhoTau [] fret
                sym = U.patLocal pos uniq var
                app = App x (Vbl {pos, name=sym.name, typ = Just arg}) (Just (ForAll [] res))
                pat = PVar {pos=pos, uid=uniq, var}
                -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=uniq}
            U.enter sym.{state=Typechecked, typ=arg}
            body <- etaExpand app
            stio  Lam {pat, ex=body, typ = Just (ForAll [] (RhoFun ctx arg res))}
        | otherwise = stio x
    Just (ForAll [] (RhoFun ctx arg res)) = do
            uniq <- U.uniqid
            let pos = (getpos x).change VARID name
                name = "η" ++ show uniq
                pat = PVar{pos=getpos x, uid=uniq, var=name}
                sym = U.patLocal pos uniq name
                app = App x (Vbl {pos, name=sym.name, typ = Just arg}) (Just (ForAll [] res))
            -- sym <- U.mkLocal pat
            U.enter sym.{state=Typechecked, typ=arg}
            body <- etaExpand app
            stio  Lam {pat, ex=body, typ = x.typ}

    Just sig = do
        g <- getST
        U.warn (getpos x) (msgdoc ("can't do eta expansion for an expression of type " ++ nice sig g))
        U.hint (getpos x) (msgdoc ("try to write the surrounding binding in a eta expanded form"))
        stio x
    Nothing -> do
        g <- getST
        U.fatal (getpos x) (msgdoc ("eta expansion must be done after type check for "
             ++ nice x g))
        stio x


{--
 * [usage] @returnKind group symbol@
 * [computes] the return type (lazy=0, boxed=1) of the r-Method, and, if a w-Method is needed,
 * the return kind of the w-Method (none, lazy=2, boxed=4, strict=6)
 *
 * - non nullary Constructors have implicitely 1101 (boxed mk-Method, boxed r-Method)
 *   and are safe tail calls (as they return immediately with the new object)
 * - Native methods have 5 or 7 (the native method *is* the w method, and if the return type
 *   is a java type, then it is 7, otherwise 5 (Maybe, Either or ST s/IO). They make also
 *   safe tail calls.
 * - if functions with constraints have a w-Method, this will be an instance method,
 *   otherwise a static one.
 * - a function with a strict argument gets a w-Method
 * - a CAF (lambdadepth = 0) will have no w-Method. The rkind will show if the CAF is
 *   declared with a lazy type or not. The bit 16 is on if the expression is simple
 *   and no self references or possibly forward references exist.
 *   Forward references can appear in global symbols which reference any global
 *   value from this package.
 -}
returnKind syms (sym@SymV {nativ = Just _}) = do
        g <- getST
        -- jt <- U.isJavaType ((fst • U.returnType) sym.typ.rho)
        U.changeSym sym.{rkind = RState.fromList [RSafeTC, RValue]}

returnKind syms (sym@SymV {expr = Just x, depth = 0}) = do
        w      <- returnExprKind syms sym x
        self   <- references [sym.sid] x        -- is it self-referential?
        rec    <- references syms x             -- is it recursive
        (_, deps) <- U.fundep sym
        -- depsyms   <- mapSt U.findV deps
        sx        <- isSimple x
        let local = sym.name.isLocal                            -- is this a local item?
            fwrefs
                | local                = self > 0
                | MName{}  <- sym.name = not (null deps)        -- possible forward references?
                | null syms            = self > 0
                | [mutual] <- syms     = mutual != sym.sid || self > 0
                | otherwise            = true
            safe   = if rec > 0 then RState.empty else RState.singleton RSafeTC
            simple = if sx && not fwrefs && self == 0 
                    then RState.singleton RSimple 
                    else RState.empty
            stricter = null sym.typ.bound           -- don't make 'undefined' strict!
                        && not local
                        && RSafeTC `member` safe
                        && RSimple `member` simple 
                    || Strictness.isStrict sym.strsig   -- if it is strict anyway        
            value  = RState.singleton (if except then  RValue else RAlways)   
            rkind = (safe.union simple).union value
            stri  = if except && not (Strictness.isStrict sym.strsig)
                    then S[] else sym.strsig
            except 
                | stricter,
                  not (RSimple `member` simple),
                  RValue `member` w,
                  not (RSafeTC `member` w)  = false -- don't return a lazy result
                                                    -- and force it right away in the eval() fun
                | stricter, local, self > 0 = false -- local self refs must be lazy 
                | otherwise                 = stricter
        U.changeSym sym.{rkind, strsig = stri}

returnKind syms (sym@SymV {expr = Just x}) = do
        w      <- returnExprKind syms sym x
        sx     <- isSimple x
        let rkind = if sx then w.unionE RSimple else w
        U.changeSym sym.{rkind}

--- assume abstract class functions are tail call safe
returnKind syms (sym@SymV {expr = Nothing, name = MName _ _}) 
    = U.changeSym sym.{rkind=RState.singleton RSafeTC}
returnKind _ _ = stio ()     -- abstract methods

{--
 * how often the symbol with 'Symbol.sid' is referenced in 'Expr' @x@
 -}
references sids x = U.foldEx true refs 0 x
    where
        refs n (Vbl {pos,name}) = do
            -- g <- getST
            -- U.logmsg TRACE7 pos ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice name g)
            sym <- U.findV name
            if sym.sid `elem` sids then stio (Right (n+1)) else stio (Left n)
        refs n (Ifte c t e _) = do
            crefs <- references sids c
            trefs <- references sids t
            erefs <- references sids e
            stio (Right (n + crefs + max trefs erefs))
        refs n (Case {ex,alts}) = do
            xrefs <- references sids ex
            arefs <- mapSt altRefs alts
            stio (Right (n + xrefs + fold max 0 arefs))
        refs n (Lam {ex}) = do
            lrefs <- references sids ex
            stio (Right (n + lrefs))
        refs n (Let {env,ex}) = do
            syms  <- mapSt U.findV env
            srefs <- mapSt (references sids) [ subex | SymV{expr = Just subex} <- syms ]
            lrefs <- references sids ex
            stio (Right (n + 2*sum srefs + lrefs))             
        refs n x = do
            -- g <- getST
            -- U.logmsg TRACE7 (getpos x) ("references " ++ show n ++ " " ++ show sids ++ "  " ++ nice x g)
            stio (Left n)
        altRefs (CAlt {ex}) = references sids ex

{--
 * [usage] @returnExprKind syms symbol x@
 *
 * Look for the return expressions in @x@ and compute the minimum return kind.
 * If any symbol in @syms@ is called, it is regarded as recursive and not fit
 * for tailcall.
 *
 * A return expression is an application, literal, variable or constructor.
 *
 * - When it is a literal, unboxed return (6) is possible.
 * - When it is a local lambda or case bound variable,
 *   return will be according to the variable's strictness boxed or lazy.
 *   Otherwise, it's the return kind of the variable.
 * - Constructor is either a function or a nullary constructor - both are boxed.
 * - A tail recursive application is either 6 or 4, depending on return type
 * - A tail call to a native function or a constructor is 4 or 6 depending on their w-value
 * - Otherwise, if the application is saturated or a lambda/case-bound variable is applied,
 *   it's lazy.
 * - Unsaturated applications are boxed (function types)
 -}
returnExprKind syms sym (x@Lit {pos}) = stio (RState.fromList [RSafeTC, RValue])
returnExprKind syms sym (x@Con {pos}) = stio (RState.fromList [RSafeTC, RValue])
returnExprKind syms sym (x@Ann {ex})  = returnExprKind syms sym ex

returnExprKind syms sym (x@Vbl {name}) = do
    symv <- U.findV name
    g    <- getST
    case symv.expr of
        Nothing -> case symv.name of
            Local{} -> if symv.strsig.isStrict
                        then stio (RState.fromList [RSafeTC, RValue])
                        else stio (RState.fromList [RSafeTC, RAlways])             -- lambda/case bound
            _ -> case U.returnType symv.typ.rho of
                (_,[]) -> stio (BitSet.union (RState.singleton RSafeTC) symv.rkind)
                _      -> stio (RState.fromList [RSafeTC, RValue])      -- global function
        Just (Lam {})  -> stio (RState.fromList [RSafeTC, RValue])      -- return a local function
        Just vx -> let !r = symv.rkind `intersection` RState.singleton RSafeTC in 
                    if symv.strsig.isStrict 
                        then stio (r.unionE RValue)
                        else stio (r.unionE RAlways)

returnExprKind syms sym (ex@App a b typ) = do
    returnExprKind syms sym a
    returnExprKind syms sym b
    let (f,_) = head flatx
        args  = tail flatx
        flatx = U.flatx ex
        app = App a b typ
    case f of
        Vbl {name} -> do
            symf <- U.findV name
            let r  = symf.rkind `intersection` RState.singleton RSafeTC
                rw = symf.rkind `intersection` (RState.fromList [RSafeTC, RAlways, RValue])
            if isJust symf.nativ then stio (rw)
              else if (length args < symf.depth) 
                    then stio ((rw.differenceE RAlways).unionE RValue)     -- unsaturated function is a value
              else case symf.expr of
                    Nothing -> case name of
                        Local{} -> stio (RState.singleton RSafeTC)  -- application of lambda/case bound
                        _       -> stio (rw)                        -- global fun
                    Just _ -> do
                        g <- getST
                        if symf.sid == Symbol.sid sym
                            then stio (RState.fromList [RSafeTC, RTailRec, RValue])
                            else if null r || (symf.sid `elem` syms)
                                then stio (RState.singleton RAlways)    -- lazy recursive application
                                else stio (rw)                          -- same as called
        Con {name} -> stio (RState.fromList [RSafeTC, RValue])
        _ -> do
                n <- references syms f
                if n > 0
                    then stio (RState.singleton RAlways)       -- better safe than sorry
                    else stio (RState.singleton RSafeTC)


returnExprKind syms sym (Ifte c t e typ) = do
    rec <- references syms c    --
    returnExprKind syms sym c
    w1 <- returnExprKind syms sym t
    w2 <- returnExprKind syms sym e
    let -- always = not (RValue `member` w1) && not (RValue `member` w2)
        -- value  = (RValue `member` w1) && (RValue `member` w2)
        res = if rec > 0 
            then minRkind w1 w2 `difference` RState.fromList [RSafeTC, RValue] 
            else minRkind w1 w2
    stio (res)

returnExprKind syms sym (x@Lam {ex}) = returnExprKind syms sym ex
        
returnExprKind syms sym (x@Let {env,ex}) = do
        returnNames syms env
        returnExprKind syms sym ex
        
returnExprKind syms sym (x@Case {ex, alts}) = do
    returnExprKind syms sym ex
    rec     <- references syms ex
    wsalts <- mapSt (altExprKind syms sym) alts
    let m = foldl1 minRkind wsalts
        res = if rec > 0 then m `difference` RState.fromList [RSafeTC, RValue] else m
    stio (res)
returnExprKind syms sym _ = error "returnExprKindbad epr."

altExprKind syms sym (alt@CAlt {ex}) = returnExprKind syms sym ex

{--
    combine two rkinds by taking the minimum of the lower 3 bits and the maximum of
    the 2³ bit, which signifies tail recursion.
 -}
minRkind a b = (safetc.union tailbit).union wrbits where
    safetc  = if (RSafeTC `member` a) && (RSafeTC `member` b) 
                then RState.singleton RSafeTC else RState.empty
    tailbit = if (RTailRec `member` a) || (RTailRec `member` b)
                then RState.singleton RTailRec else RState.empty
    wrbits  = if (RValue `member` a) && (RValue  `member` b) 
                                     && (RSafeTC `member` safetc)
                then RState.singleton RValue
                else if (RAlways `member` a) && (RAlways `member` b)
                then RState.singleton RAlways
                else RState.empty

{--
 * [usage] returnNames names name
 *
 * gets the symbol and stores the information computed by 'returnKind' in the 'Symbol.rkind'
 * field.
 *
 * The @names@ list gives the names that are mutually dependend on this one.
 -}
returnNames sids nms = do
    syms  <- mapSt U.findV nms
    let !deps = sids ++ map Symbol.sid syms
    foreach syms (returnKind deps)
    -- returnKind nms sym
    -- U.changeSym sym.{rkind}

unrollSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- unrollExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       -- do nothing
unrollSym sym = do
    g <- getST
    U.fatal sym.pos (text ("unrollSym no SymV : " ++ sym.nice g))

unLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- unLetExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       -- do nothing
unLetSym sym = do
    g <- getST
    U.fatal sym.pos (text ("unLetSym no SymV : " ++ sym.nice g))

{-
singleLetSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- singleLetExpr x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()       // do nothing
singleLetSym sym = do
    g <- getST
    U.fatal sym.pos ("unrollSym no SymV : " ++ sym.nice g)
    -}

closedLambdaSym (vsym@SymV {pos})
    | Just x <- vsym.expr = do
        nx <- U.mapExBody true closedLambda x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
closedLambdaSym sym = do
    g <- getST
    U.fatal sym.pos (text ("closedLambdaSym no SymV : " ++ sym.nice g))

{-
renameSym (vsym@SymV {})
    | Just x <- vsym.expr = do
        nx <- U.mapEx true renameLocals x
        U.changeSym vsym.{expr = Just nx}
    | otherwise = stio ()
renameSym sym = do
    g <- getST
    U.fatal sym.pos (text ("renameSym no SymV : " ++ sym.nice g))

--- map an environment to contain changed names and symbols
renamedEnv = Tree.fromList • map renamekv • each
    where
       renamekv (k, sym@SymV {name=Local 0 s, sid}) = ((mangled s ++ "_" ++ U.base32 sid),
                                              sym.{name = Local 0 (mangled s ++ "_" ++ U.base32 sid)})
       renamekv (k, sym) = error ("bad env, k=" ++ k ++ ", name = " ++ show sym.name)

--- rename all local variables in patterns and expressions
renameLocals (lam@Lam{env,pat,ex}) = with env do
    g <- getST
    let nenv = renamedEnv env
    U.logmsg TRACE8 (getpos lam) (text ("renameLocals before: " ++ nice lam g ++ "  " ++ show ((keys env)) ++ "  " ++ show ((keys nenv))))
    npat <- replPat pat
    U.logmsg TRACE8 (getpos lam) (text ("renameLocals pattern " ++ nice npat g))
    nex  <- replVar (map Symbol.sid (values env)) ex
    let nlam = lam.{env=nenv, ex=nex, pat=npat}
    U.logmsg TRACE8 (getpos lam) (text ("renameLocals after:  " ++ nice nlam g))
    stio (Left nlam)
renameLocals (cas@Case {alts}) = do
    nalts <- mapSt renameAlt alts
    stio (Left cas.{alts=nalts})
renameLocals (letex@Let {env, ex})
        | [(k, SymV {sid, expr=Just _})] <- each env = do        -- exactly 1 definition
            g <- getST
            U.logmsg TRACE8 (getpos letex) (text ("renameLocals before: " ++ nice letex g ++ "  " ++ show ((keys env))))
            let repsym (k,v@SymV {sid, expr = Just x}) = do
                    nx <- with env (replVar [sid] x)
                    stio (k, v.{expr = Just nx})
                repsym (k,v) = stio (k, v)
            nlst <- mapSt repsym (each (renamedEnv env))
            U.logmsg TRACE8 (getpos letex) (text ("renameLocals new: " ++ show (map (fst) nlst)))
            nex <- with env (replVar [sid] ex)
            let nenv = Tree.fromList nlst
                nlet = letex.{ex=nex, env=nenv}
            U.logmsg TRACE8 (getpos letex) (text ("renameLocals before: " ++ nice nlet g))
            stio (Left nlet)
renameLocals other = stio (Left other)

--- rename local variables in a case alternative
renameAlt :: CAlt -> StG CAlt
renameAlt alt = with alt.env do
    g <- getST
    let nenv = renamedEnv alt.env
        -- renameX = [replName (Symbol.sid sym) (Symbol.name sym) | (nm, sym) <- each nenv]
        -- renameP = [replPat  (Symbol.sid sym) nm                | (nm, sym) <- each nenv]
    U.logmsg TRACE8 (getpos alt.pat) (text ("renameAlt before: " ++ nice alt.pat g ++ " -> " ++ nice alt.ex g))
    nex  <- replVar (map Symbol.sid (values alt.env)) alt.ex
    npat <- replPat alt.pat
    let nalt = alt.{env=nenv, ex=nex, pat=npat}
    U.logmsg TRACE8 (getpos alt.pat) (text ("renameAlt after:  " ++ nice npat g ++ " -> " ++ nice nex g))
    stio nalt
-}    

unrollExpr    = U.mapEx true unrollLet
unLetExpr x   = U.mapEx true unusedLet x >>= U.mapEx true unLet


unrollLet (x@Let {env,ex}) = do
        g <- getST
        U.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ x.nice g))
        -- first do the subexpressions
        let mapsub (sy@SymV {expr=Just x}) = do
                    x <- unrollExpr x
                    U.changeSym sy.{expr=Just x}
            mapsub sy = error "mapsub: no var"
        ex  <- unrollExpr ex
        syms <- mapSt U.findV env
        foreach syms mapsub
        let -- kvs =  each env
            xdep k = do sym <- U.findV k; ldep (k, sym)
            ldep (k, SymV {expr=Just (Lam {ex})})
                | #^.?let\$\d+$# <- QName.base k = do
                    deps <- letlocals ex
                    stio (k, deps)
            ldep (k, SymV {expr=Nothing}) = stio (k, [])
            ldep (k, SymV {expr=Just ex}) = do
                    deps <- letlocals ex
                    stio (k, deps)
            ldep (_,_) = error "ldep: no var"
        kdeps  <- mapSt xdep env
        -- env    <- foldSt pbind env kdeps
        let result = fold (sublet env) ex ((reverse • U.tsort) kdeps)
        U.logmsg TRACE7 (getpos x) (text ("unrollLet: " ++ result.nice g))
        stio (Right result)
    where {-
        sublet env inx [k]
                | #^.?let\$\d+$# <- k,
                  Just (vsym@SymV {expr=Just (Lam {ex,pat})}) <- lookup env k
                = Case (ck inx) ex [CAlt {pat, ex=inx}] Nothing
                where
                    ck (Case {ckind}) = ckind
                    ck _ = CNormal
                    -}
        sublet env xin locals = if null locals then xin else Let locals [] xin Nothing
        letlocals ex = do
            let thisSids = map QName.uid env
            usedvars <- U.foldEx true (localvar thisSids) [] ex
            stio (DL.unique usedvars)
        localvar sidset acc (Vbl {name=nm@Local{uid}}) = do
                -- sym <- U.findV nm
                if uid `elem` sidset 
                    then stio (Left (nm:acc))
                    else stio (Left acc)
        localvar sidset acc _ = stio (Left acc)
        {-
        -- here we decide whether to translate the pattern binding
        -- conservatively (let$1 = x; a = case let$1 of (a,b) -> a; b = ...
        -- or to a case (which is actually done in sublet later)
        pbind :: [QName] -> (QName, [QName]) -> StG [QName]
        pbind env (k, deps)
            | k.base ~ #^.?let\$\d+$# = do
                ksym <- U.findV k
                case ksym of
                    SymV {pos,expr = Just (Lam {pat,ex})} = do
                        let patnms = map U.pVarLocal (U.patVars pat)                        
                        -- if the pattern binding depends on itself somehow
                        if any (`elem` patnms) deps  -- if any dependency is contained in pat names
                            then do -- conservative ksym ex pat patnms
                                U.changeSym ksym.{expr = Just ex}  -- let$123 = x
                                foreach patnms (mkCase pat ksym)
                                stio (env ++ patnms) 
                            else stio (filter (`notElem` patnms) env)
                    _ -> stio env                    
            | otherwise = stio env
            where   
                mkCase pat sym patname = do
                    psym <- U.findV patname
                    npat <- U.pReturn pat
                    let npn = head [ Vbl{pos, name=Local uid var,typ=Nothing} | 
                                PVar{pos,uid,var} <- U.patVars npat,
                                var == patname.base ]
                        cas = Case CNormal letvar  [CAlt {pat=npat, ex=npn}] Nothing
                        letvar = Vbl{pos = Symbol.pos sym, typ = Nothing,
                                                name = Symbol.name sym}                                                
                    U.changeSym psym.{expr = Just cas}
                                -}
unrollLet x = stio (Left x)


--- copy expr and re-establish type
recycle expr rho = do
        g <- getST
        expr <- U.copyExpr Nil expr
        expr <- U.untypeExpr expr
        let freevars =  U.freeTVars [] rho
        (metas, rho) <- TCU.instantiateTvs (ForAll (map Tau.varkind freevars) rho)
        x <- checkRho expr rho
        foreach (zip metas freevars) (uncurry unInst)
        x <- zonkExpr x
        x <- U.mapEx true substInst x
        U.logmsg TRACE9 (getpos expr) (text ("recycled  " ++ nice x g))
        stio x
    where
        -- restore old type variables
        -- our instantiated type variable could have been unified
        -- with something else, so follow the unification path
        -- until we find an unbound type variable
        unInst (Meta Flexi{ref}) tvar = do
                bound <- doio (ref.get)
                case bound of
                    Just tau -> unInst tau tvar
                    Nothing  -> doio (ref.put (Just tvar))
        unInst _ _ = return ()  

recyclex :: Expr -> StG Expr
recyclex expr = U.copyExpr Nil expr {- case expr.typ of
    Just sigma -> recycle expr sigma
    _ -> do
        g <- getST
        U.fatal (getpos expr) (text("recyclex untyped: " ++ nicer expr g)) -}

{--
 * [returns] *@true@* if expression is simple. See 'pass9' for more information.
 *
 * A simple expression can be translated to a java expression and will not need
 * blocks, if-then-else constructs, auxiliary declarations etc.
 -}
isSimple (App a b _)     = liftM2 (&&) (isSimple a) (isSimple b)
isSimple (Ifte a b c _)  = liftM2 (&&) (isSimple a)
                            (liftM2 (&&) (isSimple b) (isSimple c))
isSimple (Ann {ex})      = isSimple ex
isSimple (Vbl {pos})     = return true
isSimple (Lit {pos})     = return true
isSimple (Con {pos})     = return true
isSimple (Lam {ex})      = isEasy ex
isSimple _               = return false

mkSimple (x@Vbl {pos})     = return x
mkSimple (x@Lit {pos})     = return x
mkSimple (x@Con {pos})     = return x
--- @p -> x@ is simple if @x@ is easy
mkSimple (x@Lam {ex})      = do
    ex <- mkEasy 0 ex
    return x.{ex}
mkSimple (x@Ann {ex}) = do
    ex <- mkSimple ex
    return x.{ex}
mkSimple x = do
        is <- isSimple x
        if is then return x
        else mkS x 
    where
        -- any expression can be made simple through (\_ -> easy x) ()
        mkS x = do
            e <- mkEasy 0 x
            let lam = Lam {pat = PCon {pos, qname=unitName, pats=[]}, 
                           ex = e,
                           typ = Just (
                                ForAll [] (
                                    RhoFun [] (TC.sigFor "()")
                                           (unJust e.typ).rho))}
                pos = Position.null                                           
                unitName = MName (TC.tc "()").name "()"
                uni = Vbl {pos, name=unitName, typ = Just (TC.sigFor "()")}
            g <- getST
            U.hint (getpos e) (text("extra class file needed for complicated expression " ++ nicer e g))                                           
            return (App lam uni e.typ)
{--
 * [returns] *@true@* if expression is easy. See 'pass9' for more information.
 *
 * An easy expression can be translated to a series of java statements
 * with a final return, i.e. to a valid method body.
 -}

isEasy (App a b _)       = liftM2 (&&) (isSimple a) (isSimple b)
isEasy (Let {env,ex})    = do 
    e <- isEasy ex
    if e 
    then do
        syms <- mapSt U.findV env
        -- ssss <- mapSt isSimple [ x | s <- syms, x <- Symbol.expr s ]
        -- relaxed a bit cause we can handle it in the backend
        ssss <- mapSt isEasy [ x | s <- syms, x <- Symbol.expr s ]
        return (and ssss) 
    else return false
isEasy (Case {ex,alts})   = do
    e <- isSimple ex
    if e 
    then liftM and $ mapSt (isEasy • CAlt.ex) alts
    else return false
isEasy (Ifte a b c _)     = do
    e <- isSimple a
    if e then liftM2 (&&) (isEasy b)  (isEasy c)
    else return false
isEasy (Ann {ex})        = isEasy ex
isEasy x                 = isSimple x

--- tracing wrapper for 'mkEasy'
easyExpression x = do
        g <- getST
        if (U.isOn g.options.flags TRACE9)
        then do
            r <- mkEasy 0 x
            unless (r `exeq` x) do
                U.logmsg TRACE9 (getpos x) (text("mkEasy before: " ++ nice x g))
                U.logmsg TRACE9 (getpos r) (text("mkEasy after:  " ++ nice r g))
            easier r x
        else do
            r <- mkEasy 0 x
            easier r x
    where
        easier r x = if r `exeq` x then return r else easyExpression r
        -- unexact (structural) equality between expressions 
        exeq :: Expr -> Expr -> Bool
        exeq (a@Vbl{})  (b@Vbl{})  = a.name == b.name
        exeq (a@Con{})  (b@Con{})  = a.name == b.name
        exeq (a@Lit{})  (b@Lit{})  = a.kind == b.kind && a.value == b.value
        exeq (a@App{})  (b@App{})  = a.fun `exeq`  b.fun && a.arg `exeq` b.arg 
        exeq (a@Let{})  (b@Let{})  = a.ex  `exeq`  b.ex
        exeq (a@Lam{})  (b@Lam{})  = a.ex  `exeq`  b.ex
        exeq (a@Ann{})  (b@Ann{})  = a.ex  `exeq`  b.ex 
        exeq (a@Ifte{}) (b@Ifte{}) = a.cnd `exeq`  b.cnd && a.els `exeq`  b.els && a.thn `exeq`  b.thn
        exeq (a@Case{}) (b@Case{}) = a.ex  `exeq`  b.ex  && and (zipWith exeq (map CAlt.ex a.alts) (map CAlt.ex b.alts))
        exeq _          _          = false 
         
{--
    Perform program transformations that ensure an easy expression.
    This may imply making some sub expression simple, which, in turn,
    may imply making this sub-expression at least easy.
    The recursive process must terminate eventually at some expression that
    is inherently easy, because there is no such rule as
    > mkEasy x = mkSimple x
    but only strictly smaller expressions are considered.
        
    Annotations are pushed inside for @let@, @case@ and @if@ like in
    > if a then b else c :: t 
    > if a then b :: t else c :: t
    Hence if the result is  'Ann', the enclosed expression 
    is guaranteed not to be @let@, @case@ or @if@.
    This is important because many rules want to eliminate those in places where
    simple expressions are expected.
    
    1. Easy lambda expressions are arrived at by making the body easy.
    2. Easy @if@ eliminates @let@, @case@ and @if@ from the condition if present,
       otherwise makes the condition simple and the alternatives easy.
    3. Likewise, @case@ eliminates @let@, @case@ and @if@ from the scrutinized expression
       or makes it simple and all alternatives easy.
    4. Let makes the symbols' expression simple and the base expression easy.
    5. Function application removes @let@, @case@ and @if@ from both function and 
       argument. 
    -}
mkEasy :: Int -> Expr -> StG Expr    
mkEasy !d  (x@Lit{})    = return x
mkEasy !d (v@Vbl {name, typ = Just sig}) | not name.isLocal = do
            g <- getST
            if U.isOn g.options.flags INLINE 
                then do
                    sym <- U.findV v.name
                    -- U.logmsg TRACE9 (getpos v) (text ("can we inline " ++ nicer sym g ++ "?"))
                    case sym.expr of 
                        Just x 
                            -- we can't inline any class methods
                            -- because, for example 
                            -- (display x) would be replaced by (show x)
                            -- Hence the instance specific functionality was lost
                            -- e.g. display "foo" = "foo"  
                            -- and  show    "foo" = "\"foo\""
                            | MName tname _ <- v.name,
                              Just SymC{} <- tname.findit g = return v 
                            | sym.exported && (d >= sym.depth) = do
                                U.logmsg TRACE9 (getpos v) (text ("replace " ++ nice v g  ++ " :: " ++ nicer sig g))
                                x <- recycle x sig.rho
                                mkEasy d x
                        _ -> return v
                else return v    
mkEasy !d  (x@Vbl{})    = return x
mkEasy !d  (x@Con{})    = return x
mkEasy !d  (ann@Ann {ex})
    | Let{}  <- ex = mkEasy 0 ex.{ex <- ann.{ex=}}
    | Ifte{} <- ex = mkEasy 0 ex.{thn <- ann.{ex=}, els <- ann.{ex=}}
    | Case{} <- ex = mkEasy 0 ex.{alts <- map substAlt}
    | otherwise = do
        ex <- mkEasy 0 ex
        return ann.{ex}
    where substAlt :: CAlt -> CAlt
          substAlt calt = calt.{ex <- ann.{ex=}}
mkEasy !d  (x@Lam {ex}) = do
    ex <- mkEasy 0 ex
    return x.{ex}
mkEasy !d  (x@App f arg t) = do
        -- handle argument first
        -- f (case a of {p1->x;p2->y}) ==> case a of {p1->f x;p2->f y}
        -- f (if a then b else c) ==> if a then f b else f c
        -- f (let a = b in c) ==> let a = b in f c  
        ea     <- mkEasy 0 arg
        simple <- isSimple ea
        case ea of
            Let{} -> mkEasy 0 ea.{ex = App f ea.ex t, typ = t}
            Ifte a b c _ | not simple = do
                f' <- recyclex f
                mkEasy 0 ea.{thn = App f b t, els = App f' c t, typ=t}
            Case{} = do
                    alts <- mapSt adapt ea.alts
                    mkEasy 0 ea.{alts, typ=t}
                where
                    adapt :: CAlt -> StG CAlt
                    adapt calt = do
                        f' <- recyclex f
                        return calt.{ex = App f' calt.ex t}
            _ -> do
                arg <- if simple then return ea else mkSimple ea
                -- handle function with easy arg
                -- (let a = b in c) r => let a = b in c r
                -- (if a then b else c) r => if a then b r else c r
                -- (case a of {p1->b;p2->c}) r => case a of {p1->b r;p2->c r}
                -- (\p -> a) r => case r of \p -> a
                ef <- mkEasy (d+1) f
                -- simple <- isSimple ef
                case ef of
                    Let{} -> mkEasy 0 ef.{ex = App ef.ex arg t, typ = t}
                    Ifte{} -> do
                        r' <- recyclex arg
                        mkEasy 0 ef.{thn = App ef.thn arg t, els = App ef.els r' t, typ = t}
                    Case{} -> do
                            alts <- mapSt adapt ef.alts
                            mkEasy 0 ef.{alts, typ=t}
                        where
                            adapt :: CAlt -> StG CAlt
                            adapt calt = do
                                r' <- recyclex arg
                                return calt.{ex = App calt.ex r' t}
                    Lam{} -> do 
                        let cas = Case CNormal arg [CAlt{pat=ef.pat, ex=ef.ex}] t
                        mkEasy 0 cas
                    _ -> do
                        sf <- mkSimple ef
                        return (App sf arg t)

            
mkEasy !d (x@Let{env,ex}) = do             -- TODO: handle non-recursive let/case/if
        syms <- mapSt U.findV env
        mkEasyLet x syms
    where
        mkEasyLet (x@Let{env=[Local{uid}],ex}) [sym]
            | Just (cas@Case{alts=[alt]}) <- Symbol.expr sym, isAtomic alt.ex = do       
                -- handle  let a = case ... of p -> x in foo a
                --         case ... of p -> foo x
                g <- getST
                U.logmsg TRACE9 (getpos x) (text("mkEasyLet before: " ++ nice x g))
                let alt = head cas.alts
                ex <- replSid uid alt.ex ex
                let neu = cas.{alts=[alt.{ex}]}
                U.logmsg TRACE9 (getpos x) (text("mkEasyLet after:  " ++ nice neu g))
                mkEasy 0 neu  
        mkEasyLet (x@Let{env,ex}) syms = do
            foreach syms easySym 
            ex <- mkEasy 0 ex
            return x.{ex}
        mkEasyLet _ _ = undefined
            
mkEasy !d (outer@Case{}) = do
    ea     <- mkEasy 0 outer.ex
    simple <- isSimple ea
    
    case ea of
        -- case let a = b in c of {p1->x;p2->y}
        -- let a = b in case c of {p1->x;p2->y}
        Let{} -> mkEasy 0 (Let {env = ea.env, defs = [], typ = outer.typ,
                    ex = outer.{ex = ea.ex}})
        -- case if a then b else c of {p1->x;p2->y}
        -- if a then case b of {p1->x;p2->y} else case c of {p1->x;p2->y}
        Ifte{} | not simple -> do
            let thn = outer.{ex = ea.thn}
            els <- recyclex outer.{ex = ea.els}
            mkEasy 0 ea.{thn,els,typ=outer.typ}
        -- case case a of {b -> c; d -> e} of {f -> g; h -> i}
        -- case a of {b -> case c of {f -> g; h -> i}; d -> case e of {f' -> g; h' -> i}}
        Case{} -> do
                alts <- mapSt adapt ea.alts
                mkEasy 0 ea.{alts, typ=outer.typ, 
                    ckind = if outer.ckind == CWhen then CWhen else ea.ckind}
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex outer.{ex = calt.ex}
                    return calt.{ex}
        _ -> do
                g      <- getST
                -- case elimination possible?
                let alt1 = head outer.alts
                    match = sMatch g alt1.pat ea Nil
                    sxs = maybe [] each match
                substOk <- forM sxs (checkSubst alt1.ex) 
                case match of
                    Just tree | and substOk,
                                length outer.alts == 1 = do
                        ex <- foldM doSubst alt1.ex sxs
                        mkEasy 0 ex
                    _ = do
                        sa  <- if simple then return ea else mkSimple ea
                        alts <- mapSt easyAlt outer.alts
                        return outer.{ex=sa, alts}
            where
                easyAlt calt = do
                    ex <- mkEasy 0 (CAlt.ex calt)
                    return calt.{ex}
                checkSubst ex (uid, x) 
                    | isAtomic x = return true
                    | otherwise = do
                        n <- references [uid] ex
                        return (n < 2)
                doSubst ex (uid, x) = replSid uid x ex
                
                    
        
mkEasy !d  (Ifte a x y t) = do
    ea     <- mkEasy 0 a
    simple <- isSimple ea
    case ea of
        -- if let a = b in c then x else y
        -- let a = b in if c then y else y
        Let{} -> mkEasy 0 (Let {env=ea.env,defs=[],typ=t,
                    ex = Ifte ea.ex x y t})
        -- if (if a then b else c) then x else y
        -- if a then (if b then x else y) else (if c then x' else y')
        Ifte a b c _ | not simple -> do
            let thn = Ifte b x y t
            x' <- recyclex x
            y' <- recyclex y
            let els = Ifte c x' y' t
            mkEasy 0 (Ifte a thn els t)
        -- if (case a of p1 -> b; p2 -> c ...) then x else y
        -- case a of p1 -> if b then x else y; p2 -> if c then x else y   
        Case{ckind,ex=a,alts} -> do
                alts <- mapSt adapt alts
                mkEasy 0 Case{ckind,ex=a,typ=t,alts} 
            where
                adapt :: CAlt -> StG CAlt
                adapt calt = do
                    ex <- recyclex (Ifte calt.ex x y t)
                    return calt.{ex}
        _ -> do
            sa  <- if simple then return ea else mkSimple ea
            ex  <- mkEasy 0 x
            ey  <- mkEasy 0 y
            return (Ifte sa ex ey t)
-- should not happen
mkEasy !d  (x@ConFS{})  = return x
mkEasy !d  (x@Mem{})    = return x
            
    
--- return the symbol ids of all local variables introduced in this expression and its subexpression
innerSids ex = U.foldEx true collect Nil ex
    where
        patSids env = map Pattern.uid (U.patVars env)
        collect t (Lam {pat}) = stio (Left (fold including t (patSids pat)))
        collect t (Let {env}) = stio (Left (fold including t (map QName.uid env)))
        collect t (Case {alts}) = stio (Left (fold union t (map altSids alts)))
        collect t x = stio (Left t)
        altSids (CAlt {pat}) = fromKeys (patSids pat)

--- @replSid sid r ex@ - replace local variables referncing sid with r in ex
replSid sid r ex = U.mapEx true action ex
    where
        action (v@Vbl {name=Local {}}) = do
            sym <- U.findV v.name
            if sym.sid == sid then stio (Right r) else stio (Right v)
        action x = stio (Left x)

--- @replName sid nm ex@ - rename variables that references sid in ex
replName sid nm ex = U.mapEx true action ex
    where
        action (v@Vbl {name,pos}) = do
            sym <- U.findV name
            if sym.sid == sid then do
                changeST Global.{sub <- SubSt.{
                           idKind <- insertkv (KeyTk pos.first) (Right nm)}}
                stio (Right v.{name=nm}) 
            else stio (Right v)
        action x = stio (Left x)

-- rename all variables that are element of sids
replVar sids = U.mapEx true action
    where
        action (v@Vbl {name=Local uid nm}) = do
            sym <- U.findV v.name
            if sym.sid `elem` sids
                then stio (Right v.{name=Local uid (mangled nm ++ "_" ++ U.base32 sym.sid)})
                else stio (Right v)
        action x = stio (Left x)

replPat pat = case pat of
    PCon {pats} = do
        npats <- mapSt replPat pats
        stio pat.{pats = npats}
    PConFS{} = U.fatal (getpos pat) (text "PConFS must not happen")
    _ | pat.{var?}, pat.{uid?} = do
            sym <- U.findV (Local pat.uid pat.var)
            if pat.{pat?}       -- PAt !
                then do
                    p <- replPat pat.pat
                    stio  pat.{var = mangled pat.var ++ "_" ++ U.base32 sym.sid, pat = p}
                else stio pat.{var = mangled pat.var ++ "_" ++ U.base32 sym.sid}
      | pat.{pat?} = do
            p <- replPat pat.pat
            stio pat.{pat=p}
      | otherwise = stio pat

{--
    Rename unused patterns to "_"
    
    Later, in code generation, those patterns will be ignored
    -}
rmUnusedPat :: [Int] -> Pattern -> Pattern
rmUnusedPat unused p = case p of
        PVar{pos, uid, var}
            | var == "_"        = p
            | uid `elem` unused = p.{var = "_"}
            | otherwise         = p
        PCon{pos, qname, pats}  = p.{pats <- map (rmUnusedPat unused)}
        PConFS{pos, qname, fields} -> undefined    -- TODO: complete code
        PAt{pos, uid, var, pat}
            | uid `elem` unused = rmUnusedPat unused pat
            | otherwise         = p
        PUser{pat, lazy}        = p.{pat <- rmUnusedPat unused}
        PLit{pos, kind, value}  = p
        PAnn{pat, typ}          = p.{pat <- rmUnusedPat unused}
        PMat{pos, uid, var, value}
            | uid `elem` unused = PLit{pos, kind=LRegex, value}
            | otherwise         = p
    

--- find and remove unused local definitions
unusedLet (x@Let {env,ex}) = do
        down <- references (map QName.uid env) ex
        if down == 0
            then do
                syms <- mapSt U.findV env
                g <- getST
                foreach syms (\(sym::Symbol) ->
                    unless (sym.name.base ~ ´^_´) do
                        U.hint (getrange sym) (msgdoc (
                            nicer sym g ++ " is not used anywhere."))
                    )
                stio (Left ex)
            else stio (Left x)
unusedLet x = stio (Left x)


--- lift mutual recursive let functions to the top level
unLet (x@Let {env,ex}) | length env > 1 = do
    vals <- mapSt U.findV env
    unLetMutual vals x 
  where
    unLetMutual :: [Symbol] -> Expr -> StG (Either Expr Expr)
    unLetMutual vals (x@Let {env,ex}) = do
        g <- getST
        freevbls <- toPass
        case freevbls of
            [] -> do
                gsyms  <- mapSt globalize vals
                foreach gsyms U.enter
                let vgs = zip vals gsyms
                syms   <- mapSt (mkGlobal vgs) vgs
                newlet <- foldSt replsym ex vgs
                U.logmsg TRACE7 pos (text ("changed  " ++ nice newlet g))
                foreach syms U.changeSym
                foreach (map Symbol.name syms) unLetName
                stio (Left newlet)
            xs -> do
                let part1 = msgdoc ("implementation restriction: mutual recursive local functions"
                        ++ " that use variables bound in enclosing lexical scopes"
                        ++ " are currently not supported.")
                    part2 = text "functions: " <+> sep "," (map (text • flip nice g • Symbol.name) vals)
                    part3 = text "variables: " <+> sep "," (map (text • flip nice g • Symbol.name) freevbls)
                    part4 = text "There are two possible workarounds:"
                    part5 = text "- If possible, make" <+> lit (length vals - 1) <+> text "functions local to the remaining one."
                    part6 = text "- Pass the variables as arguments."
                U.error (getpos x) (part1 </> nest 4 (part2 </> part3 </> part4 </> part5 </> part6))
                stio (Left x)
      where
        pos = getpos x

        exprs :: [Expr]
        exprs = map (unJust • Symbol.expr) vals

        freeSym :: Expr -> StG [Symbol]             -- free variables in expression
        freeSym x = do
                used  <- U.localSyms x
                inner <- innerSids   x
                let uids = filter (not • (inner `contains`)) (keys used)
                mapSt U.findV   [ Local uid "_" | uid <- uids ] 
                

        toPass :: StG [Symbol]           -- symbols we must pass to each global val
        toPass = do
            exsyms <- mapSt freeSym exprs
            stio ((uniq • sort) [ s | ss <- exsyms, s <- ss, s `notElem` vals ])

        globalize :: Symbol -> StG Symbol
        globalize sym = do
            g <- getST
            let name = U.unusedName (VName (Global.thisPack g) (sym.name.base)) g
            stio sym.{name, sid=0, expr = Nothing, vis = Private}

        replsym :: Expr -> (Symbol, Symbol) -> StG Expr
        replsym x (sym,gsym) = replName sym.sid gsym.name x


        mkGlobal :: [(Symbol, Symbol)] -> (Symbol,Symbol) -> StG Symbol
        mkGlobal vgs (sym,gsym) = do
            let ex = unJust sym.expr
            ex <- foldSt replsym ex vgs
            -- sym <- globalize sym
            g <- getST
            U.logmsg TRACE7 pos (text ("global: " ++ gsym.name.nice g ++ " = " ++ nice ex g))
            let vks  = map Tau.varkind (U.freeTVars [] sym.typ.rho)
            let typ = ForAll vks sym.typ.rho
            changeST Global.{sub <- SubSt.{
                                idKind <- insertkv (KeyTk gsym.pos.first) (Right gsym.name)}}
            stio gsym.{expr = Just ex, typ}

        unLetName nm = do
            symv <- U.findV nm
            unLetSym symv
    unLetMutual vals x = error "unLetMutual"

unLet (xlet@Let {env=letenv,ex=letex,typ=lettyp})
        | [x] <- letenv = do                  -- let x = ... in ex
    sym <- U.findV x
    case sym.expr of
        Just (Lam {pat,ex,typ}) = do           -- let x = \_ -> ... in ex
            ex    <- U.mapEx true unLet ex
            used  <- U.localSyms ex
            inner <- innerSids ex
            let thisSids = fold including inner (sym.sid:[ uid | PVar{uid} <- U.patVars pat ])  -- including x
            if all (thisSids `contains`) (keys used)         -- ex uses only x and
              then do
                g <- getST
                let name = U.unusedName (VName g.thisPack x.base)  g
                ex <- replName sym.sid name ex  -- no reference to x anymore
                letex2 <- replName sym.sid name letex  -- in the inner of the lambda or the let ex
                let lamx = Lam {pat,ex,typ}
                let vks  = map Tau.varkind (U.freeTVars [] sym.typ.rho)
                let typ  = ForAll vks sym.typ.rho
                U.enter sym.{sid = 0, name, expr = Just lamx, vis = Private, typ}
                changeST Global.{sub <- SubSt.{
                                idKind <- insertkv (KeyTk sym.pos.first) (Right name)}}
                U.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice lamx g ++ " in ... replaced with " ++ nice letex2 g))
                U.logmsg TRACE7 sym.pos (text ("new function is " ++ name.nice g))
                unLet letex2       -- other opportunities possible here
              else do
                U.changeSym sym.{expr = Just (Lam {pat,ex,typ})}
                letex <- U.mapEx true unLet letex
                stio (Right (Let {env=letenv,ex=letex,typ=lettyp,defs=[]}))
        Just cx = do
            e <- isSimple cx
            if e then do
                self <- references [sym.sid] cx
                down <- references [sym.sid] letex
                if self == 0 && down == 1       -- used exactly once, note that use
                                            -- in a local function counts twice.
                    
                then do
                    let inline = if U.isPSigma sym.typ then cx
                                    else Ann {ex = cx, typ = Just sym.typ}
                    ex <- replSid sym.sid inline letex
                    g <- getST
                    U.logmsg TRACE7 sym.pos (text ("let " ++ nice x g ++ " = " ++ nice inline g ++ " in ... replaced with " ++ nice ex g))
                    unLet ex
                else stio (Left xlet)
            else stio (Left xlet)
        other -> stio (Left xlet)
unLet x = stio (Left x)

{--
    tell if an expression is just a literal, variable or constructor name
 -}
isAtomic Vbl {} = true
isAtomic Lit {} = true
isAtomic Con {} = true
isAtomic _      = false

--- tell if a pattern is just a simple variable 
-- private isPVar (PStrict p) = isPVar p
private isPVar (PVar{})    = true
private isPVar _           = false

--- tell if a pattern is a variable or a constant or a nullary constructors
isPVarOrPLit  PVar{} = true
isPVarOrPLit  PLit{} = true
isPVarOrPLit  PCon{pats=[]} = true
isPVarOrPLit  _             = false

{--
    @sMatch tree pat ex@ matches pattern @pat@ symbolically with expression @ex@ 
    and returns either @Nothing@ if there is no match or @Just tree@ where the
    'Tree' maps local unique numbers to expressions.
    
    The symbolic match matches 
    - /v/ with any /x/ and binds /v/ to /x/
    - /C/ with /C/
    - /Con p1 p2 ...pn/ with /Con x1 x2 xn/ if all subpatterns are literals or variables
      and match their corresponding subexpressions
      and binds the variables to the corresponding expressions.
    - /Con p1 ... pn/ with /x/ if /Con/ is a product or newtype constructor 
      and all subpatterns are variables. Nothing is bound.
    
    This is used in case elimination.
    Note that strict patterns are not matched.  
    -}
sMatch g PVar{uid}        x               tree = Just (tree.insert uid x)
sMatch g PLit{value=pval} Lit{value=xval} tree = if xval == pval then Just tree else Nothing
sMatch g PCon{qname,pats} x               tree
    | Con{name}:xs <- map fst (U.flatx x),
      name == qname, 
      length pats == length xs = fold (>>=) (Just tree) (zipWith (sMatch g) pats xs)
      -- all isPVarOrPLit pats = fold (>>=) (Just tree) (zipWith (sMatch g) pats xs)
    -- productCon qname g, all isPVar pats = Just Nil  
sMatch g p x t = Nothing    

{-
closedLambda (app@App (Lam {pat,ex,typ}) b ty) = do
        g <- getST
        let pos = getpos app
        U.logmsg TRACE8 pos (text ("beta reduction on: " ++ nice app g))
        let result = Case CNormal b [CAlt {pat,ex}] ty
        U.logmsg TRACE8 pos (text ("results in: " ++ nice result g))
        closedLambda result

closedLambda (app@App a b ty) = do
        a <- U.mapEx true closedLambda a
        case a of
            Lam {} -> closedLambda (App a b ty)
            _ -> do
                b <- U.mapEx true closedLambda b
                stio (Right (App a b ty))
                -}

closedLambda (Lam {pat,ex,typ = Just sigma}) = do
        ex    <- U.mapEx true closedLambda ex   -- recurse
        used  <- U.localSyms ex                 -- find local vars used
        inner <- innerSids ex
        let thisSids = fold including inner  [ uid | PVar {uid} <- U.patVars pat ]
        if all (thisSids `contains`) (keys used)
            then do
                g <- getST
                -- u <- U.uniqid
                
                let name = U.unusedName (VName g.thisPack ("anon$" ++ show (getpos ex))) g
                    lamx = Lam {pat,ex,typ = Just sigma}
                    sym0  = U.patLocal (getpos ex) 0 "anonymous"
                    vks   = map Tau.varkind (U.freeTVars [] sigma.rho)
                
                typ  <- TCU.cleanSigma (ForAll vks sigma.rho)
                let sym   = sym0.{name, expr=Just lamx, vis=Private, typ}
                    var   = Vbl {pos=sym.pos, name, typ = Just sigma}
                U.enter sym
                sym <- U.findV sym.name
                depthSym sym
                sym <- U.findV sym.name
                U.logmsg TRACE8 sym.pos (text ("anonymous lambda  " ++ lamx.nice g 
                        ++ " replaced with " ++ var.nice g
                        ++ " :: " ++ sym.typ.nice g))
                stio (Right var)
            else stio (Right (Lam {pat,ex,typ = Just sigma}))

closedLambda (letex@Let{env,ex}) = do       -- do not change an inner symbol bound to a lambda
        syms <- mapSt U.findV env
        ex   <- U.mapEx true closedLambda ex
        foreach syms closedLambdaSym 
        return (Right letex.{ex})
        
closedLambda x = stio (Left x)

{- ############################### strictness analysis ########################## -}
{--
 * [usage] @lambdaStrictess x@
 * [returns] a list of 'Strictness' items derived from patterns of the lambda in @x@
 *           or the empty list if @x@ is not a lambda
 * [see]     'patternStrictness'
 -}
lambdaStrictness (x@Lam {pat,ex}) = do
        sx <- lambdaStrictness ex
        sp <- patternStrictness pat
        stio (sp:sx)
lambdaStrictness x = stio []        -- not a lambda

{--
 * [usage] @patternStrictness pat@
 * [returns] the 'Strictness' value for the 'Pattern' @pat@
 * [requires] The environment where the pattern bound variables are held must be active.
 * [see] 'productCon'
 *
 * A pattern is /strict/, if it is /refutable/ or if it contains strict variables.
 * A pattern is /refutable/ if the match can possibly fail. Variables and product constructor
 * applications that contain only irrefutable patterns are irrefutable.
 -}
patternStrictness p = case p of
        PVar {uid,var} -> do
            v <- U.findV (Local uid var)
            stio v.strsig
        PAt {pos,uid,var,pat} -> do
            ps <- patternStrictness pat
            if ps == U then patternStrictness (PVar {pos,uid,var}) else stio ps
        PUser {pat, lazy} -> do
            ps <- patternStrictness pat
            if lazy then stio U
            else if ps == U then stio (S[]) else stio ps
        PLit {pos} -> stio (S[])
        PMat {pos} -> stio (S[])
        PAnn {pat} -> patternStrictness pat
        PCon {pos,qname,pats} = do
                g <- getST
                if not (productCon qname g) then stio (S[])
                  else do
                    ps <- mapSt patternStrictness pats
                    -- if all (U==) ps then stio U else stio (S ps)
                    return (S ps)
        PConFS {pos} -> U.fatal pos (text ("patternStrictness: found PConFS")) -- not allowed anymore at this time

{--
 * [usage] @patternRefutable g pat@
 * [returns] *true* if the pattern is refutable, *false* otherwise
 -}
patternRefutable g p = case p of
    PVar {var}      -> false
    PLit {pos}      -> true
    PMat {pos}      -> true
    PCon {pos,pats} -> not (productCon p.qname g) || any (patternRefutable g) pats
    _ | p.{pat?}    -> patternRefutable g p.pat
      | otherwise   -> false

{--
    1. usage: @elimPattern p@
    2. returns: *true* if the pattern supports _case elimination_.
    
    This is the case if the pattern is a variable or a constructor applied only to variables.
    -}
elimPattern (PVar {var}) = true
elimPattern (PCon {pats}) = all isPVar pats
elimPattern _ = false 

{--
 * [usage] @productCon name g@
 * [returns] *@true@* if @name@ names a constructor of a product type in @g@,
 *           *@false@* if it is the name of a sum type
 * [requires] @name@ must name a member of a data type in @g@
 -}
productCon (MName tname _) g = case tname.findit g of
        Just (SymT {product}) -> product
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
productCon _ _ = false

{--
    @newtypeCon qname g@ returns true if, and only if @qname@ is the name
    of the constructor for a _newtype_, i.e. a product type with a single
    constructor of arity 1.
 -}
newtypeCon (qname@MName tname _) g = case qname.findit g of
    Just SymD{} -> case tname.findit g of
        Just (SymT {newt}) -> newt
        other -> error ("productCon " ++ tname.nice g ++ " is not a type")
    sonst -> false
newtypeCon _ _ = false


{--
 * check a name for strictness, sids are already being checked
 -}
strictName sids nm = do
    g <- getST
    v <- U.findV nm
    when (v.state != StrictChecked) do
        U.logmsg TRACES v.pos (text ("strictness analysis for " ++ v.nice g))
    let ari = U.arity v             -- ... based on type
    case v of
        SymV {state = StrictChecked} = stio []          -- do nothing
        SymV {nativ = Just _} -> do
            let strsig = S (take ari allStrict)
            U.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            U.changeSym v.{strsig, state = StrictChecked}
            stio []
        SymV {expr = Just (x@Lam {ex})} -> do
            (x, syms) <- strictness (v.sid:sids) x
            s <- lambdaStrictness x     -- collect strictness from patterns
            U.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (S s)
                                    ++ " ignoring "
                                    ++ joined ", " (map (flip nice g • Symbol.name) syms)))
            U.changeSym v.{expr = Just x, strsig = S s, state = StrictChecked}
            stio syms
        SymV {expr = Just x} | ari >= 0 = do
                y <- eta ari x
                (y, syms) <- strictness (v.sid:sids) y
                s <- lambdaStrictness y
                let x = uneta ari y
                U.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show (if null s then U else S s)))
                U.changeSym v.{expr = Just x, strsig = if null s then U else S s, state = StrictChecked}
                stio syms
            where
                eta 0 x = stio x
                eta n x = do
                    let pos = getpos x
                    nums <- sequence (take n (repeat U.uniqid))
                    syms <- mapSt U.mkLocal  [ PVar{pos=pos,uid,var="$"} | uid <- nums ]
                    let vars = map Symbol.name syms
                        mkapp ex n = nApp ex (Vbl {pos, name=n, typ = Nothing})
                        -- mklam :: Expr -> Int -> Expr
                        mklam ex sym = Lam {pat,ex,typ=Nothing}
                            where pat = PVar {pos, uid=Symbol.sid sym, var="$"}
                                  -- env = insert Nil pat.var (U.patLocal pos pat.var).{sid=n}
                        -- \a\b -> x a b
                        body = fold mkapp    x vars
                        lam  = fold mklam body (reverse syms)
                    stio lam
                uneta n x = unapp n • unlam n $ x
                    where unlam 0 x = x
                          unlam n (Lam {ex}) = unlam (n-1) ex
                          unlam _ _ = error "unlam: no Lam"
                          unapp 0 x = x
                          unapp n (App a b _) = unapp (n-1) a
                          unapp _ _ = error "unapp: no App"

        SymV {state} -> do              -- pointless style or just var
            let strsig = if ari == 0 then U else S (take ari allLazy)
            U.logmsg TRACES v.pos (text ("strictness for " ++ v.name.nice g ++ " is "
                                    ++ show strsig))
            U.changeSym v.{strsig, state = StrictChecked}
            stio []
        other -> U.fatal other.pos (text ("strictness: strange symbol  " ++ other.nice g))


{--
 * - _usage_ @strictness sids x@
 * - _returns_ a possibly modified expression and a list of local symbols that appear strict
 *           under the assumption that @x@ itself is strict
 * - _requires_ environment must be set up correctly and the list @sids@ contains the
 *            symbol numbers of all named functions that are recursively checked to
 *            avoid infinite recursion
 *
 * Strictness rules for various expressions:
 * 1. if @\p -> x@ is strict then @x@ is strict
 * 2. if @case x of alt1;...@ is strict, then @x@ is strict if the pattern in the first
 *    case alternative is strict. Non immediate local
 *    names from subexpressions are strict only when they appear strict in all alternatives.
 * 3. if local variable @v@ is strict, then @v@ is strict
 * 4. if application @f a b c@ is strict, and @f@ is a variable, @f@ is strict
 * 5. if application @g x y@ is strict, and g has a strictness signature, then
 *      the arguments are strict if the signatur at the corresponding position is.
 *      Otherwise, if @g@ is checked recursively, assume all arguments as strict.
 *      If @g@ is encountered the first time, look at @g@'s lambda and use
 *      the lambda strictness for the arguments
 * 6. if g is checked recursively, all arguments are strict
 -}
strictness :: [Int] -> Expr -> StG (Expr, [Symbol])
strictness sids x = do
        g <- getST
        U.logmsg TRACES (getpos x) (text ("strictness for: " ++ nice x g))
        let mine = if x.{env?} then map QName.uid x.env
                    else if x.{pat?} then map Pattern.uid (U.patVars x.pat) 
                    else []
            my   = filter ((`elem`    mine) • Symbol.sid)
            them = filter ((`notElem` mine) • Symbol.sid)
        case x of
            Vbl {name=Local{}} -> do
                    v <- U.findV x.name
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g [v]))
                    stio (x, [v])
            Vbl {name} -> do
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Con {name} ->  do
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            Ifte c a b t -> do
                    (c, sc) <- strictness sids c
                    (a, sa) <- strictness sids a
                    (b, sb) <- strictness sids b
                    let syms = sc `uni` (sa `inter` sb)
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (Ifte c a b t, syms)
            Let {env,ex} -> do
                    -- let ve = values env
                    results <- mapSt (strictName sids) 
                                  (filter ((`notElem` sids) • QName.uid) env)
                    (ex, syms) <- strictness sids ex
                    let strictSyms = my syms
                        sSsids = map Symbol.sid strictSyms
                        upper = [ sres  | (loc, sres) <- zip env results,
                                        QName.uid loc `elem` sSsids ]
                        result = fold uni (them syms) upper
                    foreach strictSyms mark
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g result))
                    stio (x.{ex}, result)
            Lit {pos} ->  do
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g []))
                    stio (x, [])
            App _ _ _ -> do
                    (fx, syms) <- appstr (U.flatx x)
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g syms))
                    stio (U.unflatx fx, syms)
            Lam {ex, pat} -> do
                    (ex, syms) <- strictness sids ex
                    foreach (my syms) mark
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (them syms)))
                    refs <- mapSt (\sid -> references [sid] ex) mine
                    let unused = [ sid | (sid, 0) <- zip mine refs ]
                        upat = rmUnusedPat unused pat
                    stio (x.{ex, pat=upat}, them syms)
            Case {ex,alts} -> do
                    s0 <- patternStrictness (head alts).pat
                    U.logmsg TRACES (getpos x) (text ("first pattern is at least " ++ show s0))
                    altsyms <- mapSt strictAlt alts
                    let alts = map fst altsyms
                        syms = foldl1 inter (map snd altsyms)
                    -- extract S[...] of patterns
                    s1 <- do patternStrictness (head alts).pat
                    U.logmsg TRACES (getpos x) (text ("first pattern is in fact  " ++ show s1))
                    sx <- foldSt unisa s1 (tail alts)
                    U.logmsg TRACES (getpos x) (text ("all patterns together are " ++ show sx))
                    let ss = maxss s0 sx
                    U.logmsg TRACES (getpos x) (text ("combined with minimum     " ++ show ss))
                    (ex, xsyms) <- apply ex ss         -- take advantage of S[.....] if possible
                    U.logmsg TRACES (getpos x) (text ("strictness  " ++ nice x g ++ " :: " ++ names g (uni syms xsyms)))
                    stio (x.{ex, alts}, uni syms xsyms)
            Ann {ex} -> do
                    (ex,syms) <- strictness sids ex
                    stio (x.{ex}, syms)
            _ -> do
                U.fatal (getpos x) (text ("no strictness rule, turn on -xs -xr " ++ show (getpos x)))
                stio (x, [])
    where
        names g = show • map (flip QName.nice g • Symbol.name)
        inter as = filter (\b -> elemBy (using Symbol.sid) b as)
        uni as bs = as ++ [ b | b <- bs, not (elemBy (using Symbol.sid) b as)]
        maxss (S s1) (S s2) = S (zipWith maxss s1 s2)
        maxss U s = s
        maxss s U = s
        unisa :: Strictness -> CAlt -> StG Strictness
        unisa sleft alt = do
            sright <- patternStrictness alt.pat
            stio (uniss sleft sright)
          where
            uniss (S s1) (S s2) = S (zipWith uniss s1 s2)
            uniss U _ = U
            uniss _ U = U


        -- mark a symbol as strict
        mark sym = do
            g <- getST
            U.logmsg TRACES (Symbol.pos sym) (text (nice sym.name g ++ " marked as strict"))
            when (sym.strsig == U) do U.changeSym sym.{strsig = S[]}
        -- strictness for case alternative, same as in lambda
        strictAlt (alt@CAlt {pat,ex}) = do
                (lam, syms) <- strictness sids (Lam {pat,ex,typ=Nothing})
                stio (alt.{ex=lam.ex}, syms)
        subapp (a,b)   = apply a b
        apply ex U     = do
                            (x,_) <- strictness sids ex
                            stio (x, [])      -- lazy
        apply ex (S[]) = strictness sids ex -- strict
        apply ex (S ss) = do
            g <- getST
            case U.flatx ex of
                fex@((Con {name},_):xs) | productCon name g, length ss == length xs = do
                        U.logmsg TRACES (getpos ex) (text ("apply " ++ show (S ss)
                                                        ++ " to " ++ nice ex g))

                        exsyms <- mapSt (\(a,b) -> apply a b) (zip (map fst xs) ss)
                        let exs = map fst exsyms
                            syms = foldl1 uni (map snd exsyms)
                            flat = head fex : zip exs (map snd xs)
                        U.logmsg TRACES (getpos ex) (text ("apply found: " ++ names g syms))
                        stio (U.unflatx flat, syms)
                _ -> strictness sids ex
        convar (Con {name}) = true
        convar (Vbl {name}) = true
        convar _ = false
        appstr (app@((f,mbt):as)) | not (convar f) = do
            (f,syms) <- strictness sids f
            fas <- mapSt (strictness sids) (map fst as)
            let nas = zip (map fst fas) (map snd as)
            stio ((f,mbt):nas, syms)
        appstr (app@((f,mbt):as)) = do
            g <- getST
            v <- case f of
                    Con {name} -> U.findD name
                    Vbl {name} -> U.findV name
                    _ -> U.fatal (getpos f) (text ("Can't handle " ++ nice f g ++ "  applications"))
            let fsym | Local {} <- v.name = [v]
                     | otherwise = []
                mkAll = do
                    fapp <- mapSt (strictness sids) (map fst app)
                    let napp = zip (map fst fapp) (map snd app)
                    stio (napp, fsym)
            case v of
                SymV {state = Typechecked, expr = Nothing} = mkAll
                SymV {state = Typechecked, expr = Just (Lam {})} = if v.sid `elem` sids
                        then do
                            -- assume all are strict
                            asx <- mapSt (strictness sids) (map fst as)
                            stio ((f,mbt):zip (map fst asx) (map snd as), fold uni fsym (map snd asx))
                        else do
                            strictName sids v.name
                            appstr app              -- repeat
                SymV {state = Typechecked, expr = Just x}
                    | v.sid `notElem` sids = do
                            -- inline pointless
                            let fx = U.flatx x
                            (fxas, syms) <- appstr (fx ++ as)
                            let as = drop (length fx) fxas
                            stio ((f,mbt):as, fsym ++ syms)
                    | otherwise = mkAll
                SymD {strsig = U} -> mkAll
                SymD {strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {state = StrictChecked, strsig = U} -> mkAll
                SymV {state = StrictChecked, strsig = S ss} -> do
                        let xss = take (length as) (ss ++ repeat U)     -- make sure enough
                        U.logmsg TRACES (getpos f) (text ("appstr: xss=" ++ show xss ++ " for " ++ v.name.nice g))
                        exsyms <- mapSt subapp (zip (map fst as) xss)
                        stio ((f,mbt):zip (map fst exsyms) (map snd as), fold uni fsym (map snd exsyms))
                SymV {sid} -> do
                    U.fatal (v.pos) (text ("appstr: unexpected symbol " ++ nice v g
                        ++ ", state=" ++ show v.state
                        ++ ", expr="  ++ show (isJust v.expr)))
                _ -> error "appstr: no appropriate sym"
        appstr _ = error "appstr: []"

{--
 * [usage] @patsComplete g [pat, ...]@
 * [return] @Just p@ where @p@ is a pattern that is missing in the set or @Nothing@
 *      if the set of patterns is /complete/.
 * [required] the list of patterns must not be empty
 *
 *
 * A set of patterns is complete if it contains at least one irrefutable pattern
 * or if all possible literals / constructors are listed and for every constructor
 * the set of the subpatterns is complete.
 -}
patsComplete g [] = Just (PVar {pos=Position.null, uid=0, var = "unguarded"})  -- if all case alts carry open case when
patsComplete g ps
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (flip nice g) ps) ++ "]") = undefined
    -- Prelude.traceLn ("patsComplete [" ++ joined "," (map (show • not • patternRefutable g) ps) ++ "]") = undefined
    | any (not • patternRefutable g) ps = Nothing
    | otherwise                         = missing canonicPats
    where
        -- refutables  = filter (patternRefutable g) canonicPats
        canonicPats = map canonic ps
        -- only PCon, PLit and PVar are considered
        canonic (PMat {pos, value}) = PLit {pos, kind = LRegex, value}
        canonic (p@PCon {pos}) = p.{pats <- map canonic}
        canonic p | p.{pat?}   = canonic p.pat
        canonic p              = p
        pany                   = PVar {pos=Position.null, uid=0, var = "_"}
        -- compute the missing element from a list of refutable patterns
        missingLiteral [] = Just pany
        missingLiteral ls | any regex ls = Just (PLit {pos=Position.null, kind=LString,
                                            value="\"any string not matched by regular expression\""})
            where regex (PLit {kind = LRegex}) = true
                  regex _                      = false
        missingLiteral (ps@PLit {pos, kind}:_) = Just (PLit {pos, kind, value})
            where value = (head • filter (`notElem` (map Pattern.value ps))) (lany kind)
                  lany LBool = ["true", "false", "blödsinn"]
                  lany LString = U.allBinders
                  lany LChar   = map show (iterate Char.succ '!')
                  lany LInt    = map show (iterate Int.succ 42)
                  lany LLong   = map show (iterate Long.succ 42L)
                  lany LBig    = map show (iterate Integer.succ 42n)
                  lany LDouble = map show (iterate (0.42*)  3.14159)
                  lany LFloat  = map show (iterate (0.42f*) 3.14159f)
                  lany LRegex  = U.allBinders
        missingLiteral _ = Just pany
        -- compute the missing element from a list of refutable patterns
        missing [] = Just pany                              -- _
        missing (ps@(PLit {kind=LBool}:_)) = case map Pattern.value ps of
            tfs -> if all (`elem` tfs) ["true", "false"]
                then Nothing
                else missingLiteral ps
        missing (ps@(PLit {pos}:_))   = missingLiteral ps
        missing (ps@(PCon {qname}:_))
            | s:_ <- filter (not • (`elem` pnames) • Symbol.name) (cons qname) = Just (mkCon s)
            | otherwise = case (filter isJust • map groupcheck) (group ps) of
                some:_ -> some
                []  -> Nothing
            where
                pnames = map Pattern.qname ps
                cons (MName tname _) = case QName.findit tname g of
                    Just (SymT {env}) -> U.envConstructors env
                    _ -> []
                cons _ = []
                mkCon (SymD {name,flds}) = PCon {pos=Position.null, qname=name,
                                                    pats = map (const pany) flds}
                mkCon _ = error "mkCon: no constructor"
                group [] = []
                group (PCon {qname,pats}:ps) = (qname, pats:map Pattern.pats same):group other
                    where
                        same  = filter ((`==` qname) • Pattern.qname) ps
                        other = filter ((`!=` qname) • Pattern.qname) ps
                group _ = error "group: no PCon"
        missing _ = error "missing: bad patterns"
        -- check a group of patterns (QName, [[p11, p12, p13], [p21, p22, p23], ...])
        groupcheck (qname, [])    = Just pany                   -- cannot happen
        groupcheck (qname, []:_)  = Nothing                     -- nullary constructor
        groupcheck (qname, patss) = anongroup (PCon Position.null qname) patss
        -- [true, 2, c1]
        -- [false, b2, 3]
        -- [_, 1, _]            // irefs
        anongroup recon grp
            | length (head grp) == 1 = result (patsComplete g col1)     -- base case
            | all (not • patternRefutable g) col1 = -- the first column has only irrefutables
                anongroup (\ps -> recon (pany:ps)) cols
            | all (patternRefutable g) col1 = anonRgrp recon grp
            | Nothing <- anongroup recon irefs = Nothing
            | Nothing <- anonRgrp recon refs = Nothing
            -- there are some patterns with refutable heads and some with irrefutable ones
            | otherwise = anonRgrp  recon (refs ++ nrefs)
            where
                col1 = map head grp
                cols = map tail grp
                result Nothing = Nothing
                result (Just p) = Just (recon (p : map (const pany) (head cols)))
                (refs, irefs) = partitioned (patternRefutable g <~ head) grp
                nrefs = [ p:rest | _:rest <- irefs, p <- cons ]
                cons = constructors (head (head refs))
                -- constructors :: Pattern -> ([Pattern] ->
                constructors (lit@PLit {kind=LBool}) = [ lit.{value=s} | s <- ["true", "false"] ]
                constructors (con@PCon {qname=MName tname _}) = case QName.findit tname g of
                    Just (SymT {env}) ->
                        [ PCon con.pos sym.name (take (length sym.flds) dummies) |
                            (sym::Symbol) <- U.envConstructors env ] where
                                dummies = repeat (PVar con.pos 0 "_")
                    _ -> []
                constructors _ = []
                -- [[Just 1, a1, a2]         // refs
                --  [Just x, b1, b2]]
                -- [[Nothing, c1, c2]]            // irefs
                -- transform this to  [[1, a1, a2], [x, b1, b2]]  and [[c1,c2]]
                -- then check each as anon group
                anonRgrp recon grp
                    | Just x <- patsComplete g col1 = Just (recon (x : map (const pany) (head cols)))
                    | otherwise = loop groups
                    where
                        constructor (PCon {qname}) = qname
                        constructor (PLit {value}) = Local 0 value
                        constructor _ = error "constructor: ?"
                        subpats (PCon {pats}) = pats
                        subpats _             = []
                        recreate (PCon {pos, qname}) = PCon pos qname
                        recreate x                   = const x
                        groups = group grp
                        group [] = []
                        group ps = pss1 : group xs where
                          p1c = constructor (head (head ps))
                          (pss1, xs) = partitioned samecon ps
                          samecon p = constructor (head p) == p1c
                        col1 = map head grp
                        cols = map tail grp
                        loop [] = Nothing           -- complete!
                        loop (grp:grps) = case anongroup (f rest.length) ung of
                                Nothing -> loop grps
                                other   -> other
                            where
                                rec  = recreate (head (head grp))
                                rest = subpats  (head (head grp))
                                ung  = map uncon grp
                                uncon (p:ps) = subpats p ++ ps
                                uncon [] = undefined
                                f n xs = recon (rec (take n xs) : drop n xs)

{--
 * checks whether an expression is a case expression made from a guard (CWhen)
 * that has no trailing otherwise or irrefutable pattern match
 * If so, returns the expression or pattern that could cause the CaseWhen to fall through
 -}
openCaseWhen :: Global -> Expr -> Maybe (Either Expr Pattern)
openCaseWhen g (Case CWhen _ [alt1, alt2] _) = openCaseWhen g alt2.ex
openCaseWhen g (e@Case CWhen x [alt1] _)
    |  caseOtherwise g e              = Nothing           -- can't fall through
    |  isPTrue alt1.pat, !(isXTrue x) = Just (Left x)
    |  patternRefutable g alt1.pat    = Just (Right alt1.pat)
    |  otherwise = openCaseWhen g alt1.ex
openCaseWhen g (Let {ex}) = openCaseWhen g ex
openCaseWhen _ _ = Nothing

{--
 * tells if this is the pattern "true"
 -}
isPTrue (PLit {kind=LBool, value="true"}) = true
isPTrue p | p.{pat?} = isPTrue p.pat
isPTrue _ = false

{--
 * tells if this is the constant "true"
 -}
isXTrue (Lit {kind=LBool, value="true"}) = true
isXTrue (Vbl {name = VName p "otherwise"}) | pPreludeBase == p = true
isXTrue _ = false

{--
 * tells us if this is the "otherwise" case
 *  > case true of true -> notopencase
 -}
caseOtherwise g (Case CWhen x [alt] _)
    | isCaseWhen alt.ex = false
    | isXTrue x && isPTrue alt.pat = true
    | otherwise = !(patternRefutable g alt.pat)
    where
        isCaseWhen (Case CWhen _ _ _) = true
        isCaseWhen _ = false
caseOtherwise _ _ = false
